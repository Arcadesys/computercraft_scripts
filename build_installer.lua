-- Utility script that packages flattened factory_*.lua files into a single install_factory.lua payload

local flattened_pattern = "factory_*.lua"
local output_file = "install_factory.lua"

local path_separator = package.config:sub(1, 1)
local is_windows = path_separator == "\\"

local function collect_source_files()
    if not io.popen then
        error("Your Lua build does not expose io.popen; run this script with a standard Lua interpreter.")
    end

    local command

    if is_windows then
        command = string.format('cmd /C dir /b %s', flattened_pattern)
    else
        command = string.format("sh -c 'ls -1 %s 2>/dev/null'", flattened_pattern)
    end

    local handle, popen_error = io.popen(command, "r")

    if not handle then
        error("Unable to list source files: " .. tostring(popen_error))
    end

    local discovered_files = {}

    for line in handle:lines() do
        local trimmed = line:gsub("\r", "")

        if trimmed ~= "" then
            local lower_trimmed = trimmed:lower()

            if not lower_trimmed:find("file not found", 1, true)
                and not lower_trimmed:find("cannot access", 1, true)
            then
                table.insert(discovered_files, trimmed)
            end
        end
    end

    handle:close()

    table.sort(discovered_files)

    return discovered_files
end

local function read_file_contents(file_path)
    local file_handle, open_error = io.open(file_path, "rb")

    if not file_handle then
        error("Failed to open " .. file_path .. ": " .. tostring(open_error))
    end

    local contents = file_handle:read("*a")
    file_handle:close()

    return contents
end

local function decode_flat_path(flat_path)
    -- Interpret flattened names where single underscores represent path separators
    -- and doubled underscores round-trip literal underscores within a segment.
    -- Example: factory_manifest__entry.lua -> factory/manifest_entry.lua
    local decoded = {}
    local length = #flat_path
    local index = 1

    while index <= length do
        local character = flat_path:sub(index, index)

        if character ~= "_" then
            decoded[#decoded + 1] = character
            index = index + 1
        else
            local run_end = index

            while run_end <= length and flat_path:sub(run_end, run_end) == "_" do
                run_end = run_end + 1
            end

            local run_length = run_end - index

            if run_length % 2 == 1 then
                decoded[#decoded + 1] = "/"
                run_length = run_length - 1
            end

            for _ = 1, run_length / 2 do
                decoded[#decoded + 1] = "_"
            end

            index = run_end
        end
    end

    return table.concat(decoded)
end

local function derive_target_path(relative_path)
    if relative_path:find("/") then
        return relative_path
    end

    local basename, extension = relative_path:match("^(.*)(%.[^%.\\/]+)$")

    if not basename then
        return decode_flat_path(relative_path)
    end

    local decoded_basename = decode_flat_path(basename)
    return decoded_basename .. extension
end

local function build_packaged_entries(file_paths)
    local buffer = {}

    for _, relative_path in ipairs(file_paths) do
        local contents = read_file_contents(relative_path)
        local escaped_contents = string.format("%q", contents)
        local target_path = derive_target_path(relative_path)
        local entry = string.format('    { target_path = %q, content = %s }', target_path, escaped_contents)
        table.insert(buffer, entry)
    end

    return table.concat(buffer, ",\n")
end

local installer_template = [[
-- install_factory.lua
-- Auto-generated by build_installer.lua on %s
-- Installs or updates the packaged factory directory into this ComputerCraft computer.

local function ensureParentDirectories(filePath)
    local current_path = ""

    for directory in filePath:gmatch("([^/]+)/") do
        current_path = current_path == "" and directory or (current_path .. "/" .. directory)

        if not fs.exists(current_path) then
            fs.makeDir(current_path)
        end
    end
end

local packaged_files = {
%s
}

local written_file_count = 0

for _, file_entry in ipairs(packaged_files) do
    local target_path = file_entry.target_path

    ensureParentDirectories(target_path)

    if fs.exists(target_path) and not fs.isDir(target_path) then
        fs.delete(target_path)
    end

    local handle = assert(fs.open(target_path, "w"), "Unable to open " .. target_path)
    handle.write(file_entry.content)
    handle.close()

    written_file_count = written_file_count + 1
end

print(("Factory installer wrote %%d file(s)."):format(written_file_count))
]]

local function write_output_file(installer_source)
    local output_handle, open_error = io.open(output_file, "w")

    if not output_handle then
        error("Unable to create " .. output_file .. ": " .. tostring(open_error))
    end

    output_handle:write(installer_source)
    output_handle:close()
end

local function main()
    local file_paths = collect_source_files()

    if #file_paths == 0 then
        error("No source files matched pattern " .. flattened_pattern)
    end

    local packaged_entries = build_packaged_entries(file_paths)
    local installer_source = string.format(installer_template, os.date("!%Y-%m-%d %H:%M:%S UTC"), packaged_entries)

    write_output_file(installer_source)

    print(("Wrote %s with %d packaged file(s)."):format(output_file, #file_paths))
end

main()
