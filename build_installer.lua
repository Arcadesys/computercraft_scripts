-- Utility script that packages flattened factory_*.lua files into a single install_factory.lua payload.
-- This version runs entirely inside a ComputerCraft computer.
---@diagnostic disable: undefined-global

local flattened_pattern = "^factory_.-%.lua$"
local output_file = "install_factory.lua"

local function assert_computercraft_environment()
    if not fs or type(fs.list) ~= "function" then
        error("This script must run on a ComputerCraft computer.")
    end
end

assert_computercraft_environment()

local working_directory = shell and shell.dir() or ""

local function resolve_local(path)
    if path:sub(1, 1) == "/" then
        return path
    end

    if working_directory == "" or working_directory == "/" then
        return path
    end

    return fs.combine(working_directory, path)
end

local function collect_source_files()
    local listing_directory = working_directory ~= "" and working_directory or ""
    local ok, entries = pcall(fs.list, listing_directory)

    if not ok then
        error("Unable to list files in " .. (listing_directory ~= "" and listing_directory or "/") .. ": " .. tostring(entries))
    end

    local discovered_files = {}

    for _, entry in ipairs(entries) do
        local absolute_path = resolve_local(entry)

        if not fs.isDir(absolute_path)
            and entry ~= output_file
            and entry:match(flattened_pattern)
        then
            table.insert(discovered_files, entry)
        end
    end

    table.sort(discovered_files)

    return discovered_files
end

local function read_file_contents(relative_path)
    local absolute_path = resolve_local(relative_path)

    if not fs.exists(absolute_path) then
        error("Source file missing: " .. relative_path)
    end

    local handle, open_error = fs.open(absolute_path, "rb")

    if not handle then
        error("Failed to open " .. relative_path .. ": " .. tostring(open_error))
    end

    local contents = handle.readAll()
    handle.close()

    return contents
end

local function decode_flat_path(flat_path)
    -- Interpret flattened names where single underscores represent path separators
    -- and doubled underscores round-trip literal underscores within a segment.
    -- Example: factory_manifest__entry.lua -> factory/manifest_entry.lua
    local decoded = {}
    local length = #flat_path
    local index = 1

    while index <= length do
        local character = flat_path:sub(index, index)

        if character ~= "_" then
            decoded[#decoded + 1] = character
            index = index + 1
        else
            local run_end = index

            while run_end <= length and flat_path:sub(run_end, run_end) == "_" do
                run_end = run_end + 1
            end

            local run_length = run_end - index

            if run_length % 2 == 1 then
                decoded[#decoded + 1] = "/"
                run_length = run_length - 1
            end

            for _ = 1, run_length / 2 do
                decoded[#decoded + 1] = "_"
            end

            index = run_end
        end
    end

    return table.concat(decoded)
end

local function derive_target_path(relative_path)
    if relative_path:find("/") then
        return relative_path
    end

    local basename, extension = relative_path:match("^(.*)(%.[^%.\\/]+)$")

    if not basename then
        return decode_flat_path(relative_path)
    end

    local decoded_basename = decode_flat_path(basename)
    return decoded_basename .. extension
end

local function build_packaged_entries(file_paths)
    local buffer = {}

    for _, relative_path in ipairs(file_paths) do
        local contents = read_file_contents(relative_path)
        local escaped_contents = string.format("%q", contents)
        local target_path = derive_target_path(relative_path)
        local entry = string.format('    { target_path = %q, content = %s }', target_path, escaped_contents)
        table.insert(buffer, entry)
    end

    return table.concat(buffer, ",\n")
end

local installer_template = [[
-- install_factory.lua
-- Auto-generated by build_installer.lua on %s
-- Installs or updates the packaged factory directory into this ComputerCraft computer.

local function ensureParentDirectories(filePath)
    local current_path = ""

    for directory in filePath:gmatch("([^/]+)/") do
        current_path = current_path == "" and directory or (current_path .. "/" .. directory)

        if not fs.exists(current_path) then
            fs.makeDir(current_path)
        end
    end
end

local packaged_files = {
%s
}

local written_file_count = 0

for _, file_entry in ipairs(packaged_files) do
    local target_path = file_entry.target_path

    ensureParentDirectories(target_path)

    if fs.exists(target_path) and not fs.isDir(target_path) then
        fs.delete(target_path)
    end

    local handle = assert(fs.open(target_path, "w"), "Unable to open " .. target_path)
    handle.write(file_entry.content)
    handle.close()

    written_file_count = written_file_count + 1
end

print(("Factory installer wrote %%d file(s)."):format(written_file_count))
]]

local function write_output_file(installer_source)
    local output_path = resolve_local(output_file)

    if fs.exists(output_path) and not fs.isDir(output_path) then
        fs.delete(output_path)
    end

    local handle, open_error = fs.open(output_path, "w")

    if not handle then
        error("Unable to create " .. output_file .. ": " .. tostring(open_error))
    end

    handle.write(installer_source)
    handle.close()
end

local function main()
    local file_paths = collect_source_files()

    if #file_paths == 0 then
        error("No source files matched pattern factory_*.lua")
    end

    local packaged_entries = build_packaged_entries(file_paths)
    local installer_source = string.format(installer_template, os.date("!%Y-%m-%d %H:%M:%S UTC"), packaged_entries)

    write_output_file(installer_source)

    print(("Wrote %s with %d packaged file(s)."):format(output_file, #file_paths))
end

main()
