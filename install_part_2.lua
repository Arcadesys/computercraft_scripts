--[[ Local Installer Part 2 generated by bundle.ps1 ]]
local files = {}

files['lib/lib_inventory.lua'] = [========[---@diagnostic disable: undefined-globallocal inventory = {}local movement = require("lib_movement")local logger = require("lib_logger")local SIDE_ACTIONS = {forward = {drop = turtle and turtle.drop or nil,suck = turtle and turtle.suck or nil,},up = {drop = turtle and turtle.dropUp or nil,suck = turtle and turtle.suckUp or nil,},down = {drop = turtle and turtle.dropDown or nil,suck = turtle and turtle.suckDown or nil,},}local PUSH_TARGETS = {"front","back","left","right","top","bottom","north","south","east","west","up","down",}local OPPOSITE_FACING = {north = "south",south = "north",east = "west",west = "east",}local CONTAINER_KEYWORDS = {"chest","barrel","shulker","crate","storage","inventory",}inventory.DEFAULT_TRASH = {["minecraft:air"] = true,["minecraft:stone"] = true,["minecraft:cobblestone"] = true,["minecraft:deepslate"] = true,["minecraft:cobbled_deepslate"] = true,["minecraft:tuff"] = true,["minecraft:diorite"] = true,["minecraft:granite"] = true,["minecraft:andesite"] = true,["minecraft:calcite"] = true,["minecraft:netherrack"] = true,["minecraft:end_stone"] = true,["minecraft:basalt"] = true,["minecraft:blackstone"] = true,["minecraft:gravel"] = true,["minecraft:dirt"] = true,["minecraft:coarse_dirt"] = true,["minecraft:rooted_dirt"] = true,["minecraft:mycelium"] = true,["minecraft:sand"] = true,["minecraft:red_sand"] = true,["minecraft:sandstone"] = true,["minecraft:red_sandstone"] = true,["minecraft:clay"] = true,["minecraft:dripstone_block"] = true,["minecraft:pointed_dripstone"] = true,["minecraft:bedrock"] = true,["minecraft:lava"] = true,["minecraft:water_bucket"] = true,}local function noop()endlocal function normalizeSide(value)if type(value) ~= "string" thenreturn nilendlocal lower = value:lower()if lower == "forward" or lower == "front" or lower == "fwd" thenreturn "forward"endif lower == "up" or lower == "top" or lower == "above" thenreturn "up"endif lower == "down" or lower == "bottom" or lower == "below" thenreturn "down"endreturn nilendlocal function resolveSide(ctx, opts)if type(opts) == "string" thenlocal direct = normalizeSide(opts)return direct or "forward"endlocal candidateif type(opts) == "table" thencandidate = opts.side or opts.direction or opts.facing or opts.containerSide or opts.defaultSideif not candidate and type(opts.location) == "string" thencandidate = opts.locationendendif not candidate and type(ctx) == "table" thenlocal cfg = ctx.configif type(cfg) == "table" thencandidate = cfg.inventorySide or cfg.materialSide or cfg.supplySide or cfg.defaultInventorySideendif not candidate and type(ctx.inventoryState) == "table" thencandidate = ctx.inventoryState.defaultSideendendlocal normalised = normalizeSide(candidate)if normalised thenreturn normalisedendreturn "forward"endlocal function tableCount(tbl)if type(tbl) ~= "table" thenreturn 0endlocal count = 0for _ in pairs(tbl) docount = count + 1endreturn countendlocal function copyArray(list)if type(list) ~= "table" thenreturn {}endlocal result = {}for index = 1, #list doresult[index] = list[index]endreturn resultendlocal function copySummary(summary)if type(summary) ~= "table" thenreturn {}endlocal result = {}for key, value in pairs(summary) doresult[key] = valueendreturn resultendlocal function copySlots(slots)if type(slots) ~= "table" thenreturn {}endlocal result = {}for slot, info in pairs(slots) doif type(info) == "table" thenresult[slot] = {slot = info.slot,count = info.count,name = info.name,detail = info.detail,}elseresult[slot] = infoendendreturn resultendlocal function hasContainerTag(tags)if type(tags) ~= "table" thenreturn falseendfor key, value in pairs(tags) doif value and type(key) == "string" thenlocal lower = key:lower()for _, keyword in ipairs(CONTAINER_KEYWORDS) doif lower:find(keyword, 1, true) thenreturn trueendendendendreturn falseendlocal function isContainerBlock(name, tags)if type(name) ~= "string" thenreturn falseendlocal lower = name:lower()for _, keyword in ipairs(CONTAINER_KEYWORDS) doif lower:find(keyword, 1, true) thenreturn trueendendreturn hasContainerTag(tags)endlocal function inspectForwardForContainer()if not turtle or type(turtle.inspect) ~= "function" thenreturn falseendlocal ok, data = turtle.inspect()if not ok or type(data) ~= "table" thenreturn falseendif isContainerBlock(data.name, data.tags) thenreturn true, dataendreturn falseendlocal function inspectUpForContainer()if not turtle or type(turtle.inspectUp) ~= "function" thenreturn falseendlocal ok, data = turtle.inspectUp()if not ok or type(data) ~= "table" thenreturn falseendif isContainerBlock(data.name, data.tags) thenreturn true, dataendreturn falseendlocal function inspectDownForContainer()if not turtle or type(turtle.inspectDown) ~= "function" thenreturn falseendlocal ok, data = turtle.inspectDown()if not ok or type(data) ~= "table" thenreturn falseendif isContainerBlock(data.name, data.tags) thenreturn true, dataendreturn falseendlocal function shouldSearchAllSides(opts)if type(opts) ~= "table" thenreturn trueendif opts.searchAllSides == false thenreturn falseendreturn trueendlocal function peripheralSideForDirection(side)if side == "forward" or side == "front" thenreturn "front"endif side == "up" or side == "top" thenreturn "top"endif side == "down" or side == "bottom" thenreturn "bottom"endreturn sideendlocal function computePrimaryPushDirection(ctx, periphSide)if periphSide == "front" thenlocal facing = movement.getFacing(ctx)if facing thenreturn OPPOSITE_FACING[facing]endelseif periphSide == "top" thenreturn "down"elseif periphSide == "bottom" thenreturn "up"endreturn nilendlocal function tryPushItems(chest, periphSide, slot, amount, targetSlot, primaryDirection)if type(chest) ~= "table" or type(chest.pushItems) ~= "function" thenreturn 0endlocal tried = {}local function attempt(direction)if not direction or tried[direction] thenreturn 0endtried[direction] = truelocal ok, movedif targetSlot thenok, moved = pcall(chest.pushItems, direction, slot, amount, targetSlot)elseok, moved = pcall(chest.pushItems, direction, slot, amount)endif ok and type(moved) == "number" and moved > 0 thenreturn movedendreturn 0endlocal moved = attempt(primaryDirection)if moved > 0 thenreturn movedendfor _, direction in ipairs(PUSH_TARGETS) domoved = attempt(direction)if moved > 0 thenreturn movedendendreturn 0endlocal function collectStacks(chest, material)local stacks = {}if type(chest) ~= "table" or not material thenreturn stacksendif type(chest.list) == "function" thenlocal ok, list = pcall(chest.list)if ok and type(list) == "table" thenfor slot, stack in pairs(list) dolocal numericSlot = tonumber(slot)if numericSlot and type(stack) == "table" thenlocal name = stack.name or stack.idlocal count = stack.count or stack.qty or stack.quantity or 0if name == material and type(count) == "number" and count > 0 thenstacks[#stacks + 1] = { slot = numericSlot, count = count }endendendendendif #stacks == 0 and type(chest.size) == "function" and type(chest.getItemDetail) == "function" thenlocal okSize, size = pcall(chest.size)if okSize and type(size) == "number" and size > 0 thenfor slot = 1, size dolocal okDetail, detail = pcall(chest.getItemDetail, slot)if okDetail and type(detail) == "table" thenlocal name = detail.namelocal count = detail.count or detail.qty or detail.quantity or 0if name == material and type(count) == "number" and count > 0 thenstacks[#stacks + 1] = { slot = slot, count = count }endendendendendtable.sort(stacks, function(a, b)return a.slot < b.slotend)return stacksendlocal function newContainerManifest()return {totals = {},slots = {},totalItems = 0,orderedSlots = {},size = nil,metadata = nil,}endlocal function addManifestEntry(manifest, slot, stack)if type(manifest) ~= "table" or type(slot) ~= "number" thenreturnendif type(stack) ~= "table" thenreturnendlocal name = stack.name or stack.idlocal count = stack.count or stack.qty or stack.quantity or stack.Countif type(name) ~= "string" or type(count) ~= "number" or count <= 0 thenreturnendmanifest.slots[slot] = {name = name,count = count,tags = stack.tags,nbt = stack.nbt,displayName = stack.displayName or stack.label or stack.Name,detail = stack,}manifest.totals[name] = (manifest.totals[name] or 0) + countmanifest.totalItems = manifest.totalItems + countendlocal function populateManifestSlots(manifest)local ordered = {}for slot in pairs(manifest.slots) doordered[#ordered + 1] = slotendtable.sort(ordered)manifest.orderedSlots = orderedlocal materials = {}for material in pairs(manifest.totals) domaterials[#materials + 1] = materialendtable.sort(materials)manifest.materials = materialsendlocal function attachMetadata(manifest, periphSide)if not peripheral thenreturnendlocal metadata = manifest.metadata or {}if type(peripheral.call) == "function" thenlocal okMeta, meta = pcall(peripheral.call, periphSide, "getMetadata")if okMeta and type(meta) == "table" thenmetadata.name = meta.name or metadata.namemetadata.displayName = meta.displayName or meta.label or metadata.displayNamemetadata.tags = meta.tags or metadata.tagsendendif type(peripheral.getType) == "function" thenlocal okType, perType = pcall(peripheral.getType, periphSide)if okType thenif type(perType) == "string" thenmetadata.peripheralType = perTypeelseif type(perType) == "table" and type(perType[1]) == "string" thenmetadata.peripheralType = perType[1]endendendif next(metadata) ~= nil thenmanifest.metadata = metadataendendlocal function readContainerManifest(periphSide)if not peripheral or type(peripheral.wrap) ~= "function" thenreturn nil, "peripheral_api_unavailable"endlocal wrapOk, chest = pcall(peripheral.wrap, periphSide)if not wrapOk or type(chest) ~= "table" thenreturn nil, "wrap_failed"endlocal manifest = newContainerManifest()if type(chest.list) == "function" thenlocal okList, list = pcall(chest.list)if okList and type(list) == "table" thenfor slot, stack in pairs(list) dolocal numericSlot = tonumber(slot)if numericSlot thenaddManifestEntry(manifest, numericSlot, stack)endendendendlocal haveSlots = next(manifest.slots) ~= nilif type(chest.size) == "function" thenlocal okSize, size = pcall(chest.size)if okSize and type(size) == "number" and size >= 0 thenmanifest.size = sizeif not haveSlots and type(chest.getItemDetail) == "function" thenfor slot = 1, size dolocal okDetail, detail = pcall(chest.getItemDetail, slot)if okDetail thenaddManifestEntry(manifest, slot, detail)endendendendendpopulateManifestSlots(manifest)attachMetadata(manifest, periphSide)return manifestendlocal function extractFromContainer(ctx, periphSide, material, amount, targetSlot)if not material or not peripheral or type(peripheral.wrap) ~= "function" thenreturn 0endlocal wrapOk, chest = pcall(peripheral.wrap, periphSide)if not wrapOk or type(chest) ~= "table" thenreturn 0endif type(chest.pushItems) ~= "function" thenreturn 0endlocal desired = amountif not desired or desired <= 0 thendesired = 64endlocal stacks = collectStacks(chest, material)if #stacks == 0 thenreturn 0endlocal remaining = desiredlocal transferred = 0local primaryDirection = computePrimaryPushDirection(ctx, periphSide)for _, stack in ipairs(stacks) dolocal available = stack.count or 0while remaining > 0 and available > 0 dolocal toMove = math.min(available, remaining, 64)local moved = tryPushItems(chest, periphSide, stack.slot, toMove, targetSlot, primaryDirection)if moved <= 0 thenbreakendtransferred = transferred + movedremaining = remaining - movedavailable = available - movedendif remaining <= 0 thenbreakendendreturn transferredendlocal function ensureChestAhead(ctx, opts)local frontOk, frontDetail = inspectForwardForContainer()if frontOk thenreturn true, noop, { side = "forward", detail = frontDetail }endif not shouldSearchAllSides(opts) thenreturn false, nil, nil, "container_not_found"endif not turtle thenreturn false, nil, nil, "turtle_api_unavailable"endmovement.ensureState(ctx)local startFacing = movement.getFacing(ctx)local function restoreFacing()if not startFacing thenreturnendif movement.getFacing(ctx) ~= startFacing thenlocal okFace, faceErr = movement.faceDirection(ctx, startFacing)if not okFace and faceErr thenlogger.log(ctx, "warn", "Failed to restore facing: " .. tostring(faceErr))endendendlocal function makeRestore()if not startFacing thenreturn noopendreturn function()restoreFacing()endend-- Check leftlocal ok, err = movement.turnLeft(ctx)if not ok thenrestoreFacing()return false, nil, nil, err or "turn_failed"endlocal leftOk, leftDetail = inspectForwardForContainer()if leftOk thenlogger.log(ctx, "debug", "Found container on left side; using that")return true, makeRestore(), { side = "left", detail = leftDetail }endok, err = movement.turnRight(ctx)if not ok thenrestoreFacing()return false, nil, nil, err or "turn_failed"end-- Check rightok, err = movement.turnRight(ctx)if not ok thenrestoreFacing()return false, nil, nil, err or "turn_failed"endlocal rightOk, rightDetail = inspectForwardForContainer()if rightOk thenlogger.log(ctx, "debug", "Found container on right side; using that")return true, makeRestore(), { side = "right", detail = rightDetail }endok, err = movement.turnLeft(ctx)if not ok thenrestoreFacing()return false, nil, nil, err or "turn_failed"end-- Check behindok, err = movement.turnRight(ctx)if not ok thenrestoreFacing()return false, nil, nil, err or "turn_failed"endok, err = movement.turnRight(ctx)if not ok thenrestoreFacing()return false, nil, nil, err or "turn_failed"endlocal backOk, backDetail = inspectForwardForContainer()if backOk thenlogger.log(ctx, "debug", "Found container behind; using that")return true, makeRestore(), { side = "back", detail = backDetail }endok, err = movement.turnLeft(ctx)if not ok thenrestoreFacing()return false, nil, nil, err or "turn_failed"endok, err = movement.turnLeft(ctx)if not ok thenrestoreFacing()return false, nil, nil, err or "turn_failed"endrestoreFacing()return false, nil, nil, "container_not_found"endlocal function ensureInventoryState(ctx)if type(ctx) ~= "table" thenerror("inventory library requires a context table", 2)endif type(ctx.inventoryState) ~= "table" thenctx.inventoryState = ctx.inventory or {}endctx.inventory = ctx.inventoryStatelocal state = ctx.inventoryStatestate.scanVersion = state.scanVersion or 0state.slots = state.slots or {}state.materialSlots = state.materialSlots or {}state.materialTotals = state.materialTotals or {}state.emptySlots = state.emptySlots or {}state.totalItems = state.totalItems or 0if state.dirty == nil thenstate.dirty = trueendreturn stateendfunction inventory.ensureState(ctx)return ensureInventoryState(ctx)endfunction inventory.invalidate(ctx)local state = ensureInventoryState(ctx)state.dirty = truereturn trueendlocal function fetchSlotDetail(slot)if not turtle thenreturn { slot = slot, count = 0 }endlocal detailif turtle.getItemDetail thendetail = turtle.getItemDetail(slot)endlocal countif turtle.getItemCount thencount = turtle.getItemCount(slot)elseif detail thencount = detail.countendcount = count or 0local name = detail and detail.name or nilreturn {slot = slot,count = count,name = name,detail = detail,}endfunction inventory.scan(ctx, opts)local state = ensureInventoryState(ctx)if not turtle thenstate.slots = {}state.materialSlots = {}state.materialTotals = {}state.emptySlots = {}state.totalItems = 0state.dirty = falsestate.scanVersion = state.scanVersion + 1return false, "turtle API unavailable"endlocal slots = {}local materialSlots = {}local materialTotals = {}local emptySlots = {}local totalItems = 0for slot = 1, 16 dolocal info = fetchSlotDetail(slot)slots[slot] = infoif info.count > 0 and info.name thenlocal list = materialSlots[info.name]if not list thenlist = {}materialSlots[info.name] = listendlist[#list + 1] = slotmaterialTotals[info.name] = (materialTotals[info.name] or 0) + info.counttotalItems = totalItems + info.countelseemptySlots[#emptySlots + 1] = slotendendstate.slots = slotsstate.materialSlots = materialSlotsstate.materialTotals = materialTotalsstate.emptySlots = emptySlotsstate.totalItems = totalItemsif os and type(os.clock) == "function" thenstate.lastScanClock = os.clock()elsestate.lastScanClock = nilendlocal epochFn = os and os["epoch"]if type(epochFn) == "function" thenstate.lastScanEpoch = epochFn("utc")elsestate.lastScanEpoch = nilendstate.scanVersion = state.scanVersion + 1state.dirty = falselogger.log(ctx, "debug", string.format("Inventory scan complete: %d items across %d materials", totalItems, tableCount(materialSlots)))return trueendlocal function ensureScanned(ctx, opts)local state = ensureInventoryState(ctx)if state.dirty or (type(opts) == "table" and opts.force) or not state.slots or next(state.slots) == nil thenlocal ok, err = inventory.scan(ctx, opts)if not ok and err thenreturn nil, errendendreturn stateendfunction inventory.getMaterialSlots(ctx, material, opts)if type(material) ~= "string" or material == "" thenreturn nil, "invalid_material"endlocal state, err = ensureScanned(ctx, opts)if not state thenreturn nil, errendlocal slots = state.materialSlots[material]if not slots thenreturn {}endreturn copyArray(slots)endfunction inventory.getSlotForMaterial(ctx, material, opts)local slots, err = inventory.getMaterialSlots(ctx, material, opts)if slots == nil thenreturn nil, errendif slots[1] thenreturn slots[1]endreturn nil, "missing_material"endfunction inventory.countMaterial(ctx, material, opts)if type(material) ~= "string" or material == "" thenreturn 0, "invalid_material"endlocal state, err = ensureScanned(ctx, opts)if not state thenreturn 0, errendreturn state.materialTotals[material] or 0endfunction inventory.hasMaterial(ctx, material, amount, opts)amount = amount or 1if amount <= 0 thenreturn trueendlocal total, err = inventory.countMaterial(ctx, material, opts)if err thenreturn false, errendreturn total >= amountendfunction inventory.findEmptySlot(ctx, opts)local state, err = ensureScanned(ctx, opts)if not state thenreturn nil, errendlocal empty = state.emptySlotsif empty and empty[1] thenreturn empty[1]endreturn nil, "no_empty_slot"endfunction inventory.isEmpty(ctx, opts)local state, err = ensureScanned(ctx, opts)if not state thenreturn false, errendreturn state.totalItems == 0endfunction inventory.totalItemCount(ctx, opts)local state, err = ensureScanned(ctx, opts)if not state thenreturn 0, errendreturn state.totalItemsendfunction inventory.getTotals(ctx, opts)local state, err = ensureScanned(ctx, opts)if not state thenreturn nil, errendreturn copySummary(state.materialTotals)endfunction inventory.snapshot(ctx, opts)local state, err = ensureScanned(ctx, opts)if not state thenreturn nil, errendreturn {slots = copySlots(state.slots),totals = copySummary(state.materialTotals),emptySlots = copyArray(state.emptySlots),totalItems = state.totalItems,scanVersion = state.scanVersion,lastScanClock = state.lastScanClock,lastScanEpoch = state.lastScanEpoch,}endfunction inventory.detectContainer(ctx, opts)opts = opts or {}local side = resolveSide(ctx, opts)if side == "forward" thenlocal chestOk, restoreFn, info, err = ensureChestAhead(ctx, opts)if not chestOk thenreturn nil, err or "container_not_found"endif type(restoreFn) == "function" thenrestoreFn()endlocal result = info or { side = "forward" }result.peripheralSide = "front"return resultelseif side == "up" thenlocal okUp, detail = inspectUpForContainer()if okUp thenreturn { side = "up", detail = detail, peripheralSide = "top" }endreturn nil, "container_not_found"elseif side == "down" thenlocal okDown, detail = inspectDownForContainer()if okDown thenreturn { side = "down", detail = detail, peripheralSide = "bottom" }endreturn nil, "container_not_found"endreturn nil, "unsupported_side"endfunction inventory.getContainerManifest(ctx, opts)if not turtle thenreturn nil, "turtle API unavailable"endopts = opts or {}local side = resolveSide(ctx, opts)local periphSide = peripheralSideForDirection(side)local restoreFacing = nooplocal infoif side == "forward" thenlocal chestOk, restoreFn, chestInfo, err = ensureChestAhead(ctx, opts)if not chestOk thenreturn nil, err or "container_not_found"endif type(restoreFn) == "function" thenrestoreFacing = restoreFnendinfo = chestInfo or { side = "forward" }periphSide = "front"elseif side == "up" thenlocal okUp, detail = inspectUpForContainer()if not okUp thenreturn nil, "container_not_found"endinfo = { side = "up", detail = detail }periphSide = "top"elseif side == "down" thenlocal okDown, detail = inspectDownForContainer()if not okDown thenreturn nil, "container_not_found"endinfo = { side = "down", detail = detail }periphSide = "bottom"elsereturn nil, "unsupported_side"endlocal manifest, manifestErr = readContainerManifest(periphSide)restoreFacing()if not manifest thenreturn nil, manifestErr or "wrap_failed"endmanifest.peripheralSide = periphSideif info thenmanifest.relativeSide = info.sidemanifest.inspectDetail = info.detailif not manifest.metadata and info.detail thenmanifest.metadata = {name = info.detail.name,displayName = info.detail.displayName or info.detail.label,tags = info.detail.tags,}elseif manifest.metadata and info.detail thenmanifest.metadata.name = manifest.metadata.name or info.detail.namemanifest.metadata.displayName = manifest.metadata.displayName or info.detail.displayName or info.detail.labelmanifest.metadata.tags = manifest.metadata.tags or info.detail.tagsendendreturn manifestendfunction inventory.selectMaterial(ctx, material, opts)if not turtle thenreturn false, "turtle API unavailable"endlocal slot, err = inventory.getSlotForMaterial(ctx, material, opts)if not slot thenreturn false, err or "missing_material"endif turtle.select(slot) thenreturn trueendreturn false, "select_failed"endlocal function selectSlot(slot)if not turtle thenreturn false, "turtle API unavailable"endif type(slot) ~= "number" or slot < 1 or slot > 16 thenreturn false, "invalid_slot"endif turtle.select(slot) thenreturn trueendreturn false, "select_failed"endlocal function rescanIfNeeded(ctx, opts)if opts and opts.deferScan theninventory.invalidate(ctx)returnendlocal ok, err = inventory.scan(ctx)if not ok and err thenlogger.log(ctx, "warn", "Inventory rescan failed: " .. tostring(err))inventory.invalidate(ctx)endendfunction inventory.pushSlot(ctx, slot, amount, opts)if not turtle thenreturn false, "turtle API unavailable"endlocal side = resolveSide(ctx, opts)local actions = SIDE_ACTIONS[side]if not actions or type(actions.drop) ~= "function" thenreturn false, "invalid_side"endlocal ok, err = selectSlot(slot)if not ok thenreturn false, errendlocal restoreFacing = noopif side == "forward" thenlocal chestOk, restoreFn, _, searchErr = ensureChestAhead(ctx, opts)if not chestOk thenreturn false, searchErr or "container_not_found"endif type(restoreFn) == "function" thenrestoreFacing = restoreFnendelseif side == "up" thenlocal okUp = inspectUpForContainer()if not okUp thenreturn false, "container_not_found"endelseif side == "down" thenlocal okDown = inspectDownForContainer()if not okDown thenreturn false, "container_not_found"endendlocal count = turtle.getItemCount and turtle.getItemCount(slot) or nilif count ~= nil and count <= 0 thenrestoreFacing()return false, "empty_slot"endif amount and amount > 0 thenok = actions.drop(amount)elseok = actions.drop()endif not ok thenrestoreFacing()return false, "drop_failed"endrestoreFacing()rescanIfNeeded(ctx, opts)return trueendfunction inventory.pushMaterial(ctx, material, amount, opts)if type(material) ~= "string" or material == "" thenreturn false, "invalid_material"endlocal slot, err = inventory.getSlotForMaterial(ctx, material, opts)if not slot thenreturn false, err or "missing_material"endreturn inventory.pushSlot(ctx, slot, amount, opts)endlocal function resolveTargetSlotForPull(state, material, opts)if opts and opts.slot thenreturn opts.slotendif material thenlocal materialSlots = state.materialSlots[material]if materialSlots and materialSlots[1] thenreturn materialSlots[1]endendlocal empty = state.emptySlotsif empty and empty[1] thenreturn empty[1]endreturn nilendfunction inventory.pullMaterial(ctx, material, amount, opts)if not turtle thenreturn false, "turtle API unavailable"endlocal state, err = ensureScanned(ctx, opts)if not state thenreturn false, errendlocal side = resolveSide(ctx, opts)local actions = SIDE_ACTIONS[side]if not actions or type(actions.suck) ~= "function" thenreturn false, "invalid_side"endif material ~= nil and (type(material) ~= "string" or material == "") thenreturn false, "invalid_material"endlocal targetSlot = resolveTargetSlotForPull(state, material, opts)if not targetSlot then-- Try to condense inventory to free slots before giving uppcall(inventory.condense, ctx)-- Recompute state and targetSlot after condensestate = ensureScanned(ctx, { force = true }) or statetargetSlot = resolveTargetSlotForPull(state, material, opts)if not targetSlot thenreturn false, "no_empty_slot"endendlocal ok, selectErr = selectSlot(targetSlot)if not ok thenreturn false, selectErrendlocal periphSide = peripheralSideForDirection(side)local restoreFacing = noopif side == "forward" thenlocal chestOk, restoreFn, _, searchErr = ensureChestAhead(ctx, opts)if not chestOk thenreturn false, searchErr or "container_not_found"endif type(restoreFn) == "function" thenrestoreFacing = restoreFnendelseif side == "up" thenlocal okUp = inspectUpForContainer()if not okUp thenreturn false, "container_not_found"endelseif side == "down" thenlocal okDown = inspectDownForContainer()if not okDown thenreturn false, "container_not_found"endendlocal desired = nilif material thenif amount and amount > 0 thendesired = math.min(amount, 64)else-- Accept any positive stack when no explicit amount is requested.desired = nilendelseif amount and amount > 0 thendesired = amountendlocal transferred = 0if material thentransferred = extractFromContainer(ctx, periphSide, material, desired, targetSlot)if transferred > 0 thenrestoreFacing()rescanIfNeeded(ctx, opts)return trueendendif material == nil thenif amount and amount > 0 thenok = actions.suck(amount)elseok = actions.suck()endif not ok thenrestoreFacing()return false, "suck_failed"endrestoreFacing()rescanIfNeeded(ctx, opts)return trueendlocal function makePushOpts()local pushOpts = { side = side }if type(opts) == "table" and opts.searchAllSides ~= nil thenpushOpts.searchAllSides = opts.searchAllSidesendreturn pushOptsendlocal stashSlots = {}local stashSet = {}local function addStashSlot(slot)stashSlots[#stashSlots + 1] = slotstashSet[slot] = trueendlocal function markSlotEmpty(slot)if not slot thenreturnendlocal info = state.slots[slot]if info theninfo.count = 0info.name = nilinfo.detail = nilendfor index = #state.emptySlots, 1, -1 doif state.emptySlots[index] == slot thenreturnendendstate.emptySlots[#state.emptySlots + 1] = slotendlocal function freeAdditionalSlot()local pushOpts = makePushOpts()pushOpts.deferScan = truefor slot = 16, 1, -1 doif slot ~= targetSlot and not stashSet[slot] thenlocal count = turtle.getItemCount(slot)if count > 0 thenlocal info = state.slots[slot]if not info or info.name ~= material thenlocal pushOk, pushErr = inventory.pushSlot(ctx, slot, nil, pushOpts)if pushOk theninventory.invalidate(ctx)markSlotEmpty(slot)local newState = ensureScanned(ctx, { force = true })if newState thenstate = newStateendif turtle.getItemCount(slot) == 0 thenreturn slotendelseif pushErr thenlogger.log(ctx, "debug", string.format("Unable to clear slot %d while restocking %s: %s", slot, material or "unknown", pushErr))endendendendendendreturn nilendlocal function findTemporarySlot()for slot = 1, 16 doif slot ~= targetSlot and not stashSet[slot] and turtle.getItemCount(slot) == 0 thenreturn slotendendlocal cleared = freeAdditionalSlot()if cleared thenreturn clearedendfor slot = 1, 16 doif slot ~= targetSlot and not stashSet[slot] and turtle.getItemCount(slot) == 0 thenreturn slotendendreturn nilendlocal function returnStash(deferScan)if #stashSlots == 0 thenreturnendlocal pushOpts = makePushOpts()pushOpts.deferScan = deferScanfor _, slot in ipairs(stashSlots) dolocal pushOk, pushErr = inventory.pushSlot(ctx, slot, nil, pushOpts)if not pushOk and pushErr thenlogger.log(ctx, "warn", string.format("Failed to return cycled item from slot %d: %s", slot, tostring(pushErr)))endendturtle.select(targetSlot)inventory.invalidate(ctx)local newState = ensureScanned(ctx, { force = true })if newState thenstate = newStateendstashSlots = {}stashSet = {}endlocal cycles = 0local maxCycles = (type(opts) == "table" and opts.cycleLimit) or 48local success = falselocal failureReasonlocal cycled = 0local assumedMatch = falsewhile cycles < maxCycles docycles = cycles + 1local currentCount = turtle.getItemCount(targetSlot)if desired and currentCount >= desired thensuccess = truebreakendlocal need = desired and math.max(desired - currentCount, 1) or nillocal pulledif need thenpulled = actions.suck(math.min(need, 64))elsepulled = actions.suck()endif not pulled thenfailureReason = failureReason or "suck_failed"breakendlocal detailif turtle and turtle.getItemDetail thendetail = turtle.getItemDetail(targetSlot)if detail == nil thenlocal okDetailed, detailed = pcall(turtle.getItemDetail, targetSlot, true)if okDetailed thendetail = detailedendendendlocal updatedCount = turtle.getItemCount(targetSlot)local assumedMatch = falseif not detail and material and updatedCount > 0 then-- Non-advanced turtles cannot inspect stacks; assume the pulled stack-- matches the requested material when we cannot obtain metadata.assumedMatch = trueendif (detail and detail.name == material) or assumedMatch thenif not desired or updatedCount >= desired thensuccess = truebreakendelseassumedMatch = falselocal stashSlot = findTemporarySlot()if not stashSlot thenfailureReason = "no_empty_slot"breakendlocal moved = turtle.transferTo(stashSlot)if not moved thenfailureReason = "transfer_failed"breakendaddStashSlot(stashSlot)cycled = cycled + 1inventory.invalidate(ctx)turtle.select(targetSlot)endendif success thenif assumedMatch thenlogger.log(ctx, "debug", string.format("Pulled %s without detailed item metadata", material or "unknown"))elseif cycled > 0 thenlogger.log(ctx, "debug", string.format("Pulled %s after cycling %d other stacks", material, cycled))elselogger.log(ctx, "debug", string.format("Pulled %s directly via turtle.suck", material))endreturnStash(true)restoreFacing()rescanIfNeeded(ctx, opts)return trueendreturnStash(true)restoreFacing()if failureReason thenlogger.log(ctx, "debug", string.format("Failed to pull %s after cycling %d stacks: %s", material, cycled, failureReason))endif failureReason == "suck_failed" thenreturn false, "missing_material"endreturn false, failureReason or "missing_material"endfunction inventory.dumpTrash(ctx, trashList)if not turtle then return false, "turtle API unavailable" endtrashList = trashList or inventory.DEFAULT_TRASHlocal state, err = ensureScanned(ctx)if not state then return false, err endfor slot, info in pairs(state.slots) doif info and info.name and trashList[info.name] thenturtle.select(slot)turtle.drop()endend-- Force rescan after dumpinginventory.scan(ctx)return trueendfunction inventory.clearSlot(ctx, slot, opts)if not turtle thenreturn false, "turtle API unavailable"endlocal state, err = ensureScanned(ctx, opts)if not state thenreturn false, errendlocal info = state.slots[slot]if not info or info.count == 0 thenreturn trueendlocal ok, dropErr = inventory.pushSlot(ctx, slot, nil, opts)if not ok thenreturn false, dropErrendreturn trueendfunction inventory.describeMaterials(io, info)if not io.print thenreturnendio.print("Schema manifest requirements:")if not info or not info.materials thenio.print(" - <none>")returnendfor _, entry in ipairs(info.materials) doif entry.material ~= "minecraft:air" and entry.material ~= "air" thenio.print(string.format(" - %s x%d", entry.material, entry.count or 0))endendendfunction inventory.runCheck(ctx, io, opts)local ok, report = initialize.ensureMaterials(ctx, { manifest = ctx.schemaInfo and ctx.schemaInfo.materials }, opts)if io.print thenif ok thenio.print("Material check passed. Turtle and chests meet manifest requirements.")elseio.print("Material check failed. Missing materials:")for _, entry in ipairs(report.missing or {}) doio.print(string.format(" - %s: need %d, have %d", entry.material, entry.required, entry.have))endendendreturn ok, reportendfunction inventory.gatherSummary(io, report)if not io.print thenreturnendio.print("\nDetailed totals:")io.print(" Turtle inventory:")for material, count in pairs(report.turtleTotals or {}) doio.print(string.format("   - %s x%d", material, count))endio.print(" Nearby chests:")for material, count in pairs(report.chestTotals or {}) doio.print(string.format("   - %s x%d", material, count))endif #report.chests > 0 thenio.print(" Per-chest breakdown:")for _, entry in ipairs(report.chests) doio.print(string.format("   [%s] %s", entry.side, entry.name or "container"))for material, count in pairs(entry.totals or {}) doio.print(string.format("     * %s x%d", material, count))endendendendfunction inventory.describeTotals(io, totals)totals = totals or {}local keys = {}for material in pairs(totals) dokeys[#keys + 1] = materialendtable.sort(keys)if io.print thenif #keys == 0 thenio.print("Inventory totals: <empty>")elseio.print("Inventory totals:")for _, material in ipairs(keys) doio.print(string.format(" - %s x%d", material, totals[material] or 0))endendendendfunction inventory.computeManifest(list)local totals = {}for _, sc in ipairs(list) doif sc.material and sc.material ~= "" thentotals[sc.material] = (totals[sc.material] or 0) + 1endendreturn totalsendfunction inventory.printManifest(io, manifest)if not io.print thenreturnendio.print("\nRequested manifest (minimum counts):")local shown = falsefor material, count in pairs(manifest) doio.print(string.format(" - %s x%d", material, count))shown = trueendif not shown thenio.print(" - <empty>")endend--- Condense inventory by merging stacks of the same itemfunction inventory.condense(ctx)if not turtle then return false, "turtle API unavailable" endlocal state, err = ensureScanned(ctx)if not state then return false, err end-- Map item names to list of slots containing themlocal itemSlots = {}for slot, info in pairs(state.slots) doif info and info.name thenif not itemSlots[info.name] thenitemSlots[info.name] = {}endtable.insert(itemSlots[info.name], slot)endendlocal changes = falsefor name, slots in pairs(itemSlots) doif #slots > 1 then-- Sort slots to merge into the first available onestable.sort(slots)local targetIdx = 1while targetIdx < #slots dolocal targetSlot = slots[targetIdx]local sourceIdx = targetIdx + 1while sourceIdx <= #slots dolocal sourceSlot = slots[sourceIdx]-- Check if target is full (assuming 64 stack size for simplicity,-- though some items are 16 or 1. transferTo handles limits)local targetInfo = state.slots[targetSlot]local sourceInfo = state.slots[sourceSlot]if targetInfo and sourceInfo and targetInfo.count < 64 thenturtle.select(sourceSlot)if turtle.transferTo(targetSlot) thenchanges = true-- Update local state tracking (approximate)-- Real update happens on next scanendend-- If target is now full (or we can't verify), move to next targetif turtle.getItemCount(targetSlot) >= 64 thenbreakendsourceIdx = sourceIdx + 1endtargetIdx = targetIdx + 1endendendif changes theninventory.scan(ctx)endreturn trueendfunction inventory.getCounts(ctx)local counts = {}-- Scan all slotsfor i = 1, 16 dolocal item = turtle.getItemDetail(i)if item thencounts[item.name] = (counts[item.name] or 0) + item.countendendreturn countsendfunction inventory.retrieveFromNearby(ctx, missing)local sides = {"front", "top", "bottom", "left", "right", "back"}local pulledAny = falsefor _, side in ipairs(sides) doif peripheral.isPresent(side) thenlocal types = { peripheral.getType(side) }local isInventory = falsefor _, t in ipairs(types) doif t == "inventory" then isInventory = true break endendif isInventory thenlocal p = peripheral.wrap(side)if p and p.list thenlocal list = p.list()local neededFromChest = {}for slot, item in pairs(list) doif item and missing[item.name] and missing[item.name] > 0 thenneededFromChest[item.name] = trueendend-- Check if we need anything from this chestlocal hasNeeds = falsefor k,v in pairs(neededFromChest) do hasNeeds = true break endif hasNeeds thenlocal pullSide = "forward"local turned = false-- Turn to face the chest if neededif side == "top" then pullSide = "up"elseif side == "bottom" then pullSide = "down"elseif side == "front" then pullSide = "forward"elseif side == "left" thenmovement.turnLeft(ctx)turned = truepullSide = "forward"elseif side == "right" thenmovement.turnRight(ctx)turned = truepullSide = "forward"elseif side == "back" thenmovement.turnRight(ctx)movement.turnRight(ctx)turned = truepullSide = "forward"end-- Pull all needed itemsfor mat, _ in pairs(neededFromChest) dolocal amount = missing[mat]if amount > 0 thenprint(string.format("Attempting to pull %s from %s...", mat, side))-- If inventory is full, try condensing to free space before pullinglocal empty = inventory.findEmptySlot(ctx)if not empty thenpcall(inventory.condense, ctx)empty = inventory.findEmptySlot(ctx)endif not empty thenlogger.log(ctx, "warn", string.format("No empty slot available to pull %s; skipping pull", mat))elselocal success, err = inventory.pullMaterial(ctx, mat, amount, { side = pullSide })if success thenpulledAny = truemissing[mat] = math.max(0, missing[mat] - amount)elselogger.log(ctx, "warn", "Failed to pull " .. mat .. ": " .. tostring(err))endendendend-- Restore facingif turned thenif side == "left" then movement.turnRight(ctx)elseif side == "right" then movement.turnLeft(ctx)elseif side == "back" thenmovement.turnRight(ctx)movement.turnRight(ctx)endendendendendendendreturn pulledAnyendfunction inventory.checkNearby(ctx, missing)local found = {}local sides = {"front", "top", "bottom", "left", "right", "back"}for _, side in ipairs(sides) doif peripheral.isPresent(side) thenlocal types = { peripheral.getType(side) }local isInventory = falsefor _, t in ipairs(types) doif t == "inventory" then isInventory = true break endendif isInventory thenlocal p = peripheral.wrap(side)if p and p.list thenlocal list = p.list()for slot, item in pairs(list) doif item and missing[item.name] thenfound[item.name] = (found[item.name] or 0) + item.countendendendendendendreturn foundendreturn inventory]========]
files['lib/lib_items.lua'] = [======[local items = {{ id = "minecraft:stone", name = "Stone", color = colors.lightGray, sym = "#" },{ id = "minecraft:granite", name = "Granite", color = colors.red, sym = "#" },{ id = "minecraft:polished_granite", name = "Polished Granite", color = colors.red, sym = "#" },{ id = "minecraft:diorite", name = "Diorite", color = colors.white, sym = "#" },{ id = "minecraft:polished_diorite", name = "Polished Diorite", color = colors.white, sym = "#" },{ id = "minecraft:andesite", name = "Andesite", color = colors.gray, sym = "#" },{ id = "minecraft:polished_andesite", name = "Polished Andesite", color = colors.gray, sym = "#" },{ id = "minecraft:grass_block", name = "Grass Block", color = colors.green, sym = "G" },{ id = "minecraft:dirt", name = "Dirt", color = colors.brown, sym = "d" },{ id = "minecraft:coarse_dirt", name = "Coarse Dirt", color = colors.brown, sym = "d" },{ id = "minecraft:podzol", name = "Podzol", color = colors.brown, sym = "d" },{ id = "minecraft:cobblestone", name = "Cobblestone", color = colors.gray, sym = "C" },{ id = "minecraft:oak_planks", name = "Oak Planks", color = colors.brown, sym = "P" },{ id = "minecraft:spruce_planks", name = "Spruce Planks", color = colors.brown, sym = "P" },{ id = "minecraft:birch_planks", name = "Birch Planks", color = colors.yellow, sym = "P" },{ id = "minecraft:jungle_planks", name = "Jungle Planks", color = colors.brown, sym = "P" },{ id = "minecraft:acacia_planks", name = "Acacia Planks", color = colors.orange, sym = "P" },{ id = "minecraft:dark_oak_planks", name = "Dark Oak Planks", color = colors.brown, sym = "P" },{ id = "minecraft:mangrove_planks", name = "Mangrove Planks", color = colors.red, sym = "P" },{ id = "minecraft:cherry_planks", name = "Cherry Planks", color = colors.pink, sym = "P" },{ id = "minecraft:bamboo_planks", name = "Bamboo Planks", color = colors.yellow, sym = "P" },{ id = "minecraft:bedrock", name = "Bedrock", color = colors.black, sym = "B" },{ id = "minecraft:sand", name = "Sand", color = colors.yellow, sym = "s" },{ id = "minecraft:red_sand", name = "Red Sand", color = colors.orange, sym = "s" },{ id = "minecraft:gravel", name = "Gravel", color = colors.gray, sym = "g" },{ id = "minecraft:gold_ore", name = "Gold Ore", color = colors.yellow, sym = "o" },{ id = "minecraft:iron_ore", name = "Iron Ore", color = colors.brown, sym = "o" },{ id = "minecraft:coal_ore", name = "Coal Ore", color = colors.black, sym = "o" },{ id = "minecraft:nether_gold_ore", name = "Nether Gold Ore", color = colors.yellow, sym = "o" },{ id = "minecraft:oak_log", name = "Oak Log", color = colors.brown, sym = "L" },{ id = "minecraft:spruce_log", name = "Spruce Log", color = colors.brown, sym = "L" },{ id = "minecraft:birch_log", name = "Birch Log", color = colors.white, sym = "L" },{ id = "minecraft:jungle_log", name = "Jungle Log", color = colors.brown, sym = "L" },{ id = "minecraft:acacia_log", name = "Acacia Log", color = colors.orange, sym = "L" },{ id = "minecraft:dark_oak_log", name = "Dark Oak Log", color = colors.brown, sym = "L" },{ id = "minecraft:mangrove_log", name = "Mangrove Log", color = colors.red, sym = "L" },{ id = "minecraft:cherry_log", name = "Cherry Log", color = colors.pink, sym = "L" },{ id = "minecraft:stripped_oak_log", name = "Stripped Oak Log", color = colors.brown, sym = "L" },{ id = "minecraft:stripped_spruce_log", name = "Stripped Spruce Log", color = colors.brown, sym = "L" },{ id = "minecraft:stripped_birch_log", name = "Stripped Birch Log", color = colors.white, sym = "L" },{ id = "minecraft:stripped_jungle_log", name = "Stripped Jungle Log", color = colors.brown, sym = "L" },{ id = "minecraft:stripped_acacia_log", name = "Stripped Acacia Log", color = colors.orange, sym = "L" },{ id = "minecraft:stripped_dark_oak_log", name = "Stripped Dark Oak Log", color = colors.brown, sym = "L" },{ id = "minecraft:stripped_mangrove_log", name = "Stripped Mangrove Log", color = colors.red, sym = "L" },{ id = "minecraft:stripped_cherry_log", name = "Stripped Cherry Log", color = colors.pink, sym = "L" },{ id = "minecraft:glass", name = "Glass", color = colors.lightBlue, sym = "G" },{ id = "minecraft:lapis_ore", name = "Lapis Ore", color = colors.blue, sym = "o" },{ id = "minecraft:diamond_ore", name = "Diamond Ore", color = colors.cyan, sym = "o" },{ id = "minecraft:redstone_ore", name = "Redstone Ore", color = colors.red, sym = "o" },{ id = "minecraft:emerald_ore", name = "Emerald Ore", color = colors.green, sym = "o" },{ id = "minecraft:white_wool", name = "White Wool", color = colors.white, sym = "W" },{ id = "minecraft:orange_wool", name = "Orange Wool", color = colors.orange, sym = "W" },{ id = "minecraft:magenta_wool", name = "Magenta Wool", color = colors.magenta, sym = "W" },{ id = "minecraft:light_blue_wool", name = "Light Blue Wool", color = colors.lightBlue, sym = "W" },{ id = "minecraft:yellow_wool", name = "Yellow Wool", color = colors.yellow, sym = "W" },{ id = "minecraft:lime_wool", name = "Lime Wool", color = colors.lime, sym = "W" },{ id = "minecraft:pink_wool", name = "Pink Wool", color = colors.pink, sym = "W" },{ id = "minecraft:gray_wool", name = "Gray Wool", color = colors.gray, sym = "W" },{ id = "minecraft:light_gray_wool", name = "Light Gray Wool", color = colors.lightGray, sym = "W" },{ id = "minecraft:cyan_wool", name = "Cyan Wool", color = colors.cyan, sym = "W" },{ id = "minecraft:purple_wool", name = "Purple Wool", color = colors.purple, sym = "W" },{ id = "minecraft:blue_wool", name = "Blue Wool", color = colors.blue, sym = "W" },{ id = "minecraft:brown_wool", name = "Brown Wool", color = colors.brown, sym = "W" },{ id = "minecraft:green_wool", name = "Green Wool", color = colors.green, sym = "W" },{ id = "minecraft:red_wool", name = "Red Wool", color = colors.red, sym = "W" },{ id = "minecraft:black_wool", name = "Black Wool", color = colors.black, sym = "W" },{ id = "minecraft:bricks", name = "Bricks", color = colors.red, sym = "B" },{ id = "minecraft:bookshelf", name = "Bookshelf", color = colors.brown, sym = "#" },{ id = "minecraft:mossy_cobblestone", name = "Mossy Cobblestone", color = colors.gray, sym = "C" },{ id = "minecraft:obsidian", name = "Obsidian", color = colors.black, sym = "O" },{ id = "minecraft:torch", name = "Torch", color = colors.yellow, sym = "i" },{ id = "minecraft:chest", name = "Chest", color = colors.brown, sym = "C" },{ id = "minecraft:crafting_table", name = "Crafting Table", color = colors.brown, sym = "T" },{ id = "minecraft:furnace", name = "Furnace", color = colors.gray, sym = "F" },{ id = "minecraft:ladder", name = "Ladder", color = colors.brown, sym = "H" },{ id = "minecraft:snow", name = "Snow", color = colors.white, sym = "S" },{ id = "minecraft:ice", name = "Ice", color = colors.lightBlue, sym = "I" },{ id = "minecraft:snow_block", name = "Snow Block", color = colors.white, sym = "S" },{ id = "minecraft:clay", name = "Clay", color = colors.lightGray, sym = "C" },{ id = "minecraft:pumpkin", name = "Pumpkin", color = colors.orange, sym = "P" },{ id = "minecraft:netherrack", name = "Netherrack", color = colors.red, sym = "N" },{ id = "minecraft:soul_sand", name = "Soul Sand", color = colors.brown, sym = "S" },{ id = "minecraft:soul_soil", name = "Soul Soil", color = colors.brown, sym = "S" },{ id = "minecraft:basalt", name = "Basalt", color = colors.gray, sym = "B" },{ id = "minecraft:polished_basalt", name = "Polished Basalt", color = colors.gray, sym = "B" },{ id = "minecraft:glowstone", name = "Glowstone", color = colors.yellow, sym = "G" },{ id = "minecraft:stone_bricks", name = "Stone Bricks", color = colors.gray, sym = "B" },{ id = "minecraft:mossy_stone_bricks", name = "Mossy Stone Bricks", color = colors.gray, sym = "B" },{ id = "minecraft:cracked_stone_bricks", name = "Cracked Stone Bricks", color = colors.gray, sym = "B" },{ id = "minecraft:chiseled_stone_bricks", name = "Chiseled Stone Bricks", color = colors.gray, sym = "B" },{ id = "minecraft:deepslate", name = "Deepslate", color = colors.gray, sym = "D" },{ id = "minecraft:cobbled_deepslate", name = "Cobbled Deepslate", color = colors.gray, sym = "D" },{ id = "minecraft:polished_deepslate", name = "Polished Deepslate", color = colors.gray, sym = "D" },{ id = "minecraft:deepslate_bricks", name = "Deepslate Bricks", color = colors.gray, sym = "D" },{ id = "minecraft:deepslate_tiles", name = "Deepslate Tiles", color = colors.gray, sym = "D" },{ id = "minecraft:reinforced_deepslate", name = "Reinforced Deepslate", color = colors.black, sym = "D" },{ id = "minecraft:melon", name = "Melon", color = colors.green, sym = "M" },{ id = "minecraft:mycelium", name = "Mycelium", color = colors.purple, sym = "M" },{ id = "minecraft:nether_bricks", name = "Nether Bricks", color = colors.red, sym = "B" },{ id = "minecraft:end_stone", name = "End Stone", color = colors.yellow, sym = "E" },{ id = "minecraft:emerald_block", name = "Emerald Block", color = colors.green, sym = "E" },{ id = "minecraft:quartz_block", name = "Quartz Block", color = colors.white, sym = "Q" },{ id = "minecraft:white_terracotta", name = "White Terracotta", color = colors.white, sym = "T" },{ id = "minecraft:orange_terracotta", name = "Orange Terracotta", color = colors.orange, sym = "T" },{ id = "minecraft:magenta_terracotta", name = "Magenta Terracotta", color = colors.magenta, sym = "T" },{ id = "minecraft:light_blue_terracotta", name = "Light Blue Terracotta", color = colors.lightBlue, sym = "T" },{ id = "minecraft:yellow_terracotta", name = "Yellow Terracotta", color = colors.yellow, sym = "T" },{ id = "minecraft:lime_terracotta", name = "Lime Terracotta", color = colors.lime, sym = "T" },{ id = "minecraft:pink_terracotta", name = "Pink Terracotta", color = colors.pink, sym = "T" },{ id = "minecraft:gray_terracotta", name = "Gray Terracotta", color = colors.gray, sym = "T" },{ id = "minecraft:light_gray_terracotta", name = "Light Gray Terracotta", color = colors.lightGray, sym = "T" },{ id = "minecraft:cyan_terracotta", name = "Cyan Terracotta", color = colors.cyan, sym = "T" },{ id = "minecraft:purple_terracotta", name = "Purple Terracotta", color = colors.purple, sym = "T" },{ id = "minecraft:blue_terracotta", name = "Blue Terracotta", color = colors.blue, sym = "T" },{ id = "minecraft:brown_terracotta", name = "Brown Terracotta", color = colors.brown, sym = "T" },{ id = "minecraft:green_terracotta", name = "Green Terracotta", color = colors.green, sym = "T" },{ id = "minecraft:red_terracotta", name = "Red Terracotta", color = colors.red, sym = "T" },{ id = "minecraft:black_terracotta", name = "Black Terracotta", color = colors.black, sym = "T" },{ id = "minecraft:hay_block", name = "Hay Bale", color = colors.yellow, sym = "H" },{ id = "minecraft:terracotta", name = "Terracotta", color = colors.orange, sym = "T" },{ id = "minecraft:coal_block", name = "Block of Coal", color = colors.black, sym = "C" },{ id = "minecraft:packed_ice", name = "Packed Ice", color = colors.lightBlue, sym = "I" },{ id = "minecraft:blue_ice", name = "Blue Ice", color = colors.blue, sym = "I" },{ id = "minecraft:prismarine", name = "Prismarine", color = colors.cyan, sym = "P" },{ id = "minecraft:prismarine_bricks", name = "Prismarine Bricks", color = colors.cyan, sym = "P" },{ id = "minecraft:dark_prismarine", name = "Dark Prismarine", color = colors.cyan, sym = "P" },{ id = "minecraft:sea_lantern", name = "Sea Lantern", color = colors.white, sym = "L" },{ id = "minecraft:red_sandstone", name = "Red Sandstone", color = colors.orange, sym = "S" },{ id = "minecraft:magma_block", name = "Magma Block", color = colors.red, sym = "M" },{ id = "minecraft:nether_wart_block", name = "Nether Wart Block", color = colors.red, sym = "W" },{ id = "minecraft:warped_wart_block", name = "Warped Wart Block", color = colors.cyan, sym = "W" },{ id = "minecraft:red_nether_bricks", name = "Red Nether Bricks", color = colors.red, sym = "B" },{ id = "minecraft:bone_block", name = "Bone Block", color = colors.white, sym = "B" },{ id = "minecraft:shulker_box", name = "Shulker Box", color = colors.purple, sym = "S" },{ id = "minecraft:white_concrete", name = "White Concrete", color = colors.white, sym = "C" },{ id = "minecraft:orange_concrete", name = "Orange Concrete", color = colors.orange, sym = "C" },{ id = "minecraft:magenta_concrete", name = "Magenta Concrete", color = colors.magenta, sym = "C" },{ id = "minecraft:light_blue_concrete", name = "Light Blue Concrete", color = colors.lightBlue, sym = "C" },{ id = "minecraft:yellow_concrete", name = "Yellow Concrete", color = colors.yellow, sym = "C" },{ id = "minecraft:lime_concrete", name = "Lime Concrete", color = colors.lime, sym = "C" },{ id = "minecraft:pink_concrete", name = "Pink Concrete", color = colors.pink, sym = "C" },{ id = "minecraft:gray_concrete", name = "Gray Concrete", color = colors.gray, sym = "C" },{ id = "minecraft:light_gray_concrete", name = "Light Gray Concrete", color = colors.lightGray, sym = "C" },{ id = "minecraft:cyan_concrete", name = "Cyan Concrete", color = colors.cyan, sym = "C" },{ id = "minecraft:purple_concrete", name = "Purple Concrete", color = colors.purple, sym = "C" },{ id = "minecraft:blue_concrete", name = "Blue Concrete", color = colors.blue, sym = "C" },{ id = "minecraft:brown_concrete", name = "Brown Concrete", color = colors.brown, sym = "C" },{ id = "minecraft:green_concrete", name = "Green Concrete", color = colors.green, sym = "C" },{ id = "minecraft:red_concrete", name = "Red Concrete", color = colors.red, sym = "C" },{ id = "minecraft:black_concrete", name = "Black Concrete", color = colors.black, sym = "C" },{ id = "minecraft:white_concrete_powder", name = "White Concrete Powder", color = colors.white, sym = "P" },{ id = "minecraft:orange_concrete_powder", name = "Orange Concrete Powder", color = colors.orange, sym = "P" },{ id = "minecraft:magenta_concrete_powder", name = "Magenta Concrete Powder", color = colors.magenta, sym = "P" },{ id = "minecraft:light_blue_concrete_powder", name = "Light Blue Concrete Powder", color = colors.lightBlue, sym = "P" },{ id = "minecraft:yellow_concrete_powder", name = "Yellow Concrete Powder", color = colors.yellow, sym = "P" },{ id = "minecraft:lime_concrete_powder", name = "Lime Concrete Powder", color = colors.lime, sym = "P" },{ id = "minecraft:pink_concrete_powder", name = "Pink Concrete Powder", color = colors.pink, sym = "P" },{ id = "minecraft:gray_concrete_powder", name = "Gray Concrete Powder", color = colors.gray, sym = "P" },{ id = "minecraft:light_gray_concrete_powder", name = "Light Gray Concrete Powder", color = colors.lightGray, sym = "P" },{ id = "minecraft:cyan_concrete_powder", name = "Cyan Concrete Powder", color = colors.cyan, sym = "P" },{ id = "minecraft:purple_concrete_powder", name = "Purple Concrete Powder", color = colors.purple, sym = "P" },{ id = "minecraft:blue_concrete_powder", name = "Blue Concrete Powder", color = colors.blue, sym = "P" },{ id = "minecraft:brown_concrete_powder", name = "Brown Concrete Powder", color = colors.brown, sym = "P" },{ id = "minecraft:green_concrete_powder", name = "Green Concrete Powder", color = colors.green, sym = "P" },{ id = "minecraft:red_concrete_powder", name = "Red Concrete Powder", color = colors.red, sym = "P" },{ id = "minecraft:black_concrete_powder", name = "Black Concrete Powder", color = colors.black, sym = "P" },{ id = "minecraft:dried_kelp_block", name = "Dried Kelp Block", color = colors.green, sym = "K" },{ id = "minecraft:dead_tube_coral_block", name = "Dead Tube Coral Block", color = colors.gray, sym = "C" },{ id = "minecraft:dead_brain_coral_block", name = "Dead Brain Coral Block", color = colors.gray, sym = "C" },{ id = "minecraft:dead_bubble_coral_block", name = "Dead Bubble Coral Block", color = colors.gray, sym = "C" },{ id = "minecraft:dead_fire_coral_block", name = "Dead Fire Coral Block", color = colors.gray, sym = "C" },{ id = "minecraft:dead_horn_coral_block", name = "Dead Horn Coral Block", color = colors.gray, sym = "C" },{ id = "minecraft:tube_coral_block", name = "Tube Coral Block", color = colors.blue, sym = "C" },{ id = "minecraft:brain_coral_block", name = "Brain Coral Block", color = colors.pink, sym = "C" },{ id = "minecraft:bubble_coral_block", name = "Bubble Coral Block", color = colors.magenta, sym = "C" },{ id = "minecraft:fire_coral_block", name = "Fire Coral Block", color = colors.red, sym = "C" },{ id = "minecraft:horn_coral_block", name = "Horn Coral Block", color = colors.yellow, sym = "C" },{ id = "minecraft:honey_block", name = "Honey Block", color = colors.orange, sym = "H" },{ id = "minecraft:honeycomb_block", name = "Honeycomb Block", color = colors.orange, sym = "H" },{ id = "minecraft:netherite_block", name = "Block of Netherite", color = colors.black, sym = "N" },{ id = "minecraft:ancient_debris", name = "Ancient Debris", color = colors.brown, sym = "D" },{ id = "minecraft:crying_obsidian", name = "Crying Obsidian", color = colors.purple, sym = "O" },{ id = "minecraft:blackstone", name = "Blackstone", color = colors.black, sym = "B" },{ id = "minecraft:polished_blackstone", name = "Polished Blackstone", color = colors.black, sym = "B" },{ id = "minecraft:polished_blackstone_bricks", name = "Polished Blackstone Bricks", color = colors.black, sym = "B" },{ id = "minecraft:gilded_blackstone", name = "Gilded Blackstone", color = colors.black, sym = "B" },{ id = "minecraft:chiseled_polished_blackstone", name = "Chiseled Polished Blackstone", color = colors.black, sym = "B" },{ id = "minecraft:quartz_bricks", name = "Quartz Bricks", color = colors.white, sym = "Q" },{ id = "minecraft:amethyst_block", name = "Block of Amethyst", color = colors.purple, sym = "A" },{ id = "minecraft:budding_amethyst", name = "Budding Amethyst", color = colors.purple, sym = "A" },{ id = "minecraft:tuff", name = "Tuff", color = colors.gray, sym = "T" },{ id = "minecraft:calcite", name = "Calcite", color = colors.white, sym = "C" },{ id = "minecraft:tinted_glass", name = "Tinted Glass", color = colors.gray, sym = "G" },{ id = "minecraft:smooth_basalt", name = "Smooth Basalt", color = colors.gray, sym = "B" },{ id = "minecraft:raw_iron_block", name = "Block of Raw Iron", color = colors.brown, sym = "I" },{ id = "minecraft:raw_copper_block", name = "Block of Raw Copper", color = colors.orange, sym = "C" },{ id = "minecraft:raw_gold_block", name = "Block of Raw Gold", color = colors.yellow, sym = "G" },{ id = "minecraft:dripstone_block", name = "Dripstone Block", color = colors.brown, sym = "D" },{ id = "minecraft:moss_block", name = "Moss Block", color = colors.green, sym = "M" },{ id = "minecraft:mud", name = "Mud", color = colors.brown, sym = "M" },{ id = "minecraft:packed_mud", name = "Packed Mud", color = colors.brown, sym = "M" },{ id = "minecraft:mud_bricks", name = "Mud Bricks", color = colors.brown, sym = "M" },{ id = "minecraft:sculk", name = "Sculk", color = colors.cyan, sym = "S" },{ id = "minecraft:sculk_catalyst", name = "Sculk Catalyst", color = colors.cyan, sym = "S" },{ id = "minecraft:sculk_shrieker", name = "Sculk Shrieker", color = colors.cyan, sym = "S" },{ id = "minecraft:ochre_froglight", name = "Ochre Froglight", color = colors.yellow, sym = "F" },{ id = "minecraft:verdant_froglight", name = "Verdant Froglight", color = colors.green, sym = "F" },{ id = "minecraft:pearlescent_froglight", name = "Pearlescent Froglight", color = colors.purple, sym = "F" },}return items]======]
files['lib/lib_json.lua'] = [=========[---@diagnostic disable: undefined-global

local json_utils = {}

function json_utils.encode(data)
    if textutils and textutils.serializeJSON then
        return textutils.serializeJSON(data)
    end
    return nil, "json_encoder_unavailable"
end

function json_utils.decodeJson(text)
    if type(text) ~= "string" then
        return nil, "invalid_json"
    end
    if textutils and textutils.unserializeJSON then
        local ok, result = pcall(textutils.unserializeJSON, text)
        if ok and result ~= nil then
            return result
        end
        return nil, "json_parse_failed"
    end
    local ok, json = pcall(require, "json")
    if ok and type(json) == "table" and type(json.decode) == "function" then
        local okDecode, result = pcall(json.decode, text)
        if okDecode then
            return result
        end
        return nil, "json_parse_failed"
    end
    return nil, "json_decoder_unavailable"
end

return json_utils]=========]
files['lib/lib_license.lua'] = [=======[---@diagnostic disable: undefined-global-- license_store.lua-- Simple disk-backed license manager for arcade programs.-- Uses lightweight signatures to discourage casual tampering of license files.local LicenseStore = {}LicenseStore.__index = LicenseStore-- Lua tip: small helper functions keep the public API easy to read.local function ensureDirectory(path)if not fs.exists(path) thenfs.makeDir(path)endendlocal function computeHash(input)if textutils.sha256 thenreturn textutils.sha256(input)end-- Fallback checksum if sha256 is unavailable; keeps deterministic signature.local sum = 0for i = 1, #input dosum = (sum + string.byte(input, i)) % 0xFFFFFFFFendreturn string.format("%08x", sum)endlocal function signaturePayload(license)return table.concat({license.programId or "",tostring(license.purchasedAt or ""),tostring(license.pricePaid or ""),tostring(license.note or ""),}, "|")endlocal function signatureFor(license, secret)return computeHash(signaturePayload(license) .. "|" .. secret)endfunction LicenseStore.new(rootPath, secret)local store = setmetatable({}, LicenseStore)store.rootPath = rootPath or "licenses"store.secret = secret or "arcade-license-v1"ensureDirectory(store.rootPath)return storeendfunction LicenseStore:licensePath(programId)return fs.combine(self.rootPath, programId .. ".lic")endfunction LicenseStore:load(programId)local path = self:licensePath(programId)if not fs.exists(path) thenreturn nil, "missing"endlocal handle = fs.open(path, "r")local content = handle.readAll()handle.close()local data = textutils.unserialize(content)if type(data) ~= "table" thenreturn nil, "corrupt"endlocal expected = signatureFor(data, self.secret)if data.signature ~= expected thenreturn nil, "invalid_signature"endreturn dataendfunction LicenseStore:has(programId)local license = self:load(programId)if license thenreturn true, licenseendreturn falseendfunction LicenseStore:save(programId, pricePaid, note)local license = {programId = programId,purchasedAt = os.epoch("utc"),pricePaid = pricePaid or 0,note = note,}license.signature = signatureFor(license, self.secret)local handle = fs.open(self:licensePath(programId), "w")handle.write(textutils.serialize(license))handle.close()return licenseendreturn LicenseStore]=======]
files['lib/lib_logger.lua'] = [=========[---@diagnostic disable: undefined-globallocal logger = {}local diagnosticslocal diagnosticsOk, diagnosticsModule = pcall(require, "lib_diagnostics")if diagnosticsOk thendiagnostics = diagnosticsModuleendlocal DEFAULT_CRASH_FILE = "crashfile"local DEFAULT_LEVEL = "info"local DEFAULT_CAPTURE_LIMIT = 200local LEVEL_VALUE = {debug = 10,info = 20,warn = 30,error = 40,}local LEVEL_LABEL = {debug = "DEBUG",info = "INFO",warn = "WARN",error = "ERROR",}local LEVEL_ALIAS = {warning = "warn",err = "error",trace = "debug",verbose = "debug",fatal = "error",}local function isoTimestamp()if os and type(os.date) == "function" thenreturn os.date("!%Y-%m-%dT%H:%M:%SZ")endif os and type(os.clock) == "function" thenreturn string.format("%.03f", os.clock())endreturn nilendlocal function getCrashFilePath(ctx)if ctx thenlocal config = ctx.configif config and type(config.crashFile) == "string" and config.crashFile ~= "" thenreturn config.crashFileendif type(ctx.crashFilePath) == "string" and ctx.crashFilePath ~= "" thenreturn ctx.crashFilePathendendreturn DEFAULT_CRASH_FILEendlocal function buildCrashPayload(ctx, message, metadata)local payload = {message = message or "Unknown fatal error",metadata = metadata,timestamp = isoTimestamp(),}if diagnostics and ctx thenlocal ok, snapshot = pcall(diagnostics.snapshot, ctx)if ok thenpayload.context = snapshotendendif ctx and ctx.logger and type(ctx.logger.getLastEntry) == "function" thenlocal ok, entry = pcall(ctx.logger.getLastEntry, ctx.logger)if ok thenpayload.lastLogEntry = entryendendreturn payloadendlocal function serializeCrashPayload(payload)if textutils and type(textutils.serializeJSON) == "function" thenlocal ok, serialized = pcall(textutils.serializeJSON, payload, { compact = true })if ok thenreturn serializedendendif textutils and type(textutils.serialize) == "function" thenlocal ok, serialized = pcall(textutils.serialize, payload)if ok thenreturn serializedendendlocal parts = {}for key, value in pairs(payload or {}) doparts[#parts + 1] = tostring(key) .. "=" .. tostring(value)endtable.sort(parts)return table.concat(parts, "\n")endlocal function writeFile(path, contents)if not fs or type(fs.open) ~= "function" thenreturn false, "fs_unavailable"endlocal handle, err = fs.open(path, "w")if not handle thenreturn false, err or "open_failed"endhandle.write(contents)handle.close()return trueendlocal function copyTable(value, depth, seen)if type(value) ~= "table" thenreturn valueendif depth and depth <= 0 thenreturn valueendseen = seen or {}if seen[value] thenreturn "<recursive>"endseen[value] = truelocal result = {}for k, v in pairs(value) dolocal newKey = copyTable(k, depth and (depth - 1) or nil, seen)local newValue = copyTable(v, depth and (depth - 1) or nil, seen)result[newKey] = newValueendseen[value] = nilreturn resultendlocal function trySerializers(meta)if type(meta) ~= "table" thenreturn nilendif textutils and type(textutils.serialize) == "function" thenlocal ok, serialized = pcall(textutils.serialize, meta)if ok thenreturn serializedendendif textutils and type(textutils.serializeJSON) == "function" thenlocal ok, serialized = pcall(textutils.serializeJSON, meta)if ok thenreturn serializedendendreturn nilendlocal function formatMetadata(meta)if meta == nil thenreturn ""endlocal metaType = type(meta)if metaType == "string" thenreturn metaelseif metaType == "number" or metaType == "boolean" thenreturn tostring(meta)elseif metaType == "table" thenlocal serialized = trySerializers(meta)if serialized thenreturn serializedendlocal parts = {}local count = 0for key, value in pairs(meta) doparts[#parts + 1] = tostring(key) .. "=" .. tostring(value)count = count + 1if count >= 16 thenbreakendendtable.sort(parts)return "{" .. table.concat(parts, ", ") .. "}"endreturn tostring(meta)endlocal function formatMessage(message)if message == nil thenreturn ""endlocal msgType = type(message)if msgType == "string" thenreturn messageelseif msgType == "number" or msgType == "boolean" thenreturn tostring(message)elseif msgType == "table" thenif message.message and type(message.message) == "string" thenreturn message.messageendlocal metaView = formatMetadata(message)if metaView ~= "" thenreturn metaViewendendreturn tostring(message)endlocal function resolveLevel(level)if type(level) == "string" thenlocal lowered = level:lower()lowered = LEVEL_ALIAS[lowered] or loweredif LEVEL_VALUE[lowered] thenreturn loweredendreturn nilelseif type(level) == "number" thenlocal closestlocal distancefor name, value in pairs(LEVEL_VALUE) dolocal diff = math.abs(value - level)if not closest or diff < distance thenclosest = namedistance = diffendendreturn closestendreturn nilendlocal function levelValue(level)return LEVEL_VALUE[level] or LEVEL_VALUE[DEFAULT_LEVEL]endlocal function shouldEmit(level, thresholdValue)return levelValue(level) >= thresholdValueendlocal function formatTimestamp(state)if not state.timestamps thenreturn nil, nilendlocal fmt = state.timestampFormat or "%H:%M:%S"if os and type(os.date) == "function" thenlocal timeNumber = os.time and os.time() or nillocal stamp = os.date(fmt)return stamp, timeNumberendif os and type(os.clock) == "function" thenlocal clockValue = os.clock()return string.format("%.03f", clockValue), clockValueendreturn nil, nilendlocal function cloneEntry(entry)return copyTable(entry, 3)endlocal function pushHistory(state, entry)local history = state.historyhistory[#history + 1] = cloneEntry(entry)local limit = state.captureLimit or DEFAULT_CAPTURE_LIMITwhile #history > limit dotable.remove(history, 1)endendlocal function defaultWriterFactory(state)return function(entry)local segments = {}if entry.timestamp thensegments[#segments + 1] = entry.timestampelseif state.timestamps and state.lastTimestamp thensegments[#segments + 1] = state.lastTimestampendif entry.tag thensegments[#segments + 1] = entry.tagelseif state.tag thensegments[#segments + 1] = state.tagendsegments[#segments + 1] = entry.levelLabel or entry.levellocal prefix = "[" .. table.concat(segments, "][") .. "]"local line = prefix .. " " .. entry.messagelocal metaStr = formatMetadata(entry.metadata)if metaStr ~= "" thenline = line .. " | " .. metaStrendif print thenprint(line)elseif io and io.write thenio.write(line .. "\n")endendendlocal function addWriter(state, writer)if type(writer) ~= "function" thenreturn false, "invalid_writer"endfor _, existing in ipairs(state.writers) doif existing == writer thenreturn false, "writer_exists"endendstate.writers[#state.writers + 1] = writerreturn trueendlocal function logInternal(state, level, message, metadata)local resolved = resolveLevel(level)if not resolved thenreturn false, "unknown_level"endif not shouldEmit(resolved, state.thresholdValue) thenreturn false, "level_filtered"endlocal timestamp, timeNumber = formatTimestamp(state)state.lastTimestamp = timestamp or state.lastTimestamplocal entry = {level = resolved,levelLabel = LEVEL_LABEL[resolved],message = formatMessage(message),metadata = metadata,timestamp = timestamp,time = timeNumber,sequence = state.sequence + 1,tag = state.tag,}state.sequence = entry.sequencestate.lastEntry = entryif state.capture thenpushHistory(state, entry)endfor _, writer in ipairs(state.writers) dolocal ok, err = pcall(writer, entry)if not ok thenstate.lastWriterError = errendendreturn true, entryendfunction logger.new(opts)local state = {capture = opts and opts.capture or false,captureLimit = (opts and type(opts.captureLimit) == "number" and opts.captureLimit > 0) and opts.captureLimit or DEFAULT_CAPTURE_LIMIT,history = {},sequence = 0,writers = {},timestamps = opts and (opts.timestamps or opts.timestamp) or false,timestampFormat = opts and opts.timestampFormat or nil,tag = opts and (opts.tag or opts.label) or nil,}local initialLevel = (opts and resolveLevel(opts.level)) or (opts and resolveLevel(opts.minLevel)) or DEFAULT_LEVELstate.threshold = initialLevelstate.thresholdValue = levelValue(initialLevel)local instance = {}state.instance = instanceif not (opts and opts.silent) thenaddWriter(state, defaultWriterFactory(state))endif opts and type(opts.writer) == "function" thenaddWriter(state, opts.writer)endif opts and type(opts.writers) == "table" thenfor _, writer in ipairs(opts.writers) doif type(writer) == "function" thenaddWriter(state, writer)endendendfunction instance:log(level, message, metadata)return logInternal(state, level, message, metadata)endfunction instance:debug(message, metadata)return logInternal(state, "debug", message, metadata)endfunction instance:info(message, metadata)return logInternal(state, "info", message, metadata)endfunction instance:warn(message, metadata)return logInternal(state, "warn", message, metadata)endfunction instance:error(message, metadata)return logInternal(state, "error", message, metadata)endfunction instance:setLevel(level)local resolved = resolveLevel(level)if not resolved thenreturn false, "unknown_level"endstate.threshold = resolvedstate.thresholdValue = levelValue(resolved)return true, resolvedendfunction instance:getLevel()return state.thresholdendfunction instance:enableCapture(limit)state.capture = trueif type(limit) == "number" and limit > 0 thenstate.captureLimit = limitendreturn trueendfunction instance:disableCapture()state.capture = falsestate.history = {}return trueendfunction instance:getHistory()local result = {}for index = 1, #state.history doresult[index] = cloneEntry(state.history[index])endreturn resultendfunction instance:clearHistory()state.history = {}return trueendfunction instance:addWriter(writer)return addWriter(state, writer)endfunction instance:removeWriter(writer)if type(writer) ~= "function" thenreturn false, "invalid_writer"endfor index, existing in ipairs(state.writers) doif existing == writer thentable.remove(state.writers, index)return trueendendreturn false, "writer_missing"endfunction instance:setTag(tag)state.tag = tagreturn trueendfunction instance:getTag()return state.tagendfunction instance:getLastEntry()if not state.lastEntry thenreturn nilendreturn cloneEntry(state.lastEntry)endfunction instance:getLastWriterError()return state.lastWriterErrorendfunction instance:setTimestamps(enabled, format)state.timestamps = not not enabledif format thenstate.timestampFormat = formatendreturn trueendreturn instanceendfunction logger.attach(ctx, opts)if type(ctx) ~= "table" thenerror("logger.attach requires a context table", 2)endlocal instance = logger.new(opts)ctx.logger = instancereturn instanceendfunction logger.isLogger(candidate)if type(candidate) ~= "table" thenreturn falseendreturn type(candidate.log) == "function"and type(candidate.info) == "function"and type(candidate.warn) == "function"and type(candidate.error) == "function"endlogger.DEFAULT_LEVEL = DEFAULT_LEVELlogger.DEFAULT_CAPTURE_LIMIT = DEFAULT_CAPTURE_LIMITlogger.LEVELS = copyTable(LEVEL_VALUE, 1)logger.LABELS = copyTable(LEVEL_LABEL, 1)logger.resolveLevel = resolveLevellogger.DEFAULT_CRASH_FILE = DEFAULT_CRASH_FILEfunction logger.log(ctx, level, message)if type(ctx) ~= "table" thenreturnendlocal logInst = ctx.loggerif type(logInst) == "table" thenlocal fn = logInst[level]if type(fn) == "function" thenfn(logInst, message)returnendif type(logInst.log) == "function" thenlogInst.log(logInst, level, message)returnendendif (level == "warn" or level == "error") and message thenprint(string.format("[%s] %s", level:upper(), message))endendfunction logger.writeCrashFile(ctx, message, metadata)local path = getCrashFilePath(ctx)local payload = buildCrashPayload(ctx, message, metadata)local body = serializeCrashPayload(payload)if not body or body == "" thenbody = tostring(message or "Unknown fatal error")endlocal ok, err = writeFile(path, body .. "\n")if not ok thenreturn false, errendif ctx thenctx.crashFilePath = pathendreturn true, pathendreturn logger]=========]
files['lib/lib_menu.lua'] = [=======[---@diagnostic disable: undefined-global, undefined-fieldlocal menu = {}-- Helper to center textlocal function centerText(y, text)local w, h = term.getSize()local x = math.floor((w - #text) / 2) + 1term.setCursorPos(x, y)term.write(text)endfunction menu.draw(title, options, selectedIndex, scrollOffset)local w, h = term.getSize()if term.isColor() thenterm.setBackgroundColor(colors.black)term.setTextColor(colors.white)endterm.clear()-- Draw Titleif term.isColor() thenterm.setTextColor(colors.yellow)endcenterText(1, title)if term.isColor() thenterm.setTextColor(colors.white)endterm.setCursorPos(1, 2)term.write(string.rep("-", w))-- Calculate visible arealocal listStart = 3local listHeight = h - 4 -- Reserve space for title (2) and footer (1)-- Draw Optionsfor i = 1, listHeight dolocal optionIndex = i + scrollOffsetif optionIndex <= #options thenlocal option = options[optionIndex]local text = type(option) == "table" and option.text or tostring(option)-- Truncate if too longif #text > w - 4 thentext = string.sub(text, 1, w - 7) .. "..."endterm.setCursorPos(2, listStart + i - 1)if optionIndex == selectedIndex then-- Selected Itemif term.isColor() thenterm.setTextColor(colors.lime)endterm.write("> " .. text .. " <")else-- Normal Itemif term.isColor() thenterm.setTextColor(colors.white)endterm.write("  " .. text)endendend-- Draw Footerterm.setCursorPos(1, h)if term.isColor() then term.setTextColor(colors.gray) endlocal footer = "Up/Down: Move | Enter: Select"centerText(h, footer)-- Reset colorsif term.isColor() then term.setTextColor(colors.white) endendfunction menu.run(title, options)local selectedIndex = 1local scrollOffset = 0local w, h = term.getSize()local listHeight = h - 4while true do-- Adjust scroll to keep selected item in viewif selectedIndex <= scrollOffset thenscrollOffset = selectedIndex - 1elseif selectedIndex > scrollOffset + listHeight thenscrollOffset = selectedIndex - listHeightendmenu.draw(title, options, selectedIndex, scrollOffset)local event, key = os.pullEvent("key")if key == keys.up thenselectedIndex = selectedIndex - 1if selectedIndex < 1 then selectedIndex = #options endelseif key == keys.down thenselectedIndex = selectedIndex + 1if selectedIndex > #options then selectedIndex = 1 endelseif key == keys.enter thenterm.clear()term.setCursorPos(1,1)return selectedIndex, options[selectedIndex]endendendreturn menu]=======]
files['lib/lib_mining.lua'] = [=======[---@diagnostic disable: undefined-globallocal mining = {}local inventory = require("lib_inventory")local movement = require("lib_movement")local logger = require("lib_logger")local json = require("lib_json")local CONFIG_FILE = "data/trash_config.json"-- Blocks that are considered "trash" and should be ignored during ore scanning.-- Also used to determine what blocks can be used to fill holes.mining.TRASH_BLOCKS = inventory.DEFAULT_TRASHmining.TRASH_BLOCKS["minecraft:chest"] = truemining.TRASH_BLOCKS["minecraft:barrel"] = truemining.TRASH_BLOCKS["minecraft:trapped_chest"] = truemining.TRASH_BLOCKS["minecraft:torch"] = truefunction mining.loadConfig()if fs.exists(CONFIG_FILE) thenlocal f = fs.open(CONFIG_FILE, "r")if f thenlocal data = f.readAll()f.close()local config = json.decodeJson(data)if config and config.trash thenfor k, v in pairs(config.trash) domining.TRASH_BLOCKS[k] = vendendendendendfunction mining.saveConfig()local config = { trash = mining.TRASH_BLOCKS }local data = json.encode(config)-- Ensure data directory existsif not fs.exists("data") thenfs.makeDir("data")endlocal f = fs.open(CONFIG_FILE, "w")if f thenf.write(data)f.close()endend-- Load config on startupmining.loadConfig()-- Blocks that should NEVER be placed to fill holes (liquids, gravity blocks, etc)mining.FILL_BLACKLIST = {["minecraft:air"] = true,["minecraft:water_bucket"] = true,["minecraft:lava"] = true,["minecraft:sand"] = true,["minecraft:gravel"] = true,["minecraft:torch"] = true,["minecraft:bedrock"] = true,["minecraft:chest"] = true,["minecraft:barrel"] = true,["minecraft:trapped_chest"] = true,}--- Check if a block is considered "ore" (valuable)function mining.isOre(name)if not name then return false endreturn not mining.TRASH_BLOCKS[name]end--- Find a suitable trash block in inventory to use for fillinglocal function findFillMaterial(ctx)inventory.scan(ctx)local state = inventory.ensureState(ctx)if not state or not state.slots then return nil endfor slot, item in pairs(state.slots) doif mining.TRASH_BLOCKS[item.name] and not mining.FILL_BLACKLIST[item.name] thenreturn slot, item.nameendendreturn nilend--- Mine a block in a specific direction if it's valuable, then fill the hole-- @param dir "front", "up", "down"function mining.mineAndFill(ctx, dir)local inspect, dig, place, suckif dir == "front" theninspect = turtle.inspectdig = turtle.digplace = turtle.placesuck = turtle.suckelseif dir == "up" theninspect = turtle.inspectUpdig = turtle.digUpplace = turtle.placeUpsuck = turtle.suckUpelseif dir == "down" theninspect = turtle.inspectDowndig = turtle.digDownplace = turtle.placeDownsuck = turtle.suckDownelsereturn false, "Invalid direction"endlocal hasBlock, data = inspect()if hasBlock and mining.isOre(data.name) thenlogger.log(ctx, "info", "Mining valuable: " .. data.name)if dig() thensleep(0.2)while suck() do sleep(0.1) end-- Attempt to fill the holelocal slot = findFillMaterial(ctx)if slot thenturtle.select(slot)place()elselogger.log(ctx, "warn", "No trash blocks available to fill hole")endreturn trueelselogger.log(ctx, "warn", "Failed to dig " .. data.name)endendreturn falseend--- Scan all 6 directions around the turtle, mine ores, and fill holes.-- The turtle will return to its original facing.function mining.scanAndMineNeighbors(ctx)-- Check Upmining.mineAndFill(ctx, "up")-- Check Downmining.mineAndFill(ctx, "down")-- Check 4 horizontal directionsfor i = 1, 4 domining.mineAndFill(ctx, "front")movement.turnRight(ctx)endendreturn mining]=======]
files['lib/lib_monitor.lua'] = [======[local monitor = {}

local function safeInvoke(obj, method, ...)
    if not obj then return nil end
    local fn = obj[method]
    if type(fn) ~= "function" then return nil end
    local ok, res = pcall(fn, obj, ...)
    if ok then return res end
    return nil
end

local function pickMonitor(opts)
    if not peripheral or type(peripheral.find) ~= "function" then
        return nil
    end

    opts = opts or {}
    local preferred = {}
    if type(opts.preferredName) == "string" then
        preferred[#preferred + 1] = opts.preferredName
    end
    if type(opts.preferredNames) == "table" then
        for _, name in ipairs(opts.preferredNames) do
            if type(name) == "string" then
                preferred[#preferred + 1] = name
            end
        end
    end

    if #preferred > 0 and peripheral.wrap then
        for _, name in ipairs(preferred) do
            local ok, wrapped = pcall(peripheral.wrap, name)
            if ok and wrapped then
                return wrapped
            end
        end
    end

    local requireColor = opts.requireColor == true
    local userFilter = type(opts.filter) == "function" and opts.filter or nil
    local filter = nil
    if requireColor or userFilter then
        filter = function(name, wrapped)
            if userFilter then
                local ok, res = pcall(userFilter, name, wrapped)
                if not ok then return false end
                if res == false then return false end
            end
            if requireColor then
                local isColor = safeInvoke(wrapped, "isColor")
                if isColor == false then return false end
            end
            return true
        end
    end

    local ok, wrapped = pcall(peripheral.find, "monitor", filter)
    if ok then
        return wrapped
    end
    return nil
end

---Redirect the current terminal to an attached monitor if found.
---@param opts table|nil
---@return table|nil session table {monitor, native, restore} or nil if no monitor/redirect failed
---@return any err optional error when redirect fails
function monitor.redirectToMonitor(opts)
    opts = opts or {}
    if opts.skipOnTurtle and turtle then
        return nil
    end
    if not term or type(term.redirect) ~= "function" or type(term.current) ~= "function" then
        return nil
    end

    local target = pickMonitor(opts)
    if not target then
        return nil
    end

    if opts.textScale then
        safeInvoke(target, "setTextScale", opts.textScale)
    end
    if opts.clear ~= false then
        safeInvoke(target, "setBackgroundColor", colors.black)
        safeInvoke(target, "setTextColor", colors.white)
        safeInvoke(target, "clear")
        safeInvoke(target, "setCursorPos", 1, 1)
    end

    local native = term.current()
    if native == target then
        return { monitor = target, native = native, restore = function() end }
    end

    local ok, err = pcall(term.redirect, target)
    if not ok then
        return nil, err
    end

    local restored = false
    local function restore()
        if restored then return end
        restored = true
        if native then
            pcall(term.redirect, native)
        end
    end

    return {
        monitor = target,
        native = native,
        restore = restore,
    }
end

---Run a function while redirecting output to a monitor when available.
---@param fn function
---@param opts table|nil options forwarded to redirectToMonitor
function monitor.runOnMonitor(fn, opts)
    if type(fn) ~= "function" then
        return nil, "fn_missing"
    end
    opts = opts or {}
    local auto = true
    if type(opts.auto) == "boolean" then
        auto = opts.auto
    end
    local session = nil
    if auto ~= false then
        session = monitor.redirectToMonitor(opts)
    end
    local handler = (debug and debug.traceback) or function(err) return err end
    local ok, res = xpcall(fn, handler)
    if session and session.restore then
        session.restore()
    end
    if not ok then
        local msg = tostring(res)
        -- When user terminates (Ctrl+T), avoid crashing outer shell; just forward nil.
        if msg == "Terminated" or msg:match("Terminated$") then
            return nil, "terminated"
        end
        error(res)
    end
    return res
end

return monitor]======]
files['lib/lib_movement.lua'] = [===[---@diagnostic disable: undefined-global, undefined-fieldlocal movement = {}local logger = require("lib_logger")local CARDINALS = {"north", "east", "south", "west"}local DIRECTION_VECTORS = {north = { x = 0, y = 0, z = -1 },east = { x = 1, y = 0, z = 0 },south = { x = 0, y = 0, z = 1 },west = { x = -1, y = 0, z = 0 },}local AXIS_FACINGS = {x = { positive = "east", negative = "west" },z = { positive = "south", negative = "north" },}local DEFAULT_SOFT_BLOCKS = {["minecraft:snow"] = true,["minecraft:snow_layer"] = true,["minecraft:powder_snow"] = true,["minecraft:tall_grass"] = true,["minecraft:large_fern"] = true,["minecraft:grass"] = true,["minecraft:fern"] = true,["minecraft:cave_vines"] = true,["minecraft:cave_vines_plant"] = true,["minecraft:kelp"] = true,["minecraft:kelp_plant"] = true,["minecraft:sweet_berry_bush"] = true,}local DEFAULT_SOFT_TAGS = {["minecraft:snow"] = true,["minecraft:replaceable_plants"] = true,["minecraft:flowers"] = true,["minecraft:saplings"] = true,["minecraft:carpets"] = true,}local DEFAULT_SOFT_NAME_HINTS = {"sapling","propagule","seedling",}local function cloneLookup(source)local lookup = {}for key, value in pairs(source) doif value thenlookup[key] = trueendendreturn lookupendlocal function extendLookup(lookup, entries)if type(entries) ~= "table" thenreturn lookupendif #entries > 0 thenfor _, name in ipairs(entries) doif type(name) == "string" thenlookup[name] = trueendendelsefor name, enabled in pairs(entries) doif enabled and type(name) == "string" thenlookup[name] = trueendendendreturn lookupendlocal function buildSoftNameHintList(configHints)local seen = {}local list = {}local function append(value)if type(value) ~= "string" thenreturnendlocal normalized = value:lower()if normalized == "" or seen[normalized] thenreturnendseen[normalized] = truelist[#list + 1] = normalizedendfor _, hint in ipairs(DEFAULT_SOFT_NAME_HINTS) doappend(hint)endif type(configHints) == "table" thenif #configHints > 0 thenfor _, entry in ipairs(configHints) doappend(entry)endelsefor name, enabled in pairs(configHints) doif enabled thenappend(name)endendendelseif type(configHints) == "string" thenappend(configHints)endreturn listendlocal function matchesSoftNameHint(hints, blockName)if type(blockName) ~= "string" thenreturn falseendlocal lowered = blockName:lower()for _, hint in ipairs(hints or {}) doif lowered:find(hint, 1, true) thenreturn trueendendreturn falseendlocal function isSoftBlock(state, inspectData)if type(state) ~= "table" or type(inspectData) ~= "table" thenreturn falseendlocal name = inspectData.nameif type(name) == "string" thenif state.softBlockLookup and state.softBlockLookup[name] thenreturn trueendif matchesSoftNameHint(state.softNameHints, name) thenreturn trueendendlocal tags = inspectData.tagsif type(tags) == "table" and state.softTagLookup thenfor tag, value in pairs(tags) doif value and state.softTagLookup[tag] thenreturn trueendendendreturn falseendlocal function canonicalFacing(name)if type(name) ~= "string" thenreturn nilendname = name:lower()if DIRECTION_VECTORS[name] thenreturn nameendreturn nilendlocal function copyPosition(pos)if not pos thenreturn { x = 0, y = 0, z = 0 }endreturn { x = pos.x or 0, y = pos.y or 0, z = pos.z or 0 }endlocal function vecAdd(a, b)return { x = (a.x or 0) + (b.x or 0), y = (a.y or 0) + (b.y or 0), z = (a.z or 0) + (b.z or 0) }endlocal function getPlannedMaterial(ctx, pos)if type(ctx) ~= "table" or type(pos) ~= "table" thenreturn nilendlocal plan = ctx.buildPlanif type(plan) ~= "table" thenreturn nilendlocal x = pos.xlocal xLayer = plan[x] or plan[tostring(x)]if type(xLayer) ~= "table" thenreturn nilendlocal y = pos.ylocal yLayer = xLayer[y] or xLayer[tostring(y)]if type(yLayer) ~= "table" thenreturn nilendlocal z = pos.zreturn yLayer[z] or yLayer[tostring(z)]endlocal function tryInspect(inspectFn)if type(inspectFn) ~= "function" thenreturn nilendlocal ok, success, data = pcall(inspectFn)if not ok or not success thenreturn nilendif type(data) == "table" thenreturn dataendreturn nilendlocal function ensureMovementState(ctx)if type(ctx) ~= "table" thenerror("movement library requires a context table", 2)endctx.movement = ctx.movement or {}local state = ctx.movementlocal cfg = ctx.config or {}if not state.position thenif ctx.origin thenstate.position = copyPosition(ctx.origin)elsestate.position = { x = 0, y = 0, z = 0 }endendif not state.homeFacing thenstate.homeFacing = canonicalFacing(cfg.homeFacing) or canonicalFacing(cfg.initialFacing) or "north"endif not state.facing thenstate.facing = canonicalFacing(cfg.initialFacing) or state.homeFacingendstate.position = copyPosition(state.position)if not state.softBlockLookup thenstate.softBlockLookup = extendLookup(cloneLookup(DEFAULT_SOFT_BLOCKS), cfg.movementSoftBlocks)endif not state.softTagLookup thenstate.softTagLookup = extendLookup(cloneLookup(DEFAULT_SOFT_TAGS), cfg.movementSoftTags)endif not state.softNameHints thenstate.softNameHints = buildSoftNameHintList(cfg.movementSoftNameHints)endstate.hasSoftClearRules = (next(state.softBlockLookup) ~= nil)or (next(state.softTagLookup) ~= nil)or ((state.softNameHints and #state.softNameHints > 0) or false)return stateendfunction movement.ensureState(ctx)return ensureMovementState(ctx)endfunction movement.getPosition(ctx)local state = ensureMovementState(ctx)return copyPosition(state.position)endfunction movement.setPosition(ctx, pos)local state = ensureMovementState(ctx)state.position = copyPosition(pos)return trueendfunction movement.getFacing(ctx)local state = ensureMovementState(ctx)return state.facingendfunction movement.setFacing(ctx, facing)local state = ensureMovementState(ctx)local canonical = canonicalFacing(facing)if not canonical thenreturn false, "unknown facing: " .. tostring(facing)endstate.facing = canonicallogger.log(ctx, "debug", "Set facing to " .. canonical)if ctx.save then ctx.save() endreturn trueendlocal function turn(ctx, direction)local state = ensureMovementState(ctx)if not turtle thenreturn false, "turtle API unavailable"endlocal rotateFnif direction == "left" thenrotateFn = turtle.turnLeftelseif direction == "right" thenrotateFn = turtle.turnRightelsereturn false, "invalid turn direction"endif not rotateFn thenreturn false, "turn function missing"endlocal ok = rotateFn()if not ok thenreturn false, "turn " .. direction .. " failed"endlocal current = state.facinglocal indexfor i, name in ipairs(CARDINALS) doif name == current thenindex = ibreakendendif not index thenindex = 1current = CARDINALS[index]endif direction == "left" thenindex = ((index - 2) % #CARDINALS) + 1elseindex = (index % #CARDINALS) + 1endstate.facing = CARDINALS[index]logger.log(ctx, "debug", "Turned " .. direction .. ", now facing " .. state.facing)if ctx.save then ctx.save() endreturn trueendfunction movement.turnLeft(ctx)return turn(ctx, "left")endfunction movement.turnRight(ctx)return turn(ctx, "right")endfunction movement.turnAround(ctx)local ok, err = movement.turnRight(ctx)if not ok thenreturn false, errendok, err = movement.turnRight(ctx)if not ok thenreturn false, errendreturn trueendfunction movement.faceDirection(ctx, targetFacing)local state = ensureMovementState(ctx)local canonical = canonicalFacing(targetFacing)if not canonical thenreturn false, "unknown facing: " .. tostring(targetFacing)endlocal currentIndexlocal targetIndexfor i, name in ipairs(CARDINALS) doif name == state.facing thencurrentIndex = iendif name == canonical thentargetIndex = iendendif not targetIndex thenreturn false, "cannot face unknown cardinal"endif currentIndex == targetIndex thenreturn trueendif not currentIndex thenstate.facing = canonicalreturn trueendlocal diff = (targetIndex - currentIndex) % #CARDINALSif diff == 0 thenreturn trueelseif diff == 1 thenreturn movement.turnRight(ctx)elseif diff == 2 thenlocal ok, err = movement.turnRight(ctx)if not ok thenreturn false, errendok, err = movement.turnRight(ctx)if not ok thenreturn false, errendreturn trueelse -- diff == 3return movement.turnLeft(ctx)endendlocal function getMoveConfig(ctx, opts)local cfg = ctx.config or {}local maxRetries = (opts and opts.maxRetries) or cfg.maxMoveRetries or 5local allowDig = opts and opts.digif allowDig == nil thenallowDig = cfg.digOnMoveif allowDig == nil thenallowDig = trueendendlocal allowAttack = opts and opts.attackif allowAttack == nil thenallowAttack = cfg.attackOnMoveif allowAttack == nil thenallowAttack = trueendendlocal delay = (opts and opts.retryDelay) or cfg.moveRetryDelay or 0.5return maxRetries, allowDig, allowAttack, delayendlocal function moveWithRetries(ctx, opts, moveFns, delta)local state = ensureMovementState(ctx)if not turtle thenreturn false, "turtle API unavailable"endlocal maxRetries, allowDig, allowAttack, delay = getMoveConfig(ctx, opts)if type(maxRetries) ~= "number" or maxRetries < 1 thenmaxRetries = 1elsemaxRetries = math.floor(maxRetries)endif (allowDig or state.hasSoftClearRules) and maxRetries < 2 then-- Ensure we attempt at least two cycles whenever we might clear obstructions.maxRetries = 2endlocal attempt = 0while attempt < maxRetries doattempt = attempt + 1local targetPos = vecAdd(state.position, delta)if moveFns.move() thenstate.position = targetPoslogger.log(ctx, "debug", string.format("Moved to x=%d y=%d z=%d", state.position.x, state.position.y, state.position.z))if ctx.save then ctx.save() endreturn trueendlocal handled = falseif allowAttack and moveFns.attack thenif moveFns.attack() thenhandled = truelogger.log(ctx, "debug", "Attacked entity blocking movement")endendlocal blocked = moveFns.detect and moveFns.detect() or falselocal inspectDataif blocked theninspectData = tryInspect(moveFns.inspect)endif blocked and moveFns.dig thenlocal plannedMateriallocal canClear = falselocal softBlock = inspectData and isSoftBlock(state, inspectData)if softBlock thencanClear = trueelseif allowDig thenplannedMaterial = getPlannedMaterial(ctx, targetPos)canClear = true-- Safety check: Do not dig chests/barrels unless explicitly allowedif inspectData and inspectData.name and (inspectData.name:find("chest") or inspectData.name:find("barrel")) thenif not opts or not opts.forceDigChests thencanClear = falselogger.log(ctx, "warn", "Refusing to dig chest/barrel at " .. tostring(inspectData.name))endendif plannedMaterial thenif inspectData and inspectData.name thenif inspectData.name == plannedMaterial thencanClear = falseendelsecanClear = falseendendendif canClear and moveFns.dig() thenhandled = trueif moveFns.suck thenmoveFns.suck()endif softBlock thenlocal foundName = inspectData and inspectData.name or "unknown"logger.log(ctx, "debug", string.format("Cleared soft obstruction %s at x=%d y=%d z=%d",tostring(foundName),targetPos.x or 0,targetPos.y or 0,targetPos.z or 0))elseif plannedMaterial thenlocal foundName = inspectData and inspectData.name or "unknown"logger.log(ctx, "debug", string.format("Cleared mismatched block %s (expected %s) at x=%d y=%d z=%d",tostring(foundName),tostring(plannedMaterial),targetPos.x or 0,targetPos.y or 0,targetPos.z or 0))elselocal foundName = inspectData and inspectData.nameif foundName thenlogger.log(ctx, "debug", string.format("Dug blocking block %s at x=%d y=%d z=%d",foundName,targetPos.x or 0,targetPos.y or 0,targetPos.z or 0))elselogger.log(ctx, "debug", string.format("Dug blocking block at x=%d y=%d z=%d",targetPos.x or 0,targetPos.y or 0,targetPos.z or 0))endendelseif plannedMaterial and not canClear and allowDig thenlogger.log(ctx, "debug", string.format("Preserving planned block %s at x=%d y=%d z=%d",tostring(plannedMaterial),targetPos.x or 0,targetPos.y or 0,targetPos.z or 0))endendif attempt < maxRetries thenif delay and delay > 0 and _G.sleep thensleep(delay)endendendlocal axisDelta = string.format("(dx=%d, dy=%d, dz=%d)", delta.x or 0, delta.y or 0, delta.z or 0)return false, "unable to move " .. axisDelta .. " after " .. tostring(maxRetries) .. " attempts"endfunction movement.forward(ctx, opts)local state = ensureMovementState(ctx)local facing = state.facing or "north"local delta = copyPosition(DIRECTION_VECTORS[facing])local moveFns = {move = turtle and turtle.forward or nil,detect = turtle and turtle.detect or nil,dig = turtle and turtle.dig or nil,attack = turtle and turtle.attack or nil,inspect = turtle and turtle.inspect or nil,suck = turtle and turtle.suck or nil,}if not moveFns.move thenreturn false, "turtle API unavailable"endreturn moveWithRetries(ctx, opts, moveFns, delta)endfunction movement.up(ctx, opts)local moveFns = {move = turtle and turtle.up or nil,detect = turtle and turtle.detectUp or nil,dig = turtle and turtle.digUp or nil,attack = turtle and turtle.attackUp or nil,inspect = turtle and turtle.inspectUp or nil,suck = turtle and turtle.suckUp or nil,}if not moveFns.move thenreturn false, "turtle API unavailable"endreturn moveWithRetries(ctx, opts, moveFns, { x = 0, y = 1, z = 0 })endfunction movement.down(ctx, opts)local moveFns = {move = turtle and turtle.down or nil,detect = turtle and turtle.detectDown or nil,dig = turtle and turtle.digDown or nil,attack = turtle and turtle.attackDown or nil,inspect = turtle and turtle.inspectDown or nil,suck = turtle and turtle.suckDown or nil,}if not moveFns.move thenreturn false, "turtle API unavailable"endreturn moveWithRetries(ctx, opts, moveFns, { x = 0, y = -1, z = 0 })endlocal function axisFacing(axis, delta)if delta > 0 thenreturn AXIS_FACINGS[axis].positiveelsereturn AXIS_FACINGS[axis].negativeendendlocal function moveAxis(ctx, axis, delta, opts)if delta == 0 thenreturn trueendif axis == "y" thenlocal moveFn = delta > 0 and movement.up or movement.downfor _ = 1, math.abs(delta) dolocal ok, err = moveFn(ctx, opts)if not ok thenreturn false, errendendreturn trueendlocal targetFacing = axisFacing(axis, delta)local ok, err = movement.faceDirection(ctx, targetFacing)if not ok thenreturn false, errendfor step = 1, math.abs(delta) dook, err = movement.forward(ctx, opts)if not ok thenreturn false, string.format("failed moving along %s on step %d: %s", axis, step, err or "unknown")endendreturn trueendfunction movement.goTo(ctx, targetPos, opts)ensureMovementState(ctx)if type(targetPos) ~= "table" thenreturn false, "target position must be a table"endlocal state = ctx.movementlocal axisOrder = (opts and opts.axisOrder) or (ctx.config and ctx.config.movementAxisOrder) or { "x", "z", "y" }for _, axis in ipairs(axisOrder) dolocal desired = targetPos[axis]if desired == nil thenreturn false, "target position missing axis " .. axisendlocal delta = desired - (state.position[axis] or 0)local ok, err = moveAxis(ctx, axis, delta, opts)if not ok thenreturn false, errendendreturn trueendfunction movement.stepPath(ctx, pathNodes, opts)if type(pathNodes) ~= "table" thenreturn false, "pathNodes must be a table"endfor index, node in ipairs(pathNodes) dolocal ok, err = movement.goTo(ctx, node, opts)if not ok thenreturn false, string.format("failed at path node %d: %s", index, err or "unknown")endendreturn trueendfunction movement.returnToOrigin(ctx, opts)ensureMovementState(ctx)if not ctx.origin thenreturn false, "ctx.origin is required"endlocal ok, err = movement.goTo(ctx, ctx.origin, opts)if not ok thenreturn false, errendlocal desiredFacing = (opts and opts.facing) or ctx.movement.homeFacingif desiredFacing thenok, err = movement.faceDirection(ctx, desiredFacing)if not ok thenreturn false, errendendreturn trueendfunction movement.turnLeftOf(facing)facing = world.normaliseFacing(facing)if facing == "north" thenreturn "west"elseif facing == "west" thenreturn "south"elseif facing == "south" thenreturn "east"else -- eastreturn "north"endendfunction movement.turnRightOf(facing)facing = world.normaliseFacing(facing)if facing == "north" thenreturn "east"elseif facing == "east" thenreturn "south"elseif facing == "south" thenreturn "west"else -- westreturn "north"endendfunction movement.turnBackOf(facing)facing = world.normaliseFacing(facing)if facing == "north" thenreturn "south"elseif facing == "south" thenreturn "north"elseif facing == "east" thenreturn "west"else -- westreturn "east"endendfunction movement.describePosition(ctx)local pos = movement.getPosition(ctx)local facing = movement.getFacing(ctx)return string.format("(x=%d, y=%d, z=%d, facing=%s)", pos.x, pos.y, pos.z, tostring(facing))endfunction movement.face(ctx, targetFacing)return movement.faceDirection(ctx, targetFacing)endreturn movement]===]
files['lib/lib_navigation.lua'] = [========[local okMovement, movement = pcall(require, "lib_movement")if not okMovement thenmovement = nilendlocal logger = require("lib_logger")local table_utils = require("lib_table")local world = require("lib_world")local navigation = {}local function isCoordinateSpec(tbl)if type(tbl) ~= "table" thenreturn falseendif tbl.route or tbl.waypoint or tbl.path or tbl.nodes or tbl.sequence or tbl.via or tbl.target or tbl.align thenreturn falseendlocal hasX = tbl.x ~= nil or tbl[1] ~= nillocal hasY = tbl.y ~= nil or tbl[2] ~= nillocal hasZ = tbl.z ~= nil or tbl[3] ~= nilreturn hasX and hasY and hasZendlocal function cloneNodeDefinition(def)if type(def) ~= "table" thenreturn nil, "invalid_route_definition"endlocal result = {}for index, value in ipairs(def) doif type(value) == "table" thenresult[index] = table_utils.copyValue(value)elseresult[index] = valueendendreturn resultendlocal function ensureNavigationState(ctx)if type(ctx) ~= "table" thenerror("navigation library requires a context table", 2)endif type(ctx.navigationState) ~= "table" thenctx.navigationState = ctx.navigation or {}endctx.navigation = ctx.navigationStatelocal state = ctx.navigationStatestate.waypoints = state.waypoints or {}state.routes = state.routes or {}state.restock = state.restock or {}state._configLoaded = state._configLoaded or falseif ctx.origin thenlocal originPos, originErr = world.normalisePosition(ctx.origin)if originPos thenstate.waypoints.origin = originPoselseif originErr thenlogger.log(ctx, "warn", "Origin position invalid: " .. tostring(originErr))endendif not state._configLoaded thenstate._configLoaded = truelocal cfg = ctx.configif type(cfg) == "table" and type(cfg.navigation) == "table" thenlocal navCfg = cfg.navigationif type(navCfg.waypoints) == "table" thenfor name, pos in pairs(navCfg.waypoints) dolocal normalised, err = world.normalisePosition(pos)if normalised thenstate.waypoints[name] = normalisedelselogger.log(ctx, "warn", string.format("Ignoring navigation waypoint '%s': %s", tostring(name), tostring(err)))endendendif type(navCfg.routes) == "table" thenfor name, def in pairs(navCfg.routes) dolocal cloned, err = cloneNodeDefinition(def)if cloned thenstate.routes[name] = clonedelselogger.log(ctx, "warn", string.format("Ignoring navigation route '%s': %s", tostring(name), tostring(err)))endendendif type(navCfg.restock) == "table" thenstate.restock = table_utils.copyValue(navCfg.restock)endendendreturn stateendlocal function resolveWaypoint(ctx, name)local state = ensureNavigationState(ctx)if type(name) ~= "string" or name == "" thenreturn nil, "invalid_waypoint"endlocal pos = state.waypoints[name]if not pos thenreturn nil, "unknown_waypoint"endreturn { x = pos.x, y = pos.y, z = pos.z }endlocal expandSpeclocal function expandListToNodes(ctx, list, visited)if type(list) ~= "table" thenreturn nil, "invalid_path_list"endlocal nodes = {}local meta = {}for index, entry in ipairs(list) dolocal entryNodes, entryMeta = expandSpec(ctx, entry, visited)if not entryNodes thenreturn nil, string.format("path[%d]: %s", index, tostring(entryMeta or "invalid"))endfor _, node in ipairs(entryNodes) donodes[#nodes + 1] = nodeendif entryMeta and entryMeta.finalFacing and not meta.finalFacing thenmeta.finalFacing = entryMeta.finalFacingendendreturn nodes, metaendlocal function expandRouteByName(ctx, name, visited)if type(name) ~= "string" or name == "" thenreturn nil, "invalid_route_name"endlocal state = ensureNavigationState(ctx)local def = state.routes[name]if not def thenreturn nil, "unknown_route"endvisited = visited or {}if visited[name] thenreturn nil, "route_cycle"endvisited[name] = truelocal nodes, meta = expandListToNodes(ctx, def, visited)visited[name] = nilreturn nodes, metaend-- Expands a navigation spec (string, waypoint, route, or nested table) into absolute coordinates.function expandSpec(ctx, spec, visited)local specType = type(spec)if specType == "string" thenlocal routeNodes, routeMeta = expandRouteByName(ctx, spec, visited)if routeNodes thenreturn routeNodes, routeMetaendif routeMeta ~= "unknown_route" thenreturn nil, routeMetaendlocal pos, err = resolveWaypoint(ctx, spec)if not pos thenreturn nil, err or "unknown_reference"endreturn { pos }, {}elseif specType == "function" thenlocal ok, result = pcall(spec, ctx)if not ok thenreturn nil, "navigation_callback_failed"endif result == nil thenreturn {}, {}endreturn expandSpec(ctx, result, visited)elseif specType ~= "table" thenreturn nil, "invalid_navigation_spec"endif isCoordinateSpec(spec) thenlocal pos, err = world.normalisePosition(spec)if not pos thenreturn nil, errendlocal meta = {}if spec.finalFacing or spec.facing thenmeta.finalFacing = spec.finalFacing or spec.facingendreturn { pos }, metaendlocal nodes = {}local meta = {}local facing = spec.finalFacing or spec.facingif facing thenmeta.finalFacing = facingendif spec.sequence thenlocal seqNodes, seqMeta = expandListToNodes(ctx, spec.sequence, visited)if not seqNodes thenreturn nil, seqMetaendfor _, node in ipairs(seqNodes) donodes[#nodes + 1] = nodeendif seqMeta.finalFacing and not meta.finalFacing thenmeta.finalFacing = seqMeta.finalFacingendendif spec.via thenlocal viaNodes, viaMeta = expandListToNodes(ctx, spec.via, visited)if not viaNodes thenreturn nil, viaMetaendfor _, node in ipairs(viaNodes) donodes[#nodes + 1] = nodeendif viaMeta.finalFacing and not meta.finalFacing thenmeta.finalFacing = viaMeta.finalFacingendendif spec.path thenlocal pathNodes, pathMeta = expandListToNodes(ctx, spec.path, visited)if not pathNodes thenreturn nil, pathMetaendfor _, node in ipairs(pathNodes) donodes[#nodes + 1] = nodeendif pathMeta.finalFacing and not meta.finalFacing thenmeta.finalFacing = pathMeta.finalFacingendelseif spec.nodes thenlocal pathNodes, pathMeta = expandListToNodes(ctx, spec.nodes, visited)if not pathNodes thenreturn nil, pathMetaendfor _, node in ipairs(pathNodes) donodes[#nodes + 1] = nodeendif pathMeta.finalFacing and not meta.finalFacing thenmeta.finalFacing = pathMeta.finalFacingendendif spec.route thenif type(spec.route) == "table" thenlocal routeNodes, routeMeta = expandListToNodes(ctx, spec.route, visited)if not routeNodes thenreturn nil, routeMetaendfor _, node in ipairs(routeNodes) donodes[#nodes + 1] = nodeendif routeMeta.finalFacing and not meta.finalFacing thenmeta.finalFacing = routeMeta.finalFacingendelselocal routeNodes, routeMeta = expandRouteByName(ctx, spec.route, visited)if not routeNodes thenreturn nil, routeMetaendfor _, node in ipairs(routeNodes) donodes[#nodes + 1] = nodeendif routeMeta and routeMeta.finalFacing and not meta.finalFacing thenmeta.finalFacing = routeMeta.finalFacingendendendif spec.waypoint thenlocal pos, err = resolveWaypoint(ctx, spec.waypoint)if not pos thenreturn nil, errendnodes[#nodes + 1] = posendif spec.position thenlocal pos, err = world.normalisePosition(spec.position)if not pos thenreturn nil, errendnodes[#nodes + 1] = posendif spec.target thenlocal targetNodes, targetMeta = expandSpec(ctx, spec.target, visited)if not targetNodes thenreturn nil, targetMetaendfor _, node in ipairs(targetNodes) donodes[#nodes + 1] = nodeendif targetMeta.finalFacing and not meta.finalFacing thenmeta.finalFacing = targetMeta.finalFacingendendif spec.align thenlocal alignNodes, alignMeta = expandSpec(ctx, spec.align, visited)if not alignNodes thenreturn nil, alignMetaendfor _, node in ipairs(alignNodes) donodes[#nodes + 1] = nodeendif alignMeta.finalFacing thenmeta.finalFacing = alignMeta.finalFacingendendreturn nodes, metaendfunction navigation.ensureState(ctx)return ensureNavigationState(ctx)endfunction navigation.registerWaypoint(ctx, name, position)if type(name) ~= "string" or name == "" thenreturn false, "invalid_waypoint_name"endlocal state = ensureNavigationState(ctx)local pos, err = world.normalisePosition(position)if not pos thenreturn false, err or "invalid_position"endstate.waypoints[name] = posreturn trueendfunction navigation.getWaypoint(ctx, name)return resolveWaypoint(ctx, name)endfunction navigation.listWaypoints(ctx)local state = ensureNavigationState(ctx)local result = {}for name, pos in pairs(state.waypoints) doresult[name] = { x = pos.x, y = pos.y, z = pos.z }endreturn resultendfunction navigation.registerRoute(ctx, name, nodes)if type(name) ~= "string" or name == "" thenreturn false, "invalid_route_name"endlocal state = ensureNavigationState(ctx)local cloned, err = cloneNodeDefinition(nodes)if not cloned thenreturn false, err or "invalid_route"endstate.routes[name] = clonedreturn trueendfunction navigation.getRoute(ctx, name)local nodes, meta = expandRouteByName(ctx, name, {})if not nodes thenreturn nil, metaendreturn nodes, metaendfunction navigation.plan(ctx, targetSpec, opts)ensureNavigationState(ctx)if targetSpec == nil thenreturn nil, "missing_target"endlocal nodes, meta = expandSpec(ctx, targetSpec, {})if not nodes thenreturn nil, metaendif opts and opts.includeCurrent == false and #nodes > 0 then-- no-op placeholder for future optionsendreturn nodes, metaendlocal function resolveRestockSpec(ctx, kind)local state = ensureNavigationState(ctx)local restock = state.restocklocal specif type(restock) == "table" thenif kind and restock[kind] ~= nil thenspec = restock[kind]elseif restock.default ~= nil thenspec = restock.defaultelseif restock.fallback ~= nil thenspec = restock.fallbackendendif spec == nil and state.waypoints.restock thenspec = state.waypoints.restockendif spec == nil and state.waypoints.origin thenspec = state.waypoints.originendif spec == nil thenreturn nilendreturn table_utils.copyValue(spec)endfunction navigation.getRestockTarget(ctx, kind)local spec = resolveRestockSpec(ctx, kind)if spec == nil thenreturn nil, "restock_target_missing"endreturn specendfunction navigation.setRestockTarget(ctx, kind, spec)local state = ensureNavigationState(ctx)if type(kind) ~= "string" or kind == "" thenkind = "default"endif spec == nil thenstate.restock[kind] = nilreturn trueendlocal specType = type(spec)if specType ~= "string" and specType ~= "table" and specType ~= "function" thenreturn false, "invalid_restock_spec"endstate.restock[kind] = table_utils.copyValue(spec)return trueendfunction navigation.planRestock(ctx, opts)local kind = nilif type(opts) == "table" thenkind = opts.kind or opts.type or opts.categoryendlocal spec = resolveRestockSpec(ctx, kind)if spec == nil thenreturn nil, "restock_target_missing"endlocal nodes, meta = navigation.plan(ctx, spec, opts)if not nodes thenreturn nil, metaendreturn nodes, metaendfunction navigation.travel(ctx, targetSpec, opts)ensureNavigationState(ctx)if not movement thenreturn false, "movement_library_unavailable"endlocal nodes, meta = navigation.plan(ctx, targetSpec, opts)if not nodes thenreturn false, metaendmovement.ensureState(ctx)if #nodes > 0 thenlocal moveOpts = opts and opts.movelocal ok, err = movement.stepPath(ctx, nodes, moveOpts)if not ok thenreturn false, errendendlocal finalFacing = (opts and opts.finalFacing) or (meta and meta.finalFacing)if finalFacing thenlocal ok, err = movement.faceDirection(ctx, finalFacing)if not ok thenreturn false, errendendreturn trueendfunction navigation.travelToRestock(ctx, opts)local kind = nilif type(opts) == "table" thenkind = opts.kind or opts.type or opts.categoryendlocal spec, err = navigation.getRestockTarget(ctx, kind)if not spec thenreturn false, errendreturn navigation.travel(ctx, spec, opts)endreturn navigation]========]
files['lib/lib_network.lua'] = [=========[local network = {}local PROTOCOL = "ARCADESYS_FACTORY"local PING_MESSAGE = "PING"local PONG_MESSAGE = "PONG"local SEND_SCHEMA_MESSAGE = "SEND_SCHEMA"function network.openModem()local modem = peripheral.find("modem", function(name, wrapped)return wrapped.isWireless()end)if modem thenrednet.open(peripheral.getName(modem))return trueendreturn falseendfunction network.closeModem()local modem = peripheral.find("modem", function(name, wrapped)return wrapped.isWireless()end)if modem thenrednet.close(peripheral.getName(modem))endendfunction network.broadcastPresence(label)if not rednet.isOpen() then return endrednet.broadcast({type = PONG_MESSAGE,id = os.getComputerID(),label = label or os.getComputerLabel() or "Turtle " .. os.getComputerID()}, PROTOCOL)endfunction network.findDevices(timeout)if not rednet.isOpen() then return {} endrednet.broadcast({ type = PING_MESSAGE }, PROTOCOL)local devices = {}local timer = os.startTimer(timeout or 2)while true dolocal event, senderId, message, protocol = os.pullEvent()if event == "timer" and senderId == timer thenbreakelseif event == "rednet_message" and protocol == PROTOCOL thenif type(message) == "table" and message.type == PONG_MESSAGE thentable.insert(devices, {id = senderId,label = message.label})endendendreturn devicesendfunction network.sendSchema(targetId, filename, content)if not rednet.isOpen() then return false endrednet.send(targetId, {type = SEND_SCHEMA_MESSAGE,filename = filename,content = content}, PROTOCOL)return trueendfunction network.listen(callback)if not rednet.isOpen() then return endwhile true dolocal senderId, message, protocol = rednet.receive(PROTOCOL)if type(message) == "table" thenif message.type == PING_MESSAGE thennetwork.broadcastPresence()elseif message.type == SEND_SCHEMA_MESSAGE thenif callback thencallback(senderId, message.filename, message.content)endendendendendreturn network]=========]
files['lib/lib_orientation.lua'] = [====[---@diagnostic disable: undefined-global

local movement = require("lib_movement")
local world = require("lib_world")
local gps_utils = require("lib_gps")

local orientation = {}

local START_ORIENTATIONS = {
    [1] = { label = "Forward + Left", key = "forward_left" },
    [2] = { label = "Forward + Right", key = "forward_right" },
}
local DEFAULT_ORIENTATION = 1

function orientation.resolveOrientationKey(raw)
    if type(raw) == "string" then
        local key = raw:lower()
        if key == "forward_left" or key == "forward-left" or key == "left" or key == "l" then
            return "forward_left"
        elseif key == "forward_right" or key == "forward-right" or key == "right" or key == "r" then
            return "forward_right"
        end
    elseif type(raw) == "number" and START_ORIENTATIONS[raw] then
        return START_ORIENTATIONS[raw].key
    end
    return START_ORIENTATIONS[DEFAULT_ORIENTATION].key
end

function orientation.orientationLabel(key)
    local resolved = orientation.resolveOrientationKey(key)
    for _, entry in pairs(START_ORIENTATIONS) do
        if entry.key == resolved then
            return entry.label
        end
    end
    return START_ORIENTATIONS[DEFAULT_ORIENTATION].label
end

function orientation.normaliseFacing(facing)
    return world.normaliseFacing(facing)
end

function orientation.facingVectors(facing)
    return world.facingVectors(facing)
end

function orientation.rotateLocalOffset(localOffset, facing)
    return world.rotateLocalOffset(localOffset, facing)
end

function orientation.localToWorld(localOffset, facing)
    return world.localToWorld(localOffset, facing)
end

function orientation.detectFacingWithGps(logger)
    return gps_utils.detectFacingWithGps(logger)
end

function orientation.turnLeftOf(facing)
    return movement.turnLeftOf(facing)
end

function orientation.turnRightOf(facing)
    return movement.turnRightOf(facing)
end

function orientation.turnBackOf(facing)
    return movement.turnBackOf(facing)
end

return orientation]====]
files['lib/lib_parser.lua'] = [=======[---@diagnostic disable: undefined-globallocal parser = {}local logger = require("lib_logger")local table_utils = require("lib_table")local fs_utils = require("lib_fs")local json_utils = require("lib_json")local schema_utils = require("lib_schema")local function parseLayerRows(schema, bounds, counts, layerDef, legend, opts)local rows = layerDef.rowsif type(rows) ~= "table" thenreturn false, "invalid_layer"endlocal height = #rowsif height == 0 thenreturn trueendlocal width = nilfor rowIndex, row in ipairs(rows) doif type(row) ~= "string" thenreturn false, "invalid_row"endif width == nil thenwidth = #rowif width == 0 thenreturn false, "empty_row"endelseif width ~= #row thenreturn false, "ragged_row"endfor col = 1, #row dolocal symbol = row:sub(col, col)local entry, err = schema_utils.resolveSymbol(symbol, legend, opts)if err thenreturn false, string.format("legend_error:%s", symbol)endif entry thenlocal x = (layerDef.x or 0) + (col - 1)local y = layerDef.y or 0local z = (layerDef.z or 0) + (rowIndex - 1)local ok, addErr = schema_utils.addBlock(schema, bounds, counts, x, y, z, entry.material, entry.meta)if not ok thenreturn false, addErrendendendendreturn trueendlocal function toLayerRows(layer)if type(layer) == "string" thenlocal rows = {}for line in layer:gmatch("([^\r\n]+)") dorows[#rows + 1] = lineendreturn { rows = rows }endif type(layer) == "table" thenif layer.rows thenlocal rows = {}for i = 1, #layer.rows dorows[i] = tostring(layer.rows[i])endreturn {rows = rows,y = layer.y or layer.height or layer.level or 0,x = layer.x or layer.offsetX or 0,z = layer.z or layer.offsetZ or 0,}endlocal rows = {}local count = 0for _, value in ipairs(layer) dorows[#rows + 1] = tostring(value)count = count + 1endif count > 0 thenreturn { rows = rows, y = layer.y or 0, x = layer.x or 0, z = layer.z or 0 }endendreturn nilendlocal function parseLayers(schema, bounds, counts, def, legend, opts)local layers = def.layersif type(layers) ~= "table" thenreturn false, "invalid_layers"endlocal used = 0for index, layer in ipairs(layers) dolocal layerRows = toLayerRows(layer)if not layerRows thenreturn false, "invalid_layer"endif not layerRows.y thenlayerRows.y = (def.baseY or 0) + (index - 1)elselayerRows.y = layerRows.y + (def.baseY or 0)endif def.baseX thenlayerRows.x = (layerRows.x or 0) + def.baseXendif def.baseZ thenlayerRows.z = (layerRows.z or 0) + def.baseZendlocal ok, err = parseLayerRows(schema, bounds, counts, layerRows, legend, opts)if not ok thenreturn false, errendused = used + 1endif used == 0 thenreturn false, "empty_layers"endreturn trueendlocal function parseBlockList(schema, bounds, counts, blocks)local used = 0for _, block in ipairs(blocks) doif type(block) ~= "table" thenreturn false, "invalid_block"endlocal x = block.x or block[1]local y = block.y or block[2]local z = block.z or block[3]local material = block.material or block.name or block.blocklocal meta = block.meta or block.dataif type(meta) ~= "table" thenmeta = {}endlocal ok, err = schema_utils.addBlock(schema, bounds, counts, x, y, z, material, meta)if not ok thenreturn false, errendused = used + 1endif used == 0 thenreturn false, "empty_blocks"endreturn trueendlocal function parseVoxelGrid(schema, bounds, counts, grid)if type(grid) ~= "table" thenreturn false, "invalid_grid"endlocal used = 0for xKey, xColumn in pairs(grid) dolocal x = tonumber(xKey) or xKeyif type(x) ~= "number" thenreturn false, "invalid_coordinate"endif type(xColumn) ~= "table" thenreturn false, "invalid_grid"endfor yKey, yColumn in pairs(xColumn) dolocal y = tonumber(yKey) or yKeyif type(y) ~= "number" thenreturn false, "invalid_coordinate"endif type(yColumn) ~= "table" thenreturn false, "invalid_grid"endfor zKey, entry in pairs(yColumn) dolocal z = tonumber(zKey) or zKeyif type(z) ~= "number" thenreturn false, "invalid_coordinate"endif entry ~= nil thenlocal materiallocal meta = {}if type(entry) == "string" thenmaterial = entryelseif type(entry) == "table" thenmaterial = entry.material or entry.name or entry.blockmeta = type(entry.meta) == "table" and entry.meta or {}elsereturn false, "invalid_block"endif material and material ~= "" thenlocal ok, err = schema_utils.addBlock(schema, bounds, counts, x, y, z, material, meta)if not ok thenreturn false, errendused = used + 1endendendendendif used == 0 thenreturn false, "empty_grid"endreturn trueendlocal function summarise(bounds, counts, meta)local materials = {}for material, count in pairs(counts) domaterials[#materials + 1] = { material = material, count = count }endtable.sort(materials, function(a, b)if a.count == b.count thenreturn a.material < b.materialendreturn a.count > b.countend)local total = 0for _, entry in ipairs(materials) dototal = total + entry.countendreturn {bounds = {min = table_utils.shallowCopy(bounds.min),max = table_utils.shallowCopy(bounds.max),},materials = materials,totalBlocks = total,meta = meta}endlocal function buildCanonical(def, opts)local schema = {}local bounds = schema_utils.newBounds()local counts = {}local ok, errif def.blocks thenok, err = parseBlockList(schema, bounds, counts, def.blocks)elseif def.layers thenok, err = parseLayers(schema, bounds, counts, def, def.legend, opts)elseif def.grid thenok, err = parseVoxelGrid(schema, bounds, counts, def.grid)elsereturn nil, "unknown_definition"endif not ok thenreturn nil, errendif bounds.min.x == math.huge thenreturn nil, "empty_schema"endreturn schema, summarise(bounds, counts, def.meta)endlocal function detectFormatFromExtension(path)if type(path) ~= "string" thenreturn nilendlocal ext = path:match("%.([%w_%-]+)$")if not ext thenreturn nilendext = ext:lower()if ext == "json" or ext == "schem" thenreturn "json"endif ext == "txt" or ext == "grid" thenreturn "grid"endif ext == "vox" or ext == "voxel" thenreturn "voxel"endreturn nilendlocal function detectFormatFromText(text)if type(text) ~= "string" thenreturn nilendlocal trimmed = text:match("^%s*(.-)%s*$") or textlocal firstChar = trimmed:sub(1, 1)if firstChar == "{" or firstChar == "[" thenreturn "json"endreturn "grid"endlocal function parseLegendBlock(lines, index)local legend = {}local pos = indexwhile pos <= #lines dolocal line = lines[pos]if line == "" thenbreakendif line:match("^layer") thenbreakendlocal symbol, rest = line:match("^(%S+)%s*[:=]%s*(.+)$")if not symbol thensymbol, rest = line:match("^(%S+)%s+(.+)$")endif symbol and rest thenrest = rest:gsub("^%s+", ""):gsub("%s+$", "")local valueif rest:sub(1, 1) == "{" thenlocal parsed = json_utils.decodeJson(rest)if parsed thenvalue = parsedelsevalue = restendelsevalue = restendlegend[symbol] = valueendpos = pos + 1endreturn legend, posendlocal function parseTextGridContent(text, opts)local lines = {}for line in (text .. "\n"):gmatch("([^\n]*)\n") doline = line:gsub("\r$", "")lines[#lines + 1] = lineendlocal legend = schema_utils.mergeLegend(opts and opts.legend or nil, nil)local layers = {}local current = {}local currentY = nillocal lineIndex = 1while lineIndex <= #lines dolocal line = lines[lineIndex]local trimmed = line:match("^%s*(.-)%s*$")if trimmed == "" thenif #current > 0 thenlayers[#layers + 1] = { rows = current, y = currentY or (#layers) }current = {}currentY = nilendlineIndex = lineIndex + 1elseif trimmed:lower() == "legend:" thenlocal legendBlock, nextIndex = parseLegendBlock(lines, lineIndex + 1)legend = schema_utils.mergeLegend(legend, legendBlock)lineIndex = nextIndexelseif trimmed:lower() == "meta:" thenlocal metaBlock, nextIndex = parseLegendBlock(lines, lineIndex + 1) -- Reuse parseLegendBlock as format is identicalif not opts then opts = {} endopts.meta = schema_utils.mergeLegend(opts.meta, metaBlock)lineIndex = nextIndexelseif trimmed:match("^layer") thenif #current > 0 thenlayers[#layers + 1] = { rows = current, y = currentY or (#layers) }current = {}endlocal yValue = trimmed:match("layer%s*[:=]%s*(-?%d+)")currentY = yValue and tonumber(yValue) or (#layers)lineIndex = lineIndex + 1elsecurrent[#current + 1] = linelineIndex = lineIndex + 1endendif #current > 0 thenlayers[#layers + 1] = { rows = current, y = currentY or (#layers) }endif not legend or next(legend) == nil thenreturn nil, "missing_legend"endif #layers == 0 thenreturn nil, "empty_layers"endreturn {layers = layers,legend = legend,}endlocal function parseJsonContent(obj, opts)if type(obj) ~= "table" thenreturn nil, "invalid_json_root"endlocal legend = schema_utils.mergeLegend(opts and opts.legend or nil, obj.legend or nil)if obj.blocks thenreturn {blocks = obj.blocks,legend = legend,}endif obj.layers thenreturn {layers = obj.layers,legend = legend,baseX = obj.baseX,baseY = obj.baseY,baseZ = obj.baseZ,}endif obj.grid or obj.voxels thenreturn {grid = obj.grid or obj.voxels,legend = legend,}endif #obj > 0 thenreturn {blocks = obj,legend = legend,}endreturn nil, "unrecognised_json"endlocal function assignToContext(ctx, schema, info)if type(ctx) ~= "table" thenreturnendctx.schema = schemactx.schemaInfo = infoendlocal function ensureSpecTable(spec)if type(spec) == "table" thenreturn table_utils.shallowCopy(spec)endif type(spec) == "string" thenreturn { source = spec }endreturn {}endfunction parser.parse(ctx, spec)spec = ensureSpecTable(spec)local format = spec.formatlocal text = spec.textlocal data = spec.datalocal path = spec.path or spec.sourcePathlocal source = spec.sourceif not format and spec.path thenformat = detectFormatFromExtension(spec.path)endif not format and spec.formatHint thenformat = spec.formatHintendif not text and not data thenif spec.textContent thentext = spec.textContentelseif spec.raw thentext = spec.rawelseif spec.sourceText thentext = spec.sourceTextendendif not path and type(source) == "string" and text == nil and data == nil thenlocal maybeFormat = detectFormatFromExtension(source)if maybeFormat thenpath = sourceformat = format or maybeFormatelsetext = sourceendendif text == nil and path thenlocal contents, err = fs_utils.readFile(path)if not contents thenreturn false, err or "read_failed"endtext = contentsif not format thenformat = detectFormatFromExtension(path) or detectFormatFromText(text)endendif not format thenif data thenif data.layers thenformat = "grid"elseif data.blocks thenformat = "json"elseif data.grid or data.voxels thenformat = "voxel"endelseif text thenformat = detectFormatFromText(text)endendif not format thenreturn false, "unknown_format"endlocal definition, errif format == "json" thenif data thendefinition, err = parseJsonContent(data, spec)elselocal obj, decodeErr = json_utils.decodeJson(text)if not obj thenreturn false, decodeErrenddefinition, err = parseJsonContent(obj, spec)endelseif format == "grid" thenif data and (data.layers or data.rows) thendefinition = {layers = data.layers or { data.rows },legend = schema_utils.mergeLegend(spec.legend or nil, data.legend or nil),meta = spec.meta or data.meta}elsedefinition, err = parseTextGridContent(text, spec)if definition and spec.meta thendefinition.meta = schema_utils.mergeLegend(definition.meta, spec.meta)endendelseif format == "voxel" thenif data thendefinition = {grid = data.grid or data.voxels or data,}elselocal obj, decodeErr = json_utils.decodeJson(text)if not obj thenreturn false, decodeErrendif obj.grid or obj.voxels thendefinition = {grid = obj.grid or obj.voxels,}elsedefinition, err = parseJsonContent(obj, spec)endendelsereturn false, "unsupported_format"endif not definition thenreturn false, err or "invalid_definition"endif spec.legend thendefinition.legend = schema_utils.mergeLegend(definition.legend, spec.legend)endlocal schema, metadata = buildCanonical(definition, spec)if not schema thenreturn false, metadata or "parse_failed"endif type(metadata) ~= "table" thenmetadata = { note = metadata }endmetadata = metadata or {}metadata.format = formatmetadata.path = pathassignToContext(ctx, schema, metadata)logger.log(ctx, "debug", string.format("Parsed schema with %d blocks", metadata.totalBlocks or 0))return true, schema, metadataendfunction parser.parseFile(ctx, path, opts)opts = opts or {}opts.path = pathreturn parser.parse(ctx, opts)endfunction parser.parseText(ctx, text, opts)opts = opts or {}opts.text = textopts.format = opts.format or "grid"return parser.parse(ctx, opts)endfunction parser.parseJson(ctx, data, opts)opts = opts or {}opts.data = dataopts.format = "json"return parser.parse(ctx, opts)endreturn parser]=======]
files['lib/lib_placement.lua'] = [===[---@diagnostic disable: undefined-globallocal placement = {}local logger = require("lib_logger")local world = require("lib_world")local fuel = require("lib_fuel")local schema_utils = require("lib_schema")local strategy_utils = require("lib_strategy")local SIDE_APIS = {forward = {place = turtle and turtle.place or nil,detect = turtle and turtle.detect or nil,inspect = turtle and turtle.inspect or nil,dig = turtle and turtle.dig or nil,attack = turtle and turtle.attack or nil,},up = {place = turtle and turtle.placeUp or nil,detect = turtle and turtle.detectUp or nil,inspect = turtle and turtle.inspectUp or nil,dig = turtle and turtle.digUp or nil,attack = turtle and turtle.attackUp or nil,},down = {place = turtle and turtle.placeDown or nil,detect = turtle and turtle.detectDown or nil,inspect = turtle and turtle.inspectDown or nil,dig = turtle and turtle.digDown or nil,attack = turtle and turtle.attackDown or nil,},}local function ensurePlacementState(ctx)if type(ctx) ~= "table" thenerror("placement library requires a context table", 2)endctx.placement = ctx.placement or {}local state = ctx.placementstate.cachedSlots = state.cachedSlots or {}return stateendlocal function selectMaterialSlot(ctx, material)local state = ensurePlacementState(ctx)if not turtle or not turtle.getItemDetail or not turtle.select thenreturn nil, "turtle API unavailable"endif type(material) ~= "string" or material == "" thenreturn nil, "invalid_material"endlocal cached = state.cachedSlots[material]if cached thenlocal detail = turtle.getItemDetail(cached)local count = detail and detail.countif (not count or count <= 0) and turtle.getItemCount thencount = turtle.getItemCount(cached)endif detail and detail.name == material and count and count > 0 thenif turtle.select(cached) thenstate.lastSlot = cachedreturn cachedendstate.cachedSlots[material] = nilelsestate.cachedSlots[material] = nilendendfor slot = 1, 16 dolocal detail = turtle.getItemDetail(slot)local count = detail and detail.countif (not count or count <= 0) and turtle.getItemCount thencount = turtle.getItemCount(slot)endif detail and detail.name == material and count and count > 0 thenif turtle.select(slot) thenstate.cachedSlots[material] = slotstate.lastSlot = slotreturn slotendendendreturn nil, "missing_material"endlocal function resolveSide(ctx, block, opts)if type(opts) == "table" and opts.side thenreturn opts.sideendif type(block) == "table" and type(block.meta) == "table" and block.meta.side thenreturn block.meta.sideendif type(ctx.config) == "table" and ctx.config.defaultPlacementSide thenreturn ctx.config.defaultPlacementSideendreturn "forward"endlocal function resolveOverwrite(ctx, block, opts)if type(opts) == "table" and opts.overwrite ~= nil thenreturn opts.overwriteendif type(block) == "table" and type(block.meta) == "table" and block.meta.overwrite ~= nil thenreturn block.meta.overwriteendif type(ctx.config) == "table" and ctx.config.allowOverwrite ~= nil thenreturn ctx.config.allowOverwriteendreturn falseendlocal function detectBlock(sideFns)if type(sideFns.inspect) == "function" thenlocal hasBlock, data = sideFns.inspect()if hasBlock thenreturn true, dataendreturn false, nilendif type(sideFns.detect) == "function" thenlocal exists = sideFns.detect()if exists thenreturn true, nilendendreturn false, nilendlocal function clearBlockingBlock(sideFns, allowDig, allowAttack)if not allowDig and not allowAttack thenreturn falseendlocal attempts = 0local maxAttempts = 4while attempts < maxAttempts doattempts = attempts + 1local cleared = falseif allowDig and type(sideFns.dig) == "function" thencleared = sideFns.dig() or clearedendif not cleared and allowAttack and type(sideFns.attack) == "function" thencleared = sideFns.attack() or clearedendif cleared thenif type(sideFns.detect) ~= "function" or not sideFns.detect() thenreturn trueendendif sleep and attempts < maxAttempts thensleep(0)endendreturn falseendfunction placement.placeMaterial(ctx, material, opts)local state = ensurePlacementState(ctx)if not turtle thenreturn false, "turtle API unavailable"endif material == nil or material == "" or material == "minecraft:air" or material == "air" thenstate.lastPlacement = { skipped = true, reason = "air", material = material }return trueendlocal side = resolveSide(ctx, opts and opts.block or nil, opts)local sideFns = SIDE_APIS[side]if not sideFns or type(sideFns.place) ~= "function" thenreturn false, "invalid_side"endlocal slot, slotErr = selectMaterialSlot(ctx, material)if not slot thenstate.lastPlacement = { success = false, material = material, error = slotErr }return false, slotErrendlocal allowDig = opts and opts.digif allowDig == nil thenallowDig = trueendlocal allowAttack = opts and opts.attackif allowAttack == nil thenallowAttack = trueendlocal allowOverwrite = resolveOverwrite(ctx, opts and opts.block or nil, opts)local blockPresent, blockData = detectBlock(sideFns)local blockingName = blockData and blockData.name or nilif blockPresent thenif blockData and blockData.name == material thenstate.lastPlacement = { success = true, material = material, reused = true, side = side, blocking = blockingName }return true, "already_present"endlocal needsReplacement = not (blockData and blockData.name == material)local canForce = allowOverwrite or needsReplacementif not canForce thenstate.lastPlacement = { success = false, material = material, error = "occupied", side = side, blocking = blockingName }return false, "occupied"endlocal cleared = clearBlockingBlock(sideFns, allowDig, allowAttack)if not cleared thenlocal reason = needsReplacement and "mismatched_block" or "blocked"state.lastPlacement = { success = false, material = material, error = reason, side = side, blocking = blockingName }return false, reasonendendif not turtle.select(slot) thenstate.cachedSlots[material] = nilstate.lastPlacement = { success = false, material = material, error = "select_failed", side = side, slot = slot }return false, "select_failed"endlocal placed, placeErr = sideFns.place()if not placed thenif placeErr thenlogger.log(ctx, "debug", string.format("Place failed for %s: %s", material, placeErr))endlocal stillBlocked = type(sideFns.detect) == "function" and sideFns.detect()local slotCountif turtle.getItemCount thenslotCount = turtle.getItemCount(slot)elseif turtle.getItemDetail thenlocal detail = turtle.getItemDetail(slot)slotCount = detail and detail.count or nilendlocal lowerErr = type(placeErr) == "string" and placeErr:lower() or nilif slotCount ~= nil and slotCount <= 0 thenstate.cachedSlots[material] = nilstate.lastPlacement = { success = false, material = material, error = "missing_material", side = side, slot = slot, message = placeErr }return false, "missing_material"endif lowerErr thenif lowerErr:find("no items") or lowerErr:find("no block") or lowerErr:find("missing item") thenstate.cachedSlots[material] = nilstate.lastPlacement = { success = false, material = material, error = "missing_material", side = side, slot = slot, message = placeErr }return false, "missing_material"endif lowerErr:find("protect") or lowerErr:find("denied") or lowerErr:find("cannot place") or lowerErr:find("can't place") or lowerErr:find("occupied") thenstate.lastPlacement = { success = false, material = material, error = "blocked", side = side, slot = slot, message = placeErr }return false, "blocked"endendif stillBlocked thenstate.lastPlacement = { success = false, material = material, error = "blocked", side = side, slot = slot, message = placeErr }return false, "blocked"endstate.lastPlacement = { success = false, material = material, error = "placement_failed", side = side, slot = slot, message = placeErr }return false, "placement_failed"endstate.lastPlacement = {success = true,material = material,side = side,slot = slot,timestamp = os and os.time and os.time() or nil,}return trueendfunction placement.advancePointer(ctx)return strategy_utils.advancePointer(ctx)endfunction placement.ensureState(ctx)return ensurePlacementState(ctx)endfunction placement.executeBuildState(ctx, opts)opts = opts or {}local state = ensurePlacementState(ctx)local pointer, pointerErr = strategy_utils.ensurePointer(ctx)if not pointer thenlogger.log(ctx, "debug", "No build pointer available: " .. tostring(pointerErr))return "DONE", { reason = pointerErr or "no_pointer" }endif fuel.isFuelLow(ctx) thenstate.resumeState = "BUILD"logger.log(ctx, "info", "Fuel below threshold, switching to REFUEL")return "REFUEL", { reason = "fuel_low", pointer = world.copyPosition(pointer) }endlocal block, schemaErr = schema_utils.fetchSchemaEntry(ctx.schema, pointer)if not block thenlogger.log(ctx, "debug", string.format("No schema entry at x=%d y=%d z=%d (%s)", pointer.x or 0, pointer.y or 0, pointer.z or 0, tostring(schemaErr)))local autoAdvance = opts.autoAdvanceif autoAdvance == nil thenautoAdvance = trueendif autoAdvance thenlocal advanced = placement.advancePointer(ctx)if advanced thenreturn "BUILD", { reason = "skip_empty", pointer = world.copyPosition(ctx.pointer) }endendreturn "DONE", { reason = "schema_exhausted" }endif block.material == nil or block.material == "minecraft:air" or block.material == "air" thenlocal autoAdvance = opts.autoAdvanceif autoAdvance == nil thenautoAdvance = trueendif autoAdvance thenlocal advanced = placement.advancePointer(ctx)if advanced thenreturn "BUILD", { reason = "skip_air", pointer = world.copyPosition(ctx.pointer) }endendreturn "DONE", { reason = "no_material" }endlocal side = resolveSide(ctx, block, opts)local overwrite = resolveOverwrite(ctx, block, opts)local allowDig = opts.diglocal allowAttack = opts.attackif allowDig == nil and block.meta and block.meta.dig ~= nil thenallowDig = block.meta.digendif allowAttack == nil and block.meta and block.meta.attack ~= nil thenallowAttack = block.meta.attackendlocal placementOpts = {side = side,overwrite = overwrite,dig = allowDig,attack = allowAttack,block = block,}local ok, err = placement.placeMaterial(ctx, block.material, placementOpts)if not ok thenif err == "missing_material" thenstate.resumeState = "BUILD"state.pendingMaterial = block.materiallogger.log(ctx, "warn", string.format("Need to restock %s", block.material))return "RESTOCK", {reason = err,material = block.material,pointer = world.copyPosition(pointer),}endif err == "blocked" thenstate.resumeState = "BUILD"logger.log(ctx, "warn", "Placement blocked; invoking BLOCKED state")return "BLOCKED", {reason = err,pointer = world.copyPosition(pointer),material = block.material,}endif err == "turtle API unavailable" thenstate.lastError = errreturn "ERROR", { reason = err }endstate.lastError = errlogger.log(ctx, "error", string.format("Placement failed for %s: %s", block.material, tostring(err)))return "ERROR", {reason = err,material = block.material,pointer = world.copyPosition(pointer),}endstate.lastPlaced = {material = block.material,pointer = world.copyPosition(pointer),side = side,meta = block.meta,timestamp = os and os.time and os.time() or nil,}local autoAdvance = opts.autoAdvanceif autoAdvance == nil thenautoAdvance = trueendif autoAdvance thenlocal advanced = placement.advancePointer(ctx)if advanced thenreturn "BUILD", { reason = "continue", pointer = world.copyPosition(ctx.pointer) }endreturn "DONE", { reason = "complete" }endreturn "BUILD", { reason = "await_pointer_update" }endreturn placement]===]
files['lib/lib_persistence.lua'] = [=======[local json = require("lib_json")local logger = require("lib_logger")local persistence = {}local STATE_FILE = "state.json"---@class PersistenceConfig---@field path string|nil Path to the state file (default: "state.json")---Load state from disk.---@param ctx table Context table for logging---@param config PersistenceConfig|nil Configuration options---@return table|nil state The loaded state table, or nil if not found/errorfunction persistence.load(ctx, config)local path = (config and config.path) or STATE_FILEif not fs.exists(path) thenlogger.log(ctx, "info", "No previous state found at " .. path)return nilendlocal f = fs.open(path, "r")if not f thenlogger.log(ctx, "error", "Failed to open state file for reading: " .. path)return nilendlocal content = f.readAll()f.close()if not content or content == "" thenlogger.log(ctx, "warn", "State file was empty")return nilendlocal state = json.decode(content)if not state thenlogger.log(ctx, "error", "Failed to decode state JSON")return nilendlogger.log(ctx, "info", "State loaded from " .. path)return stateend---Save state to disk.---@param ctx table Context table containing the state to save---@param config PersistenceConfig|nil Configuration options---@return boolean successfunction persistence.save(ctx, config)local path = (config and config.path) or STATE_FILE-- Construct a serializable snapshot of the context-- We don't want to save everything (like functions or the logger itself)local snapshot = {state = ctx.state,config = ctx.config,origin = ctx.origin,movement = ctx.movement, -- Contains position and facingchests = ctx.chests,     -- Save chest locations-- Save specific state data if it existspotatofarm = ctx.potatofarm,treefarm = ctx.treefarm,mine = ctx.mine,-- Add other state-specific tables here as needed}local content = json.encode(snapshot)if not content thenlogger.log(ctx, "error", "Failed to encode state to JSON")return falseendlocal f = fs.open(path, "w")if not f thenlogger.log(ctx, "error", "Failed to open state file for writing: " .. path)return falseendf.write(content)f.close()return trueend---Clear the saved state file.---@param ctx table Context table---@param config PersistenceConfig|nilfunction persistence.clear(ctx, config)local path = (config and config.path) or STATE_FILEif fs.exists(path) thenfs.delete(path)logger.log(ctx, "info", "Cleared state file: " .. path)endendreturn persistence]=======]
files['lib/lib_reporter.lua'] = [===[local reporter = {}
local initialize = require("lib_initialize")
local movement = require("lib_movement")
local fuel = require("lib_fuel")
local inventory = require("lib_inventory")
local world = require("lib_world")
local schema_utils = require("lib_schema")
local string_utils = require("lib_string")

function reporter.describeFuel(io, report)
    fuel.describeFuel(io, report)
end

function reporter.describeService(io, report)
    fuel.describeService(io, report)
end

function reporter.describeMaterials(io, info)
    inventory.describeMaterials(io, info)
end

function reporter.detectContainers(io)
    world.detectContainers(io)
end

function reporter.runCheck(ctx, io, opts)
    inventory.runCheck(ctx, io, opts)
end

function reporter.gatherSummary(io, report)
    inventory.gatherSummary(io, report)
end

function reporter.describeTotals(io, totals)
    inventory.describeTotals(io, totals)
end

function reporter.showHistory(io, entries)
    if not io.print then
        return
    end
    if not entries or #entries == 0 then
        io.print("Captured history: <empty>")
        return
    end
    io.print("Captured history:")
    for _, entry in ipairs(entries) do
        local label = entry.levelLabel or entry.level
        local stamp = entry.timestamp and (entry.timestamp .. " ") or ""
        local tag = entry.tag and (entry.tag .. " ") or ""
        io.print(string.format(" - %s%s%s%s", stamp, tag, label, entry.message and (" " .. entry.message) or ""))
    end
end

function reporter.describePosition(ctx)
    return movement.describePosition(ctx)
end

function reporter.printMaterials(io, info)
    schema_utils.printMaterials(io, info)
end

function reporter.printBounds(io, info)
    schema_utils.printBounds(io, info)
end

function reporter.detailToString(value, depth)
    return string_utils.detailToString(value, depth)
end

function reporter.computeManifest(list)
    return inventory.computeManifest(list)
end

function reporter.printManifest(io, manifest)
    inventory.printManifest(io, manifest)
end

return reporter]===]
files['lib/lib_schema.lua'] = [===[---@diagnostic disable: undefined-globallocal schema_utils = {}local table_utils = require("lib_table")local function copyTable(tbl)if type(tbl) ~= "table" then return {} endreturn table_utils.shallowCopy(tbl)endfunction schema_utils.pushMaterialCount(counts, material)counts[material] = (counts[material] or 0) + 1endfunction schema_utils.cloneMeta(meta)return copyTable(meta)endfunction schema_utils.newBounds()return {min = { x = math.huge, y = math.huge, z = math.huge },max = { x = -math.huge, y = -math.huge, z = -math.huge },}endfunction schema_utils.updateBounds(bounds, x, y, z)local minB = bounds.minlocal maxB = bounds.maxif x < minB.x then minB.x = x endif y < minB.y then minB.y = y endif z < minB.z then minB.z = z endif x > maxB.x then maxB.x = x endif y > maxB.y then maxB.y = y endif z > maxB.z then maxB.z = z endendfunction schema_utils.addBlock(schema, bounds, counts, x, y, z, material, meta)if type(x) ~= "number" or type(y) ~= "number" or type(z) ~= "number" thenreturn false, "invalid_coordinate"endif type(material) ~= "string" or material == "" thenreturn false, "invalid_material"endmeta = schema_utils.cloneMeta(meta)schema[x] = schema[x] or {}local yLayer = schema[x]yLayer[y] = yLayer[y] or {}local zLayer = yLayer[y]if zLayer[z] ~= nil thenreturn false, "duplicate_coordinate"endzLayer[z] = { material = material, meta = meta }schema_utils.updateBounds(bounds, x, y, z)schema_utils.pushMaterialCount(counts, material)return trueendfunction schema_utils.mergeLegend(base, override)local result = {}if type(base) == "table" thenfor symbol, entry in pairs(base) doresult[symbol] = entryendendif type(override) == "table" thenfor symbol, entry in pairs(override) doresult[symbol] = entryendendreturn resultendfunction schema_utils.normaliseLegendEntry(symbol, entry)if entry == nil thenreturn nil, "unknown_symbol"endif entry == false or entry == "" thenreturn falseendif type(entry) == "string" thenreturn { material = entry, meta = {} }endif type(entry) == "table" thenif entry.material == nil and entry[1] thenentry = { material = entry[1], meta = entry[2] }endlocal material = entry.materialif material == nil or material == "" thenreturn falseendlocal meta = entry.metaif meta ~= nil and type(meta) ~= "table" thenreturn nil, "invalid_meta"endreturn { material = material, meta = meta or {} }endreturn nil, "invalid_legend_entry"endfunction schema_utils.resolveSymbol(symbol, legend, opts)if symbol == "" thenreturn nil, "empty_symbol"endif legend == nil thenreturn nil, "missing_legend"endlocal entry = legend[symbol]if entry == nil thenif symbol == "." or symbol == " " thenreturn falseendif opts and opts.allowImplicitAir and symbol:match("^%p?$") thenreturn falseendreturn nil, "unknown_symbol"endlocal normalised, err = schema_utils.normaliseLegendEntry(symbol, entry)if err thenreturn nil, errendreturn normalisedendfunction schema_utils.fetchSchemaEntry(schema, pos)if type(schema) ~= "table" or type(pos) ~= "table" thenreturn nil, "missing_schema"endlocal xLayer = schema[pos.x] or schema[tostring(pos.x)]if type(xLayer) ~= "table" thenreturn nil, "empty"endlocal yLayer = xLayer[pos.y] or xLayer[tostring(pos.y)]if type(yLayer) ~= "table" thenreturn nil, "empty"endlocal block = yLayer[pos.z] or yLayer[tostring(pos.z)]if block == nil thenreturn nil, "empty"endreturn blockendfunction schema_utils.canonicalToGrid(schema, opts)opts = opts or {}local grid = {}if type(schema) ~= "table" thenreturn gridendfor x, xColumn in pairs(schema) doif type(xColumn) == "table" thenfor y, yColumn in pairs(xColumn) doif type(yColumn) == "table" thenfor z, block in pairs(yColumn) doif block and type(block) == "table" thenlocal material = block.materialif material and material ~= "" thenlocal gx = tostring(x)local gy = tostring(y)local gz = tostring(z)grid[gx] = grid[gx] or {}grid[gx][gy] = grid[gx][gy] or {}grid[gx][gy][gz] = {material = material,meta = copyTable(block.meta),}endendendendendendendreturn gridendfunction schema_utils.canonicalToVoxelDefinition(schema, opts)return { grid = schema_utils.canonicalToGrid(schema, opts) }endfunction schema_utils.printMaterials(io, info)if not io.print thenreturnendif not info or not info.materials or #info.materials == 0 thenio.print("Materials: <none>")returnendio.print("Materials:")for _, entry in ipairs(info.materials) doio.print(string.format(" - %s x%d", entry.material, entry.count))endendfunction schema_utils.printBounds(io, info)if not io.print thenreturnendif not info or not info.bounds or not info.bounds.min thenio.print("Bounds: <unknown>")returnendlocal minB = info.bounds.minlocal maxB = info.bounds.maxlocal dims = {x = (maxB.x - minB.x) + 1,y = (maxB.y - minB.y) + 1,z = (maxB.z - minB.z) + 1,}io.print(string.format("Bounds: min(%d,%d,%d) max(%d,%d,%d) dims(%d,%d,%d)",minB.x, minB.y, minB.z, maxB.x, maxB.y, maxB.z, dims.x, dims.y, dims.z))endreturn schema_utils]===]
files['lib/lib_startup.lua'] = [===[---@diagnostic disable: undefined-globallocal fuelLib = require("lib_fuel")local logger = require("lib_logger")local movement = require("lib_movement")local inventory = require("lib_inventory")local startup = {}-- Checks fuel level and attempts to refuel from inventory or fuel chest.-- Returns true if fuel is sufficient, false if critical shortage (caller should wait/retry).function startup.runFuelCheck(ctx, chests, threshold, target)threshold = threshold or 200target = target or 1000local current = turtle.getFuelLevel()if current == "unlimited" then return true endif type(current) ~= "number" then current = 0 endif current < threshold thenlogger.log(ctx, "warn", "Fuel low (" .. current .. "). Attempting refuel...")fuelLib.refuel(ctx, { target = target })current = turtle.getFuelLevel()if current == "unlimited" then current = math.huge endif type(current) ~= "number" then current = 0 endif current < threshold thenif chests and chests.fuel thenlogger.log(ctx, "info", "Going to fuel chest...")movement.goTo(ctx, { x=0, y=0, z=0 })movement.face(ctx, chests.fuel)turtle.suck()fuelLib.refuel(ctx, { target = target })endendcurrent = turtle.getFuelLevel()if current == "unlimited" then current = math.huge endif type(current) ~= "number" then current = 0 endif current < threshold thenlogger.log(ctx, "error", "Critical fuel shortage. Waiting.")sleep(10)return falseendendreturn trueend-- Runs the chest setup wizard.-- Returns the configured chests table.function startup.runChestSetup(ctx)local chests = {}logger.log(ctx, "info", "Scanning for nearby containers...")-- Scan all sides for a containerlocal sides = {"front", "top", "bottom", "left", "right", "back"}local foundSide = nilfor _, side in ipairs(sides) dolocal info = inventory.detectContainer(ctx, { side = side })if info thenfoundSide = sidelogger.log(ctx, "info", "Found container at " .. side)breakendendif foundSide then-- Use the found container for everythingchests.output = foundSidechests.trash = foundSidechests.fuel = foundSidelogger.log(ctx, "info", "Using " .. foundSide .. " container for all operations.")elselogger.log(ctx, "warn", "No containers found nearby. Operations requiring chests may fail.")-- Fallback to 'front' just in case the user places one later without restartingchests.output = "front"chests.trash = "front"chests.fuel = "front"endreturn chestsendreturn startup]===]
files['lib/lib_strategy.lua'] = [=======[---@diagnostic disable: undefined-global

local strategy_utils = {}

local world = require("lib_world")

function strategy_utils.ensurePointer(ctx)
    if type(ctx.pointer) == "table" then
        return ctx.pointer
    end
    local strategy = ctx.strategy
    if type(strategy) == "table" and type(strategy.order) == "table" then
        local idx = strategy.index or 1
        local pos = strategy.order[idx]
        if pos then
            ctx.pointer = world.copyPosition(pos)
            strategy.index = idx
            return ctx.pointer
        end
        return nil, "strategy_exhausted"
    end
    return nil, "no_pointer"
end

function strategy_utils.advancePointer(ctx)
    if type(ctx.strategy) == "table" then
        local strategy = ctx.strategy
        if type(strategy.advance) == "function" then
            local nextPos, doneFlag = strategy.advance(strategy, ctx)
            if nextPos then
                ctx.pointer = world.copyPosition(nextPos)
                return true
            end
            if doneFlag == false then
                return false
            end
            ctx.pointer = nil
            return false
        end
        if type(strategy.next) == "function" then
            local nextPos = strategy.next(strategy, ctx)
            if nextPos then
                ctx.pointer = world.copyPosition(nextPos)
                return true
            end
            ctx.pointer = nil
            return false
        end
        if type(strategy.order) == "table" then
            local idx = (strategy.index or 1) + 1
            strategy.index = idx
            local pos = strategy.order[idx]
            if pos then
                ctx.pointer = world.copyPosition(pos)
                return true
            end
            ctx.pointer = nil
            return false
        end
    elseif type(ctx.strategy) == "function" then
        local nextPos = ctx.strategy(ctx)
        if nextPos then
            ctx.pointer = world.copyPosition(nextPos)
            return true
        end
        ctx.pointer = nil
        return false
    end
    ctx.pointer = nil
    return false
end

return strategy_utils]=======]
files['lib/lib_strategy_branchmine.lua'] = [=========[local strategy = {}local function normalizePositiveInt(value, default)local numberValue = tonumber(value)if not numberValue or numberValue < 1 thenreturn defaultendreturn math.floor(numberValue)endlocal function pushStep(steps, x, y, z, facing, stepType, data)steps[#steps + 1] = {type = stepType,x = x,y = y,z = z,facing = facing,data = data,}endlocal function forward(x, z, facing)if facing == 0 thenz = z + 1elseif facing == 1 thenx = x + 1elseif facing == 2 thenz = z - 1elsex = x - 1endreturn x, zendlocal function turnLeft(facing)return (facing + 3) % 4endlocal function turnRight(facing)return (facing + 1) % 4end--- Generate a branch mining strategy---@param length number Length of the main spine---@param branchInterval number Distance between branches---@param branchLength number Length of each branch---@param torchInterval number Distance between torches on spine---@return tablefunction strategy.generate(length, branchInterval, branchLength, torchInterval)length = normalizePositiveInt(length, 60)branchInterval = normalizePositiveInt(branchInterval, 3)branchLength = normalizePositiveInt(branchLength, 16)torchInterval = normalizePositiveInt(torchInterval, 6)local steps = {}local x, y, z = 0, 0, 0local facing = 0 -- 0: forward, 1: right, 2: back, 3: leftpushStep(steps, x, y, z, facing, "place_chest")-- Removed initial mine_neighbors to avoid mining the chest we just placed-- pushStep(steps, x, y, z, facing, "mine_neighbors")for i = 1, length dox, z = forward(x, z, facing)pushStep(steps, x, y, z, facing, "move")pushStep(steps, x, y, z, facing, "mine_neighbors")if i % torchInterval == 0 thenpushStep(steps, x, y, z, facing, "place_torch")endif i % branchInterval == 0 then-- Left branchfacing = turnLeft(facing)pushStep(steps, x, y, z, facing, "turn", "left")for _ = 1, branchLength dox, z = forward(x, z, facing)pushStep(steps, x, y, z, facing, "move")pushStep(steps, x, y, z, facing, "mine_neighbors")end-- Go UPy = y + 1pushStep(steps, x, y, z, facing, "move")pushStep(steps, x, y, z, facing, "mine_neighbors")-- Turn around and return to spinefacing = turnRight(facing)pushStep(steps, x, y, z, facing, "turn", "right")facing = turnRight(facing)pushStep(steps, x, y, z, facing, "turn", "right")for _ = 1, branchLength dox, z = forward(x, z, facing)pushStep(steps, x, y, z, facing, "move")pushStep(steps, x, y, z, facing, "mine_neighbors")end-- Go DOWNy = y - 1pushStep(steps, x, y, z, facing, "move")-- Face down the spine againfacing = turnLeft(facing)pushStep(steps, x, y, z, facing, "turn", "left")-- Right branch (mirror of left)facing = turnRight(facing)pushStep(steps, x, y, z, facing, "turn", "right")for _ = 1, branchLength dox, z = forward(x, z, facing)pushStep(steps, x, y, z, facing, "move")pushStep(steps, x, y, z, facing, "mine_neighbors")end-- Go UPy = y + 1pushStep(steps, x, y, z, facing, "move")pushStep(steps, x, y, z, facing, "mine_neighbors")facing = turnRight(facing)pushStep(steps, x, y, z, facing, "turn", "right")facing = turnRight(facing)pushStep(steps, x, y, z, facing, "turn", "right")for _ = 1, branchLength dox, z = forward(x, z, facing)pushStep(steps, x, y, z, facing, "move")pushStep(steps, x, y, z, facing, "mine_neighbors")end-- Go DOWNy = y - 1pushStep(steps, x, y, z, facing, "move")facing = turnRight(facing)pushStep(steps, x, y, z, facing, "turn", "right")endif i % 5 == 0 thenpushStep(steps, x, y, z, facing, "dump_trash")endend-- Return to originfacing = turnRight(facing)pushStep(steps, x, y, z, facing, "turn", "right")facing = turnRight(facing)pushStep(steps, x, y, z, facing, "turn", "right")for _ = 1, length dox, z = forward(x, z, facing)pushStep(steps, x, y, z, facing, "move")endfacing = turnRight(facing)pushStep(steps, x, y, z, facing, "turn", "right")facing = turnRight(facing)pushStep(steps, x, y, z, facing, "turn", "right")pushStep(steps, x, y, z, facing, "done")return stepsendreturn strategy]=========]
files['lib/lib_strategy_excavate.lua'] = [====[local strategy = {}local function normalizePositiveInt(value, default)local numberValue = tonumber(value)if not numberValue or numberValue < 1 thenreturn defaultendreturn math.floor(numberValue)endlocal function pushStep(steps, x, y, z, facing, stepType, data)steps[#steps + 1] = {type = stepType,x = x,y = y,z = z,facing = facing,data = data,}end--- Generate an excavation strategy---@param length number Length (z-axis)---@param width number Width (x-axis)---@param depth number Depth (y-axis, downwards)---@return tablefunction strategy.generate(length, width, depth)length = normalizePositiveInt(length, 8)width = normalizePositiveInt(width, 8)depth = normalizePositiveInt(depth, 3)local steps = {}local x, y, z = 0, 0, 0local facing = 0 -- 0: forward (z+), 1: right (x+), 2: back (z-), 3: left (x-)-- We assume turtle starts at (0,0,0) which is the top-left corner of the hole.-- It will excavate x=[0, width-1], z=[0, length-1], y=[0, -depth+1].for d = 0, depth - 1 dolocal currentY = -d-- Serpentine pattern for the layer-- If d is even: start at (0,0), end at (W-1, L-1) or (0, L-1) depending on W.-- If d is odd: we should probably reverse to minimize travel.-- Actually, standard excavate usually returns to start to dump items?-- My system handles restocking/refueling via state machine interrupts.-- So I just need to generate the path.-- Layer logic:-- Iterate z from 0 to length-1.-- For each z, iterate x.-- To optimize, we alternate x direction every z row.-- And we alternate z direction every layer?-- Let's keep it simple.-- Layer 0: z=0..L-1.--   z=0: x=0..W-1--   z=1: x=W-1..0--   ...-- End of Layer 0 is at z=L-1, x=(depends).-- Layer 1 starts at z=L-1, x=(same).-- So Layer 1 should go z=L-1..0.local zStart, zEnd, zStepif d % 2 == 0 thenzStart, zEnd, zStep = 0, length - 1, 1elsezStart, zEnd, zStep = length - 1, 0, -1endfor z = zStart, zEnd, zStep dolocal xStart, xEnd, xStep-- Determine x direction based on z and layer parity?-- If d is even (0):--   z=0: x=0..W-1--   z=1: x=W-1..0--   So if z is even, x=0..W-1.-- If d is odd (1):--   We start at z=L-1.--   We want to match the x from previous layer.--   Previous layer ended at z=L-1.--   If (L-1) was even, it ended at W-1.--   If (L-1) was odd, it ended at 0.-- Let's just use currentX to decide.-- But we are generating steps, we don't track currentX easily unless we simulate.-- Let's simulate.-- Wait, I can just use the same logic as tunnel.-- If we are at x=0, go to W-1.-- If we are at x=W-1, go to 0.-- But I need to know where I am at the start of the z-loop.-- At start of d=0, I am at (0,0,0).-- Let's track currentX, currentZ.if d == 0 and z == zStart thenx = 0endif x == 0 thenxStart, xEnd, xStep = 0, width - 1, 1elsexStart, xEnd, xStep = width - 1, 0, -1endfor ix = xStart, xEnd, xStep dox = ixpushStep(steps, x, currentY, z, 0, "move")endendendreturn stepsendreturn strategy]====]
files['lib/lib_strategy_farm.lua'] = [=======[local strategy = {}local MATERIALS = {dirt = "minecraft:dirt",sand = "minecraft:sand",water = "minecraft:water_bucket",log = "minecraft:oak_log",sapling = "minecraft:oak_sapling",cane = "minecraft:sugar_cane",potato = "minecraft:potatoes",carrot = "minecraft:carrots",wheat = "minecraft:wheat",beetroot = "minecraft:beetroots",nether_wart = "minecraft:nether_wart",soul_sand = "minecraft:soul_sand",farmland = "minecraft:farmland",stone = "minecraft:stone_bricks", -- Bordertorch = "minecraft:torch",furnace = "minecraft:furnace",chest = "minecraft:chest"}local function createBlock(mat)return { material = mat }endfunction strategy.generate(farmType, width, length)width = tonumber(width) or 9length = tonumber(length) or 9local schema = {}-- Helper to set blocklocal function set(x, y, z, mat)schema[x] = schema[x] or {}schema[x][y] = schema[x][y] or {}schema[x][y][z] = createBlock(mat)endif farmType == "tree" then-- Simple grid of saplings with 2 block spacing-- Layer 0: Dirt-- Layer 1: Saplingsfor x = 0, width - 1 dofor z = 0, length - 1 doset(x, 0, z, MATERIALS.dirt)-- Borderif x == 0 or x == width - 1 or z == 0 or z == length - 1 thenset(x, 0, z, MATERIALS.stone)else-- Checkerboard or spacingif x % 3 == 1 and z % 3 == 1 thenset(x, 1, z, MATERIALS.sapling)elseif (x % 3 == 1 and z % 3 == 0) or (x % 3 == 0 and z % 3 == 1) then-- Space around saplingelseif x % 5 == 0 and z % 5 == 0 thenset(x, 1, z, MATERIALS.torch)endendendend-- Add charcoal maker essentials (Furnace + Chest) on the borderset(0, 1, 1, MATERIALS.furnace)set(0, 1, 2, MATERIALS.chest)elseif farmType == "cane" then-- Rows: Water, Sand, Sand, Waterfor x = 0, width - 1 dofor z = 0, length - 1 do-- Borderif z == 0 or z == length - 1 thenset(x, 0, z, MATERIALS.stone)elselocal pattern = x % 3if pattern == 0 thenset(x, 0, z, MATERIALS.water)elseset(x, 0, z, MATERIALS.sand)set(x, 1, z, MATERIALS.cane)endendendendelseif farmType == "potato" or farmType == "carrot" or farmType == "wheat" or farmType == "beetroot" then-- Standard crop farm-- Rows of water every 4 blocks?-- Hydration is 4 blocks.-- Pattern: W D D D D D D D D W (9 blocks)-- Let's do: W D D D W D D D Wfor x = 0, width - 1 dofor z = 0, length - 1 do-- Only lay ground (dirt/water) at y=0; no border blocks or crops.if x % 4 == 0 thenset(x, 0, z, MATERIALS.water)elseset(x, 0, z, MATERIALS.dirt) -- turtle tills/handles crops laterendendendelseif farmType == "nether_wart" then-- Soul sand fieldfor x = 0, width - 1 dofor z = 0, length - 1 doif z == 0 or z == length - 1 or x == 0 or x == width - 1 thenset(x, 0, z, MATERIALS.stone)elseset(x, 0, z, MATERIALS.soul_sand)set(x, 1, z, MATERIALS.nether_wart)endendendendreturn schemaendreturn strategy]=======]
files['lib/lib_strategy_tunnel.lua'] = [=====[local strategy = {}local function normalizePositiveInt(value, default)local numberValue = tonumber(value)if not numberValue or numberValue < 1 thenreturn defaultendreturn math.floor(numberValue)endlocal function pushStep(steps, x, y, z, facing, stepType, data)steps[#steps + 1] = {type = stepType,x = x,y = y,z = z,facing = facing,data = data,}endlocal function forward(x, z, facing)if facing == 0 thenz = z + 1elseif facing == 1 thenx = x + 1elseif facing == 2 thenz = z - 1elsex = x - 1endreturn x, zendlocal function turnLeft(facing)return (facing + 3) % 4endlocal function turnRight(facing)return (facing + 1) % 4end--- Generate a tunnel strategy---@param length number Length of the tunnel---@param width number Width of the tunnel---@param height number Height of the tunnel---@param torchInterval number Distance between torches---@return tablefunction strategy.generate(length, width, height, torchInterval)length = normalizePositiveInt(length, 16)width = normalizePositiveInt(width, 1)height = normalizePositiveInt(height, 2)torchInterval = normalizePositiveInt(torchInterval, 6)local steps = {}local x, y, z = 0, 0, 0local facing = 0 -- 0: forward (z+), 1: right (x+), 2: back (z-), 3: left (x-)-- We assume the turtle starts at bottom-left of the tunnel face, facing into the tunnel.-- Actually, let's assume turtle starts at (0,0,0) and that is the bottom-center or bottom-left?-- Let's assume standard behavior: Turtle is at start of tunnel.-- It will mine forward `length` blocks.-- If width > 1, it needs to strafe or turn.-- Simple implementation: Layer by layer, row by row.-- But for a tunnel, we usually want to move forward, clearing the cross-section.for l = 1, length do-- Clear the cross-section at current depth-- We are at some (x, y) in the cross section.-- Let's say we start at bottom-left (0,0) of the cross section relative to the tunnel axis.-- Actually, simpler: Just iterate x, y, z loops.-- But we want to minimize movement.-- Serpentine pattern for the cross section?-- Let's stick to the `state_mine` logic which expects "move" steps.-- `state_mine` is designed for branch mining where it moves forward and mines neighbors.-- It might not be suitable for clearing a large room.-- `state_mine` supports: move, turn, mine_neighbors, place_torch.-- `mine_neighbors` mines up, down, left, right, front.-- If we use `state_mine`, we are limited to its capabilities.-- Maybe we should use `state_build` logic but with "dig" enabled?-- Or extend `state_mine`?-- `state_mine` logic:-- if step.type == "move" then movement.goTo(dest, {dig=true})-- So if we generate a path that covers every block in the tunnel volume, `movement.goTo` with `dig=true` will clear it.-- We just need to generate the path.-- Let's generate a path that visits every block in the volume (0..width-1, 0..height-1, 1..length)-- Wait, 1..length because 0 is start?-- Let's say turtle starts at 0,0,0.-- It needs to clear 0,0,1 to width-1, height-1, length.-- Actually, let's just do a simple serpentine.-- Current pos-- x, y, z are relative to start.-- We are at (x,y,z). We want to clear the block at (x,y,z) if it's not 0,0,0?-- No, `goTo` moves TO the block.-- Let's iterate length first (depth), then width/height?-- No, usually you want to clear the face then move forward.-- But `goTo` is absolute coords.-- Let's do:-- For each slice z = 1 to length:--   For each y = 0 to height-1:--     For each x = 0 to width-1:--       visit(x, y, z)-- Optimization: Serpentine x and y.end-- Re-thinking: `state_mine` uses `localToWorld` which interprets x,y,z relative to turtle start.-- So we just need to generate a list of coordinates to visit.local currentX, currentY, currentZ = 0, 0, 0for d = 1, length do-- Move forward to next slice-- We are at z = d-1. We want to clear z = d.-- But we also need to clear x=0..width-1, y=0..height-1 at z=d.-- Let's assume we are at (currentX, currentY, d-1).-- We move to (currentX, currentY, d).-- Serpentine logic for the face-- We are at some x,y.-- We want to cover all x in [0, width-1] and y in [0, height-1].-- If we are just moving forward, we are carving a 1x1 tunnel.-- If width/height > 1, we need to visit others.-- Let's generate points.local slicePoints = {}for y = 0, height - 1 dofor x = 0, width - 1 dotable.insert(slicePoints, {x=x, y=y})endend-- Sort slicePoints to be nearest neighbor or serpentine-- Simple serpentine:-- If y is even, x goes 0 -> width-1-- If y is odd, x goes width-1 -> 0-- But we also need to minimize y movement.-- Actually, let's just generate the path directly.-- We are at z=d.-- We iterate y from 0 to height-1.-- If y is even: x from 0 to width-1-- If y is odd: x from width-1 to 0-- But wait, between slices, we want to connect the end of slice d to start of slice d+1.-- End of slice d is (endX, endY, d).-- Start of slice d+1 should be (endX, endY, d+1).-- So we should reverse the traversal order for the next slice?-- Or just continue?-- Let's try to keep it simple.-- Slice 1:--   y=0: x=0->W--   y=1: x=W->0--   ...--   End at (LastX, LastY, 1)-- Slice 2:--   Start at (LastX, LastY, 2)--   We should traverse in reverse of Slice 1 to minimize movement?--   Or just continue the pattern?-- Let's just do standard serpentine for every slice, but reverse the whole slice order if d is even?local yStart, yEnd, yStepif d % 2 == 1 thenyStart, yEnd, yStep = 0, height - 1, 1elseyStart, yEnd, yStep = height - 1, 0, -1endfor y = yStart, yEnd, yStep dolocal xStart, xEnd, xStep-- If we are on an "even" row relative to the start of this slice...-- Let's just say: if y is even, go right. If y is odd, go left.-- But we need to match the previous position.-- If we came from z-1, we are at (currentX, currentY, d-1).-- We move to (currentX, currentY, d).-- So we should start this slice at currentX, currentY.-- This implies we shouldn't hardcode loops, but rather "fill" the slice starting from current pos.-- But that's pathfinding.-- Let's stick to a fixed pattern that aligns.-- If width=1, height=2.-- d=1: (0,0,1) -> (0,1,1). End at (0,1,1).-- d=2: (0,1,2) -> (0,0,2). End at (0,0,2).-- d=3: (0,0,3) -> (0,1,3).-- This works perfectly.-- So:-- If d is odd: y goes 0 -> height-1.-- If d is even: y goes height-1 -> 0.-- Inside y loop:-- We need to decide x direction.-- If y is even (0, 2...): x goes 0 -> width-1?-- Let's trace d=1 (odd). y=0. x=0->W. End x=W-1.-- y=1. We are at x=W-1. So x should go W-1 -> 0.-- So if y is odd: x goes W-1 -> 0.-- Now d=2 (even). Start y=height-1.-- If height=2. Start y=1.-- We ended d=1 at (0, 1, 1).-- So we start d=2 at (0, 1, 2).-- y=1 is odd. So x goes W-1 -> 0?-- Wait, we are at x=0.-- So if y is odd, we should go 0 -> W-1?-- This depends on where we ended.-- Let's generalize.-- We are at (currentX, currentY, d).-- We want to visit all x in row y.-- If currentX is 0, go to W-1.-- If currentX is W-1, go to 0.if currentX == 0 thenxStart, xEnd, xStep = 0, width - 1, 1elsexStart, xEnd, xStep = width - 1, 0, -1endfor x = xStart, xEnd, xStep do-- We are visiting (x, y, d)-- But wait, we need to actually MOVE there.-- The loop generates the target coordinates.-- If this is the very first point (0,0,1), we are at (0,0,0).-- We just push the step.pushStep(steps, x, y, d, 0, "move")currentX, currentY, currentZ = x, y, d-- Place torch?-- Only on the floor (y=0) and maybe centered x?-- And at interval.if y == 0 and x == math.floor((width-1)/2) and d % torchInterval == 0 thenpushStep(steps, x, y, d, 0, "place_torch")endendendendreturn stepsendreturn strategy]=====]
files['lib/lib_string.lua'] = [===[local string_utils = {}

function string_utils.trim(text)
    if type(text) ~= "string" then
        return text
    end
    return text:match("^%s*(.-)%s*$")
end

function string_utils.detailToString(value, depth)
    depth = (depth or 0) + 1
    if depth > 4 then
        return "..."
    end
    if type(value) ~= "table" then
        return tostring(value)
    end
    if textutils and textutils.serialize then
        return textutils.serialize(value)
    end
    local parts = {}
    for k, v in pairs(value) do
        parts[#parts + 1] = tostring(k) .. "=" .. string_utils.detailToString(v, depth)
    end
    return "{" .. table.concat(parts, ", ") .. "}"
end

return string_utils]===]
files['lib/lib_table.lua'] = [=========[local table_utils = {}

function table_utils.copy(source)
    if type(source) ~= "table" then
        return {}
    end
    local result = {}
    for key, value in pairs(source) do
        result[key] = value
    end
    return result
end

local function deepCopy(value)
    if type(value) ~= "table" then
        return value
    end
    local result = {}
    for k, v in pairs(value) do
        result[k] = deepCopy(v)
    end
    return result
end

table_utils.deepCopy = deepCopy

function table_utils.merge(base, overrides)
    if type(base) ~= "table" and type(overrides) ~= "table" then
        return overrides or base
    end

    local result = {}

    if type(base) == "table" then
        for k, v in pairs(base) do
            result[k] = deepCopy(v)
        end
    end

    if type(overrides) == "table" then
        for k, v in pairs(overrides) do
            if type(v) == "table" and type(result[k]) == "table" then
                result[k] = table_utils.merge(result[k], v)
            else
                result[k] = deepCopy(v)
            end
        end
    elseif overrides ~= nil then
        return deepCopy(overrides)
    end

    return result
end

function table_utils.copyArray(source)
    local result = {}
    if type(source) ~= "table" then
        return result
    end
    for i = 1, #source do
        result[i] = source[i]
    end
    return result
end

function table_utils.sumValues(tbl)
    local total = 0
    if type(tbl) ~= "table" then
        return total
    end
    for _, value in pairs(tbl) do
        if type(value) == "number" then
            total = total + value
        end
    end
    return total
end

function table_utils.copyTotals(totals)
    local result = {}
    for material, count in pairs(totals or {}) do
        result[material] = count
    end
    return result
end

function table_utils.mergeTotals(target, source)
    for material, count in pairs(source or {}) do
        target[material] = (target[material] or 0) + count
    end
end

function table_utils.tableCount(tbl)
    if type(tbl) ~= "table" then
        return 0
    end
    local count = 0
    for _ in pairs(tbl) do
        count = count + 1
    end
    return count
end

function table_utils.copyArray(list)
    if type(list) ~= "table" then
        return {}
    end
    local result = {}
    for index = 1, #list do
        result[index] = list[index]
    end
    return result
end

function table_utils.copySummary(summary)
    if type(summary) ~= "table" then
        return {}
    end
    local result = {}
    for key, value in pairs(summary) do
        result[key] = value
    end
    return result
end

function table_utils.copySlots(slots)
    if type(slots) ~= "table" then
        return {}
    end
    local result = {}
    for slot, info in pairs(slots) do
        if type(info) == "table" then
            result[slot] = {
                slot = info.slot,
                count = info.count,
                name = info.name,
                detail = info.detail,
            }
        else
            result[slot] = info
        end
    end
    return result
end

function table_utils.copyValue(value, seen)
    if type(value) ~= "table" then
        return value
    end
    seen = seen or {}
    if seen[value] then
        return seen[value]
    end
    local result = {}
    seen[value] = result
    for k, v in pairs(value) do
        result[k] = table_utils.copyValue(v, seen)
    end
    return result
end

function table_utils.shallowCopy(tbl)
    local result = {}
    for k, v in pairs(tbl) do
        result[k] = v
    end
    return result
end

return table_utils]=========]
files['lib/lib_ui.lua'] = [====[local ui = {}local colors_bg = colors.bluelocal colors_fg = colors.whitelocal colors_btn = colors.lightGraylocal colors_btn_text = colors.blacklocal colors_input = colors.blacklocal colors_input_text = colors.whitefunction ui.clear()term.setBackgroundColor(colors_bg)term.setTextColor(colors_fg)term.clear()endfunction ui.drawBox(x, y, w, h, bg, fg)term.setBackgroundColor(bg)term.setTextColor(fg)for i = 0, h - 1 doterm.setCursorPos(x, y + i)term.write(string.rep(" ", w))endendfunction ui.drawFrame(x, y, w, h, title)ui.drawBox(x, y, w, h, colors.gray, colors.white)ui.drawBox(x + 1, y + 1, w - 2, h - 2, colors_bg, colors_fg)-- Shadowterm.setBackgroundColor(colors.black)for i = 1, h doterm.setCursorPos(x + w, y + i)term.write(" ")endfor i = 1, w doterm.setCursorPos(x + i, y + h)term.write(" ")endif title thenterm.setCursorPos(x + 2, y + 1)term.setBackgroundColor(colors.white)term.setTextColor(colors.black)term.write(" " .. title .. " ")endendfunction ui.button(x, y, text, active)term.setCursorPos(x, y)if active thenterm.setBackgroundColor(colors.white)term.setTextColor(colors.black)elseterm.setBackgroundColor(colors_btn)term.setTextColor(colors_btn_text)endterm.write(" " .. text .. " ")endfunction ui.label(x, y, text)term.setCursorPos(x, y)term.setBackgroundColor(colors_bg)term.setTextColor(colors_fg)term.write(text)endfunction ui.inputText(x, y, width, value, active)term.setCursorPos(x, y)term.setBackgroundColor(colors_input)term.setTextColor(colors_input_text)local display = value or ""if #display > width thendisplay = display:sub(-width)endterm.write(display .. string.rep(" ", width - #display))if active thenterm.setCursorPos(x + #display, y)term.setCursorBlink(true)elseterm.setCursorBlink(false)endendfunction ui.drawPreview(schema, x, y, w, h)-- Find boundslocal minX, maxX, minZ, maxZ = 9999, -9999, 9999, -9999for sx, row in pairs(schema) dolocal nx = tonumber(sx)if nx thenif nx < minX then minX = nx endif nx > maxX then maxX = nx endfor sy, col in pairs(row) dofor sz, block in pairs(col) dolocal nz = tonumber(sz)if nz thenif nz < minZ then minZ = nz endif nz > maxZ then maxZ = nz endendendendendendif minX > maxX then return end -- Empty schemalocal scaleX = w / (maxX - minX + 1)local scaleZ = h / (maxZ - minZ + 1)local scale = math.min(scaleX, scaleZ, 1) -- Keep aspect ratio, max 1:1-- Draw backgroundterm.setBackgroundColor(colors.black)for i = 0, h - 1 doterm.setCursorPos(x, y + i)term.write(string.rep(" ", w))end-- Draw blocksfor sx, row in pairs(schema) dolocal nx = tonumber(sx)if nx thenfor sy, col in pairs(row) dofor sz, block in pairs(col) dolocal nz = tonumber(sz)if nz then-- Map to screenlocal scrX = math.floor((nx - minX) * scale) + xlocal scrY = math.floor((nz - minZ) * scale) + yif scrX >= x and scrX < x + w and scrY >= y and scrY < y + h thenterm.setCursorPos(scrX, scrY)-- Color mappinglocal mat = block.materiallocal color = colors.graylocal char = " "if mat:find("water") then color = colors.blueelseif mat:find("log") then color = colors.brownelseif mat:find("leaves") then color = colors.greenelseif mat:find("sapling") then color = colors.green; char = "T"elseif mat:find("sand") then color = colors.yellowelseif mat:find("dirt") then color = colors.brownelseif mat:find("grass") then color = colors.greenelseif mat:find("stone") then color = colors.lightGrayelseif mat:find("cane") then color = colors.lime; char = "!"elseif mat:find("potato") then color = colors.orange; char = "."elseif mat:find("torch") then color = colors.orange; char = "i"endterm.setBackgroundColor(color)if color == colors.black then term.setTextColor(colors.white) else term.setTextColor(colors.black) endterm.write(char)endendendendendendend-- Simple Event Loop for a Form-- form = { title = "", elements = { {type="button", x=, y=, text=, id=}, ... } }function ui.runForm(form)local w, h = term.getSize()local fw, fh = math.floor(w * 0.8), math.floor(h * 0.8)local fx, fy = math.floor((w - fw) / 2) + 1, math.floor((h - fh) / 2) + 1local running = truelocal result = nillocal activeInput = nil-- Identify focusable elementslocal focusableIndices = {}for i, el in ipairs(form.elements) doif el.type == "input" or el.type == "button" thentable.insert(focusableIndices, i)endendlocal currentFocusIndex = 1if #focusableIndices > 0 thenlocal el = form.elements[focusableIndices[currentFocusIndex]]if el.type == "input" then activeInput = el endendwhile running doui.clear()ui.drawFrame(fx, fy, fw, fh, form.title)-- Custom Drawif form.onDraw thenform.onDraw(fx, fy, fw, fh)end-- Draw elementsfor i, el in ipairs(form.elements) dolocal ex, ey = fx + el.x, fy + el.ylocal isFocused = falseif #focusableIndices > 0 and focusableIndices[currentFocusIndex] == i thenisFocused = trueendif el.type == "button" thenui.button(ex, ey, el.text, isFocused)elseif el.type == "label" thenui.label(ex, ey, el.text)elseif el.type == "input" thenui.inputText(ex, ey, el.width, el.value, activeInput == el or isFocused)endendlocal event, p1, p2, p3 = os.pullEvent()if event == "mouse_click" thenlocal btn, mx, my = p1, p2, p3local clickedSomething = falsefor i, el in ipairs(form.elements) dolocal ex, ey = fx + el.x, fy + el.yif el.type == "button" thenif my == ey and mx >= ex and mx < ex + #el.text + 2 thenui.button(ex, ey, el.text, true) -- Flashsleep(0.1)if el.callback thenlocal res = el.callback(form)if res then return res endendclickedSomething = true-- Update focusfor fi, idx in ipairs(focusableIndices) doif idx == i then currentFocusIndex = fi; break endendactiveInput = nilendelseif el.type == "input" thenif my == ey and mx >= ex and mx < ex + el.width thenactiveInput = elclickedSomething = true-- Update focusfor fi, idx in ipairs(focusableIndices) doif idx == i then currentFocusIndex = fi; break endendendendendif not clickedSomething thenactiveInput = nilendelseif event == "char" and activeInput then
            if not activeInput.stepper then
                activeInput.value = (activeInput.value or "") .. p1
            end
        elseif event == "key" then
            local key = p1
            local focusedEl = (#focusableIndices > 0) and form.elements[focusableIndices[currentFocusIndex]] or nil
            local function adjustStepper(el, delta)
                if not el or not el.stepper then return end
                local step = el.step or 1
                local current = tonumber(el.value) or 0
                local nextVal = current + (delta * step)
                if el.min then nextVal = math.max(el.min, nextVal) end
                if el.max then nextVal = math.min(el.max, nextVal) end
                el.value = tostring(nextVal)
            end

            if key == keys.backspace and activeInput then
                local val = activeInput.value or ""
                if #val > 0 then
                    activeInput.value = val:sub(1, -2)
                end
            elseif (key == keys.left or key == keys.right) and focusedEl and focusedEl.stepper then
                local delta = key == keys.left and -1 or 1
                adjustStepper(focusedEl, delta)
                activeInput = nil
            elseif key == keys.tab or key == keys.down then
                if #focusableIndices > 0 then
                    currentFocusIndex = currentFocusIndex + 1
                    if currentFocusIndex > #focusableIndices then currentFocusIndex = 1 end
                    local el = form.elements[focusableIndices[currentFocusIndex]]activeInput = (el.type == "input") and el or nilendelseif key == keys.up thenif #focusableIndices > 0 thencurrentFocusIndex = currentFocusIndex - 1if currentFocusIndex < 1 then currentFocusIndex = #focusableIndices endlocal el = form.elements[focusableIndices[currentFocusIndex]]activeInput = (el.type == "input") and el or nilendelseif key == keys.enter thenif activeInput thenactiveInput = nil-- Move to nextif #focusableIndices > 0 thencurrentFocusIndex = currentFocusIndex + 1if currentFocusIndex > #focusableIndices then currentFocusIndex = 1 endlocal el = form.elements[focusableIndices[currentFocusIndex]]activeInput = (el.type == "input") and el or nilendelse-- Activate buttonif #focusableIndices > 0 thenlocal el = form.elements[focusableIndices[currentFocusIndex]]if el.type == "button" thenui.button(fx + el.x, fy + el.y, el.text, true) -- Flashsleep(0.1)if el.callback thenlocal res = el.callback(form)if res then return res endendelseif el.type == "input" thenactiveInput = elendendendendendendend-- Simple Scrollable Menu-- items = { { text="Label", callback=function() end }, ... }function ui.runMenu(title, items)local w, h = term.getSize()local fw, fh = math.floor(w * 0.8), math.floor(h * 0.8)local fx, fy = math.floor((w - fw) / 2) + 1, math.floor((h - fh) / 2) + 1local scroll = 0local maxVisible = fh - 4 -- Title + padding (top/bottom)local selectedIndex = 1while true doui.clear()ui.drawFrame(fx, fy, fw, fh, title)-- Draw itemsfor i = 1, maxVisible dolocal idx = i + scrollif idx <= #items thenlocal item = items[idx]local isSelected = (idx == selectedIndex)ui.button(fx + 2, fy + 1 + i, item.text, isSelected)endend-- Scroll indicatorsif scroll > 0 thenui.label(fx + fw - 2, fy + 2, "^")endif scroll + maxVisible < #items thenui.label(fx + fw - 2, fy + fh - 2, "v")endlocal event, p1, p2, p3 = os.pullEvent()if event == "mouse_click" thenlocal btn, mx, my = p1, p2, p3-- Check itemsfor i = 1, maxVisible dolocal idx = i + scrollif idx <= #items thenlocal item = items[idx]local bx, by = fx + 2, fy + 1 + i-- Button width is text length + 2 spacesif my == by and mx >= bx and mx < bx + #item.text + 2 thenui.button(bx, by, item.text, true) -- Flashsleep(0.1)if item.callback thenlocal res = item.callback()if res then return res endendselectedIndex = idxendendendelseif event == "mouse_scroll" thenlocal dir = p1if dir > 0 thenif scroll + maxVisible < #items then scroll = scroll + 1 endelseif scroll > 0 then scroll = scroll - 1 endendelseif event == "key" thenlocal key = p1if key == keys.up thenif selectedIndex > 1 thenselectedIndex = selectedIndex - 1if selectedIndex <= scroll thenscroll = selectedIndex - 1endendelseif key == keys.down thenif selectedIndex < #items thenselectedIndex = selectedIndex + 1if selectedIndex > scroll + maxVisible thenscroll = selectedIndex - maxVisibleendendelseif key == keys.enter thenlocal item = items[selectedIndex]if item and item.callback thenui.button(fx + 2, fy + 1 + (selectedIndex - scroll), item.text, true) -- Flashsleep(0.1)local res = item.callback()if res then return res endendendendendend-- Form Classfunction ui.Form(title)
    local self = {
        title = title,
        elements = {},
        _row = 0,
    }

    function self:addInput(id, label, value)
        local y = 2 + self._row
        table.insert(self.elements, { type = "label", x = 2, y = y, text = label })
        table.insert(self.elements, { type = "input", x = 15, y = y, width = 20, value = value, id = id })
        self._row = self._row + 1
    end

    function self:addStepper(id, label, value, opts)
        opts = opts or {}
        local y = 2 + self._row
        table.insert(self.elements, { type = "label", x = 2, y = y, text = label })
        table.insert(self.elements, {
            type = "input",
            x = 15,
            y = y,
            width = 12,
            value = tostring(value or 0),
            id = id,
            stepper = true,
            step = opts.step or 1,
            min = opts.min,
            max = opts.max,
        })
        self._row = self._row + 1
    end

    function self:addButton(id, label, callback)
         local y = 2 + self._row
         table.insert(self.elements, { type = "button", x = 2, y = y, text = label, id = id, callback = callback })
         self._row = self._row + 1
    end

    function self:run()
        -- Add OK/Cancel buttons
        local y = 2 + self._row + 2
        table.insert(self.elements, { 
            type = "button", x = 2, y = y, text = "OK", 
            callback = function(form) return "ok" end 
        })
        table.insert(self.elements, {type = "button", x = 10, y = y, text = "Cancel",callback = function(form) return "cancel" end})return ui.runForm(self)endreturn selfendfunction ui.toBlit(color)if colors.toBlit then return colors.toBlit(color) endlocal exponent = math.log(color) / math.log(2)return string.sub("0123456789abcdef", exponent + 1, exponent + 1)endreturn ui]====]
files['lib/lib_world.lua'] = [=======[local world = {}

function world.getInspect(side)
    if side == "forward" then
        return turtle.inspect
    elseif side == "up" then
        return turtle.inspectUp
    elseif side == "down" then
        return turtle.inspectDown
    end
    return nil
end

local SIDE_ALIASES = {
    forward = "forward",
    front = "forward",
    down = "down",
    bottom = "down",
    up = "up",
    top = "up",
    left = "left",
    right = "right",
    back = "back",
    behind = "back",
}

function world.normaliseSide(side)
    if type(side) ~= "string" then
        return nil
    end
    return SIDE_ALIASES[string.lower(side)]
end

function world.toPeripheralSide(side)
    local normalised = world.normaliseSide(side) or side
    if normalised == "forward" then
        return "front"
    elseif normalised == "up" then
        return "top"
    elseif normalised == "down" then
        return "bottom"
    elseif normalised == "back" then
        return "back"
    elseif normalised == "left" then
        return "left"
    elseif normalised == "right" then
        return "right"
    end
    return normalised
end

function world.inspectSide(side)
    local normalised = world.normaliseSide(side)
    if normalised == "forward" then
        return turtle and turtle.inspect and turtle.inspect()
    elseif normalised == "up" then
        return turtle and turtle.inspectUp and turtle.inspectUp()
    elseif normalised == "down" then
        return turtle and turtle.inspectDown and turtle.inspectDown()
    end
    return false
end

function world.isContainer(detail)
    if type(detail) ~= "table" then
        return false
    end
    local name = string.lower(detail.name or "")
    if name:find("chest", 1, true) or name:find("barrel", 1, true) or name:find("drawer", 1, true) then
        return true
    end
    if type(detail.tags) == "table" then
        for tag in pairs(detail.tags) do
            local lowered = string.lower(tag)
            if lowered:find("inventory", 1, true) or lowered:find("chest", 1, true) or lowered:find("barrel", 1, true) then
                return true
            end
        end
    end
    return false
end

function world.normalizeSide(value)
    if type(value) ~= "string" then
        return nil
    end
    local lower = value:lower()
    if lower == "forward" or lower == "front" or lower == "fwd" then
        return "forward"
    end
    if lower == "up" or lower == "top" or lower == "above" then
        return "up"
    end
    if lower == "down" or lower == "bottom" or lower == "below" then
        return "down"
    end
    return nil
end

function world.resolveSide(ctx, opts)
    if type(opts) == "string" then
        local direct = world.normalizeSide(opts)
        return direct or "forward"
    end

    local candidate
    if type(opts) == "table" then
        candidate = opts.side or opts.direction or opts.facing or opts.containerSide or opts.defaultSide
        if not candidate and type(opts.location) == "string" then
            candidate = opts.location
        end
    end

    if not candidate and type(ctx) == "table" then
        local cfg = ctx.config
        if type(cfg) == "table" then
            candidate = cfg.inventorySide or cfg.materialSide or cfg.supplySide or cfg.defaultInventorySide
        end
        if not candidate and type(ctx.inventoryState) == "table" then
            candidate = ctx.inventoryState.defaultSide
        end
    end

    local normalised = world.normalizeSide(candidate)
    if normalised then
        return normalised
    end

    return "forward"
end

function world.isContainerBlock(name, tags)
    if type(name) ~= "string" then
        return false
    end
    local lower = name:lower()
    for _, keyword in ipairs(CONTAINER_KEYWORDS) do
        if lower:find(keyword, 1, true) then
            return true
        end
    end
    return world.hasContainerTag(tags)
end

function world.inspectForwardForContainer()
    if not turtle or type(turtle.inspect) ~= "function" then
        return false
    end
    local ok, data = turtle.inspect()
    if not ok or type(data) ~= "table" then
        return false
    end
    if world.isContainerBlock(data.name, data.tags) then
        return true, data
    end
    return false
end

function world.inspectUpForContainer()
    if not turtle or type(turtle.inspectUp) ~= "function" then
        return false
    end
    local ok, data = turtle.inspectUp()
    if not ok or type(data) ~= "table" then
        return false
    end
    if world.isContainerBlock(data.name, data.tags) then
        return true, data
    end
    return false
end

function world.inspectDownForContainer()
    if not turtle or type(turtle.inspectDown) ~= "function" then
        return false
    end
    local ok, data = turtle.inspectDown()
    if not ok or type(data) ~= "table" then
        return false
    end
    if world.isContainerBlock(data.name, data.tags) then
        return true, data
    end
    return false
end

function world.peripheralSideForDirection(side)
    if side == "forward" or side == "front" then
        return "front"
    end
    if side == "up" or side == "top" then
        return "top"
    end
    if side == "down" or side == "bottom" then
        return "bottom"
    end
    return side
end

function world.computePrimaryPushDirection(ctx, periphSide)
    if periphSide == "front" then
        local facing = movement.getFacing(ctx)
        if facing then
            return OPPOSITE_FACING[facing]
        end
    elseif periphSide == "top" then
        return "down"
    elseif periphSide == "bottom" then
        return "up"
    end
    return nil
end

function world.normaliseCoordinate(value)
    local number = tonumber(value)
    if number == nil then
        return nil
    end
    if number >= 0 then
        return math.floor(number + 0.5)
    end
    return math.ceil(number - 0.5)
end

function world.normalisePosition(pos)
    if type(pos) ~= "table" then
        return nil, "invalid_position"
    end
    local xRaw = pos.x
    if xRaw == nil then
        xRaw = pos[1]
    end
    local yRaw = pos.y
    if yRaw == nil then
        yRaw = pos[2]
    end
    local zRaw = pos.z
    if zRaw == nil then
        zRaw = pos[3]
    end
    local x = world.normaliseCoordinate(xRaw)
    local y = world.normaliseCoordinate(yRaw)
    local z = world.normaliseCoordinate(zRaw)
    if not x or not y or not z then
        return nil, "invalid_position"
    end
    return { x = x, y = y, z = z }
end

function world.normaliseFacing(facing)
    facing = type(facing) == "string" and facing:lower() or "north"
    if facing ~= "north" and facing ~= "east" and facing ~= "south" and facing ~= "west" then
        return "north"
    end
    return facing
end

function world.facingVectors(facing)
    facing = world.normaliseFacing(facing)
    if facing == "north" then
        return { forward = { x = 0, z = -1 }, right = { x = 1, z = 0 } }
    elseif facing == "east" then
        return { forward = { x = 1, z = 0 }, right = { x = 0, z = 1 } }
    elseif facing == "south" then
        return { forward = { x = 0, z = 1 }, right = { x = -1, z = 0 } }
    else -- west
        return { forward = { x = -1, z = 0 }, right = { x = 0, z = -1 } }
    end
end

function world.rotateLocalOffset(localOffset, facing)
    local vectors = world.facingVectors(facing)
    local dx = localOffset.x or 0
    local dz = localOffset.z or 0
    local right = vectors.right
    local forward = vectors.forward
    return {
        x = (right.x * dx) + (forward.x * dz),
        z = (right.z * dx) + (forward.z * dz),
    }
end

function world.localToWorld(localOffset, facing)
    facing = world.normaliseFacing(facing)
    local dx = localOffset and localOffset.x or 0
    local dz = localOffset and localOffset.z or 0
    local rotated = world.rotateLocalOffset({ x = dx, z = dz }, facing)
    return {
        x = rotated.x,
        y = localOffset and localOffset.y or 0,
        z = rotated.z,
    }
end

function world.localToWorldRelative(origin, localPos)
    local rotated = world.localToWorld(localPos, origin.facing)
    return {
        x = origin.x + rotated.x,
        y = origin.y + rotated.y,
        z = origin.z + rotated.z
    }
end

function world.copyPosition(pos)
    if type(pos) ~= "table" then
        return nil
    end
    return {
        x = pos.x or 0,
        y = pos.y or 0,
        z = pos.z or 0,
    }
end

function world.detectContainers(io)
    local found = {}
    local sides = { "forward", "down", "up" }
    local labels = {
        forward = "front",
        down = "below",
        up = "above",
    }
    for _, side in ipairs(sides) do
        local inspect
        if side == "forward" then
            inspect = turtle.inspect
        elseif side == "up" then
            inspect = turtle.inspectUp
        else
            inspect = turtle.inspectDown
        end
        if type(inspect) == "function" then
            local ok, detail = inspect()
            if ok then
                local name = type(detail.name) == "string" and detail.name or "unknown"
                found[#found + 1] = string.format(" %s: %s", labels[side] or side, name)
            end
        end
    end
    if io.print then
        if #found == 0 then
            io.print("Detected containers: <none>")
        else
            io.print("Detected containers:")
            for _, line in ipairs(found) do
                io.print(" -" .. line)
            end
        end
    end
end

return world]=======]

-- Installer Logic
print('Installing files (Part 2)...')
for path, content in pairs(files) do
    local dir = fs.getDir(path)
    if not fs.exists(dir) then
        fs.makeDir(dir)
    end
    local f = fs.open(path, 'w')
    f.write(content)
    f.close()
    print('Installed: ' .. path)
end
print('Part 2 complete.')
print('Run the next part if available.')
