--[[ Local Installer Part 3 generated by bundle.ps1 ]]
local files = {}

files['lib/lib_worldstate.lua'] = [=========[local movement = require("lib_movement")local worldstate = {}local CARDINALS = { "north", "east", "south", "west" }local CARDINAL_INDEX = {north = 1,east = 2,south = 3,west = 4,}local MOVE_OPTS_CLEAR = { dig = true, attack = true }local MOVE_OPTS_SOFT = { dig = false, attack = false }local MOVE_AXIS_FALLBACK = { "z", "x", "y" }local function cloneTable(source)if type(source) ~= "table" thenreturn nilendlocal copy = {}for key, value in pairs(source) doif type(value) == "table" thencopy[key] = cloneTable(value)elsecopy[key] = valueendendreturn copyendlocal function canonicalFacing(name)if type(name) ~= "string" thenreturn nilendlocal normalized = name:lower()if CARDINAL_INDEX[normalized] thenreturn normalizedendreturn nilendlocal function rotateFacing(facing, steps)local canonical = canonicalFacing(facing)if not canonical thenreturn facingendlocal index = CARDINAL_INDEX[canonical]local count = #CARDINALSlocal rotated = ((index - 1 + steps) % count) + 1return CARDINALS[rotated]endlocal function rotate2D(x, z, steps)local normalized = steps % 4if normalized < 0 thennormalized = normalized + 4endif normalized == 0 thenreturn x, zelseif normalized == 1 thenreturn -z, xelseif normalized == 2 thenreturn -x, -zelsereturn z, -xendendlocal function mergeTables(target, source)if type(target) ~= "table" or type(source) ~= "table" thenreturn targetendfor key, value in pairs(source) doif type(value) == "table" thentarget[key] = target[key] or {}mergeTables(target[key], value)elsetarget[key] = valueendendreturn targetendlocal function ensureWorld(ctx)ctx.world = ctx.world or {}local world = ctx.worldworld.origin = world.origin or cloneTable(ctx.origin) or { x = 0, y = 0, z = 0 }ctx.origin = ctx.origin or cloneTable(world.origin)world.frame = world.frame or {}world.grid = world.grid or {}world.walkway = world.walkway or {}world.traversal = world.traversal or {}world.bounds = world.bounds or {}return worldend-- Reference-frame helpers -------------------------------------------------function worldstate.buildReferenceFrame(ctx, opts)local world = ensureWorld(ctx)opts = opts or {}local desired = canonicalFacing(opts.homeFacing)or canonicalFacing(opts.initialFacing)or canonicalFacing(ctx.config and (ctx.config.homeFacing or ctx.config.initialFacing))or canonicalFacing(world.frame.homeFacing)or "east"local baseline = canonicalFacing(opts.referenceFacing) or "east"local desiredIndex = CARDINAL_INDEX[desired]local baselineIndex = CARDINAL_INDEX[baseline]local rotationSteps = ((desiredIndex - baselineIndex) % 4)world.frame.rotationSteps = rotationStepsworld.frame.homeFacing = desiredworld.frame.referenceFacing = baselinereturn world.frameendfunction worldstate.referenceToWorld(ctx, refPos)if not refPos thenreturn nilendlocal world = ensureWorld(ctx)local rotationSteps = world.frame.rotationSteps or 0local x = refPos.x or 0local z = refPos.z or 0local rotatedX, rotatedZ = rotate2D(x, z, rotationSteps)return {x = (world.origin.x or 0) + rotatedX,y = (world.origin.y or 0) + (refPos.y or 0),z = (world.origin.z or 0) + rotatedZ,}endfunction worldstate.worldToReference(ctx, worldPos)if not worldPos thenreturn nilendlocal world = ensureWorld(ctx)local rotationSteps = world.frame.rotationSteps or 0local dx = (worldPos.x or 0) - (world.origin.x or 0)local dz = (worldPos.z or 0) - (world.origin.z or 0)local refX, refZ = rotate2D(dx, dz, -rotationSteps)return {x = refX,y = (worldPos.y or 0) - (world.origin.y or 0),z = refZ,}endfunction worldstate.resolveFacing(ctx, facing)local world = ensureWorld(ctx)local rotationSteps = world.frame.rotationSteps or 0return rotateFacing(facing, rotationSteps)endlocal function mergeMoveOpts(baseOpts, extraOpts)if not extraOpts thenif not baseOpts thenreturn nilendreturn cloneTable(baseOpts)endlocal merged = {}if baseOpts thenfor key, value in pairs(baseOpts) domerged[key] = valueendendfor key, value in pairs(extraOpts) domerged[key] = valueendreturn mergedendlocal function goToWithFallback(ctx, position, moveOpts)local ok, err = movement.goTo(ctx, position, moveOpts)if ok or (moveOpts and moveOpts.axisOrder) thenreturn ok, errendlocal fallbackOpts = mergeMoveOpts(moveOpts, { axisOrder = MOVE_AXIS_FALLBACK })return movement.goTo(ctx, position, fallbackOpts)endfunction worldstate.goToReference(ctx, refPos, moveOpts)if not refPos thenreturn false, "invalid_reference_position"endlocal worldPos = worldstate.referenceToWorld(ctx, refPos)return goToWithFallback(ctx, worldPos, moveOpts)endfunction worldstate.goAndFaceReference(ctx, refPos, facing, moveOpts)if not refPos thenreturn false, "invalid_reference_position"endlocal ok, err = worldstate.goToReference(ctx, refPos, moveOpts)if not ok thenreturn false, errendif facing thenreturn movement.faceDirection(ctx, worldstate.resolveFacing(ctx, facing))endreturn trueendfunction worldstate.returnHome(ctx, moveOpts)local world = ensureWorld(ctx)local opts = moveOpts or MOVE_OPTS_SOFTlocal ok, err = goToWithFallback(ctx, world.origin, opts)if not ok thenreturn false, errendlocal facing = world.frame.homeFacing or ctx.config and (ctx.config.homeFacing or ctx.config.initialFacing) or "east"ok, err = movement.faceDirection(ctx, facing)if not ok thenreturn false, errendreturn trueend-- Movement safety ---------------------------------------------------------function worldstate.configureNoDigBounds(ctx, bounds)local world = ensureWorld(ctx)world.bounds.noDig = cloneTable(bounds)return world.bounds.noDigendlocal function positionWithinBounds(pos, bounds)if not pos or not bounds thenreturn falseendlocal x, z = pos.x or 0, pos.z or 0if bounds.minX and x < bounds.minX thenreturn falseendif bounds.maxX and x > bounds.maxX thenreturn falseendif bounds.minZ and z < bounds.minZ thenreturn falseendif bounds.maxZ and z > bounds.maxZ thenreturn falseendreturn trueendfunction worldstate.moveOptsForPosition(ctx, position)local world = ensureWorld(ctx)local bounds = world.bounds.noDigif not bounds thenreturn MOVE_OPTS_CLEARendlocal ref = worldstate.worldToReference(ctx, position) or positionif positionWithinBounds(ref, bounds) thenreturn MOVE_OPTS_SOFTendreturn MOVE_OPTS_CLEARend-- Walkway planning --------------------------------------------------------local function isColumnX(grid, testX)if not grid or not grid.origin thenreturn falseendlocal spacing = grid.spacingX or 1local width = grid.width or 0local baseX = grid.origin.x or 0for offset = 0, math.max(width - 1, 0) dolocal columnX = baseX + offset * spacingif columnX == testX thenreturn trueendendreturn falseendlocal function insertUnique(list, value)if not list or value == nil thenreturnendfor _, entry in ipairs(list) doif entry == value thenreturnendendtable.insert(list, value)endfunction worldstate.configureGrid(ctx, cfg)local world = ensureWorld(ctx)cfg = cfg or {}world.grid.width = cfg.width or world.grid.width or ctx.config and ctx.config.gridWidth or 1world.grid.length = cfg.length or world.grid.length or ctx.config and ctx.config.gridLength or 1world.grid.spacingX = cfg.spacingX or cfg.spacing or world.grid.spacingX or ctx.config and (ctx.config.treeSpacingX or ctx.config.treeSpacing) or 1world.grid.spacingZ = cfg.spacingZ or cfg.spacing or world.grid.spacingZ or ctx.config and (ctx.config.treeSpacingZ or ctx.config.treeSpacing) or 1world.grid.origin = cloneTable(cfg.origin) or world.grid.origin or cloneTable(ctx.fieldOrigin) or { x = 0, y = 0, z = 0 }ctx.fieldOrigin = cloneTable(world.grid.origin)return world.gridendfunction worldstate.configureWalkway(ctx, cfg)local world = ensureWorld(ctx)cfg = cfg or {}local walkway = world.walkwaywalkway.offset = cfg.offsetor walkway.offsetor ctx.config and (ctx.config.walkwayOffsetX)or world.grid.spacingXwalkway.candidates = cloneTable(cfg.candidates) or walkway.candidates or {}if #walkway.candidates == 0 theninsertUnique(walkway.candidates, world.grid.origin.x + (walkway.offset or -1))insertUnique(walkway.candidates, world.grid.origin.x)insertUnique(walkway.candidates, ctx.origin and ctx.origin.x)endworldstate.ensureWalkwayAvailability(ctx)return walkwayendfunction worldstate.ensureWalkwayAvailability(ctx)local world = ensureWorld(ctx)local walkway = world.walkwaywalkway.candidates = walkway.candidates or {}local safe, selected = {}, walkway.selectedfor _, candidate in ipairs(walkway.candidates) doif candidate ~= nil and not isColumnX(world.grid, candidate) theninsertUnique(safe, candidate)selected = selected or candidateendendif not selected thenlocal spacing = world.grid.spacingX or 1local maxX = (world.grid.origin.x or 0) + math.max((world.grid.width or 1) - 1, 0) * spacingselected = maxX + spacinginsertUnique(safe, selected)endwalkway.candidates = safewalkway.selected = selectedctx.walkwayEntranceX = selectedreturn selectedendlocal function moveToAvailableWalkway(ctx, yLevel, targetZ)local world = ensureWorld(ctx)local walkway = world.walkwaylocal candidates = walkway.candidates or { walkway.selected }local lastErrfor _, safeX in ipairs(candidates) doif safeX thenlocal currentWorld = movement.getPosition(ctx)local currentRef = worldstate.worldToReference(ctx, currentWorld) or { x = 0, y = 0, z = 0 }local stageOne = { x = safeX, y = yLevel, z = currentRef.z }local ok, err = worldstate.goToReference(ctx, stageOne, MOVE_OPTS_SOFT)if not ok thenlastErr = errgoto next_candidateendlocal stageTwo = { x = safeX, y = yLevel, z = targetZ }ok, err = worldstate.goToReference(ctx, stageTwo, MOVE_OPTS_SOFT)if not ok thenlastErr = errgoto next_candidateendwalkway.selected = safeXctx.walkwayEntranceX = safeXreturn trueend::next_candidate::endreturn false, lastErr or "walkway_blocked"endfunction worldstate.moveAlongWalkway(ctx, targetRef)if not ctx or not targetRef thenreturn false, "invalid_target"endlocal world = ensureWorld(ctx)local currentWorld = movement.getPosition(ctx)local currentRef = worldstate.worldToReference(ctx, currentWorld) or { x = 0, y = 0, z = 0 }local yLevel = targetRef.y or world.grid.origin.y or 0if currentRef.z ~= targetRef.z thenlocal ok, err = moveToAvailableWalkway(ctx, yLevel, targetRef.z)if not ok thenreturn false, errendcurrentRef = { x = world.walkway.selected or currentRef.x, y = yLevel, z = targetRef.z }endif currentRef.x ~= targetRef.x thenlocal ok, err = worldstate.goToReference(ctx, { x = targetRef.x, y = yLevel, z = targetRef.z }, MOVE_OPTS_SOFT)if not ok thenreturn false, errendendreturn trueend-- Traversal bookkeeping ---------------------------------------------------function worldstate.resetTraversal(ctx, overrides)local world = ensureWorld(ctx)world.traversal = {row = 1,col = 1,forward = true,done = false,}if type(overrides) == "table" thenmergeTables(world.traversal, overrides)endctx.traverse = world.traversalreturn world.traversalendfunction worldstate.advanceTraversal(ctx)local world = ensureWorld(ctx)local tr = world.traversalif not tr thentr = worldstate.resetTraversal(ctx)endif tr.done thenreturn trendif tr.forward thenif tr.col < (world.grid.width or 1) thentr.col = tr.col + 1return trendtr.forward = falseelseif tr.col > 1 thentr.col = tr.col - 1return trendtr.forward = trueendtr.row = tr.row + 1if tr.row > (world.grid.length or 1) thentr.done = trueelsetr.col = tr.forward and 1 or (world.grid.width or 1)endreturn trendfunction worldstate.currentCellRef(ctx)local world = ensureWorld(ctx)local tr = world.traversal or worldstate.resetTraversal(ctx)return {x = (world.grid.origin.x or 0) + (tr.col - 1) * (world.grid.spacingX or 1),y = world.grid.origin.y or 0,z = (world.grid.origin.z or 0) + (tr.row - 1) * (world.grid.spacingZ or 1),}endfunction worldstate.currentCellWorld(ctx)return worldstate.referenceToWorld(ctx, worldstate.currentCellRef(ctx))endfunction worldstate.offsetFromCell(ctx, offset)offset = offset or {}local base = worldstate.currentCellRef(ctx)return {x = base.x + (offset.x or 0),y = base.y + (offset.y or 0),z = base.z + (offset.z or 0),}endfunction worldstate.currentWalkPositionRef(ctx)local world = ensureWorld(ctx)local ref = worldstate.currentCellRef(ctx)return {x = (ref.x or 0) + (world.walkway.offset or -1),y = ref.y,z = ref.z,}endfunction worldstate.currentWalkPositionWorld(ctx)return worldstate.referenceToWorld(ctx, worldstate.currentWalkPositionRef(ctx))endfunction worldstate.ensureTraversal(ctx)local world = ensureWorld(ctx)if not world.traversal thenworldstate.resetTraversal(ctx)endreturn world.traversalend-- Convenience exports -----------------------------------------------------worldstate.MOVE_OPTS_CLEAR = MOVE_OPTS_CLEARworldstate.MOVE_OPTS_SOFT = MOVE_OPTS_SOFTreturn worldstate]=========]
files['lib/log.lua'] = [=====[-- log.lua-- Tiny logger tailored for ComputerCraft turtles/computers.-- Provides leveled logging with safe file writes so crashes are easier-- to diagnose. Defaults to `arcade.log` in the working directory.-- Lua Tip: Returning a constructor function lets you keep state private-- while still exposing an easy-to-use API.local Log = {}Log.__index = Loglocal LEVELS = {error = 1,warn = 2,info = 3,debug = 4,}local function now()if os and os.date thenreturn os.date("%Y-%m-%d %H:%M:%S")endreturn "unknown-time"end---Create a new logger.---@param options table|nil {logFile:string, level:string}function Log.new(options)options = options or {}local self = setmetatable({}, Log)self.logFile = options.logFile or "arcade.log"self.threshold = LEVELS[string.lower(options.level or "info")] or LEVELS.inforeturn selfendlocal function tryWrite(path, line)local ok, err = pcall(function()local handle = fs.open(path, "a")if handle thenhandle.writeLine(line)handle.close()endend)if not ok thenreturn false, errendreturn trueend---Internal helper used by all level-specific methods.function Log:log(level, message)local numeric = LEVELS[level] or LEVELS.infoif numeric > self.threshold then return endlocal safeMessage = tostring(message)local line = string.format("[%s] %-5s %s", now(), level:upper(), safeMessage)local success, err = tryWrite(self.logFile, line)if not success and term then-- Fallback to terminal output instead of crashing the program.term.setTextColor(colors.red)print("Log write failed: " .. tostring(err))term.setTextColor(colors.white)endendfunction Log:error(message) self:log("error", message) endfunction Log:warn(message) self:log("warn", message) endfunction Log:info(message) self:log("info", message) endfunction Log:debug(message) self:log("debug", message) endreturn Log]=====]
files['lib/version.lua'] = [=======[local version = {}version.MAJOR = 2version.MINOR = 1version.PATCH = 1version.BUILD = 47--- Format version string (e.g., "v2.1.1 (build 42)")function version.toString()return string.format("v%d.%d.%d (build %d)",version.MAJOR, version.MINOR, version.PATCH, version.BUILD)end--- Format short display (e.g., "TurtleOS v2.1.1 #42")function version.display()return string.format("TurtleOS v%d.%d.%d #%d",version.MAJOR, version.MINOR, version.PATCH, version.BUILD)endreturn version]=======]
files['ui/hub.lua'] = [====[local Hub = {}

-- Small sleep shim that works in plain Lua.
local function pauseBrief()
    if type(_G.sleep) == "function" then
        pcall(_G.sleep, 0.05)
    end
end

-- Platform adapter so rendering/input can be swapped for tests.
local Platform = {}
Platform.__index = Platform

local function readLineCompat()
    if type(_G.read) == "function" then
        return _G.read()
    elseif io and io.read then
        return io.read("*l")
    end
    return nil
end

function Platform.new(opts)
    opts = opts or {}
    local self = setmetatable({}, Platform)
    self.inputs = opts.inputs or nil
    self.outputs = opts.outputs or nil
    self.echoInputs = opts.echoInputs or false
    self.inputIdx = 1
    self.headless = opts.headless or false
    self.hasTerm = type(term) == "table" and type(term.clear) == "function" and not self.headless
    self.readLine = opts.readLine or readLineCompat
    self.lineWriter = opts.writeLine or function(text)
        if io and io.write then
            io.write((text or "") .. "\n")
        end
    end
    return self
end

function Platform:nextInput()
    if self.inputs and self.inputIdx <= #self.inputs then
        local v = self.inputs[self.inputIdx]
        self.inputIdx = self.inputIdx + 1
        if self.outputs and self.echoInputs then
            table.insert(self.outputs, "> " .. tostring(v))
        end
        return v
    end
    if self.readLine then
        return self.readLine()
    end
    return nil
end

function Platform:clear()
    if self.hasTerm then
        if _G.colors then
            term.setBackgroundColor(colors.black)
            term.setTextColor(colors.white)
        end
        term.clear()
        term.setCursorPos(1, 1)
    else
        self:writeLine(string.rep("-", 40))
    end
end

function Platform:write(text)
    if self.outputs then table.insert(self.outputs, tostring(text or "")) end
    if self.hasTerm then
        io.write(text or "")
    elseif io and io.write then
        io.write(text or "")
    end
end

function Platform:writeLine(text)
    if self.outputs then table.insert(self.outputs, tostring(text or "")) end
    if self.hasTerm then
        print(text)
    else
        self.lineWriter(text or "")
    end
end

function Platform:prompt(label, default)
    local suffix = default and (" [" .. tostring(default) .. "]") or ""
    self:write(label .. suffix .. ": ")
    local resp = self:nextInput()
    if resp == nil then return default end
    resp = tostring(resp)
    if resp == "" and default ~= nil then
        return default
    end
    return resp
end

function Platform:notify(msg)
    self:writeLine(msg)
    pauseBrief()
end

function Platform:pause(msg)
    if msg then self:writeLine(msg) end
    self:writeLine("(Press Enter to continue)")
    self:nextInput()
end

Hub.Platform = Platform

local function flattenSections(sections)
    local flat = {}
    for _, section in ipairs(sections or {}) do
        if not section.hidden then
            for _, item in ipairs(section.items or {}) do
                if not item.hidden then
                    table.insert(flat, {
                        section = section,
                        item = item,
                    })
                end
            end
        end
    end
    return flat
end

local function renderScreen(ui, cfg, flat)
    ui:clear()
    ui:writeLine(cfg.title or "Arcadesys")
    if cfg.subtitle then
        ui:writeLine(cfg.subtitle)
    end
    ui:writeLine("")
    for idx, entry in ipairs(flat) do
        local label = entry.item.label or ("Item " .. idx)
        local hint = entry.item.hint and (" - " .. entry.item.hint) or ""
        ui:writeLine(string.format("%2d) [%s] %s%s", idx, entry.section.label or "Section", label, hint))
    end
    ui:writeLine(" q) Quit")
end

local function safeCall(action, ctx, ui)
    local ok, err = pcall(action, ctx, ui)
    if not ok then
        ui:notify("Action failed: " .. tostring(err))
        ui:pause()
    end
end

-- Run the interactive hub.
-- cfg = { title, subtitle, sections = { { label, items = { { label, hint, action=function(ctx,ui) end } } } }, platform }
function Hub.run(cfg)
    cfg = cfg or {}
    local ui = cfg.platform or Platform.new()
    local ctx = cfg.ctx or {}
    local running = true

    while running do
        local flat = flattenSections(cfg.sections)
        renderScreen(ui, cfg, flat)

        local choice = ui:prompt("Select option", nil)
        if not choice then return end
        local lowered = tostring(choice):lower()
        if lowered == "q" or lowered == "quit" or lowered == "exit" then
            return
        end
        local idx = tonumber(choice)
        local entry = idx and flat[idx] or nil
        if entry and type(entry.item.action) == "function" then
            safeCall(entry.item.action, ctx, ui)
        else
            ui:notify("Invalid choice")
        end
    end
end

return Hub]====]
files['ui/trash_config.lua'] = [=========[local ui = require("lib_ui")local mining = require("lib_mining")local valhelsia_blocks = require("arcade.data.valhelsia_blocks")local trash_config = {}function trash_config.run()local searchTerm = ""local scroll = 0local selectedIndex = 1local filteredBlocks = {}-- Helper to update filtered listlocal function updateFilter()filteredBlocks = {}for _, block in ipairs(valhelsia_blocks) doif searchTerm == "" orblock.label:lower():find(searchTerm:lower()) orblock.id:lower():find(searchTerm:lower()) thentable.insert(filteredBlocks, block)endendendupdateFilter()while true doui.clear()ui.drawFrame(2, 2, 48, 16, "Trash Configuration")-- Search Barui.label(4, 4, "Search: ")ui.inputText(12, 4, 30, searchTerm, true)-- List Headerui.label(4, 6, "Name")ui.label(35, 6, "Trash?")ui.drawBox(4, 7, 44, 1, colors.gray, colors.white)-- List Itemslocal listHeight = 8local maxScroll = math.max(0, #filteredBlocks - listHeight)if scroll > maxScroll then scroll = maxScroll endfor i = 1, listHeight dolocal idx = i + scrollif idx <= #filteredBlocks thenlocal block = filteredBlocks[idx]local y = 7 + ilocal isTrash = mining.TRASH_BLOCKS[block.id]local trashLabel = isTrash and "[YES]" or "[NO ]"local trashColor = isTrash and colors.red or colors.greenif i == selectedIndex thenterm.setBackgroundColor(colors.white)term.setTextColor(colors.black)elseterm.setBackgroundColor(colors.blue)term.setTextColor(colors.white)endterm.setCursorPos(4, y)local label = block.labelif #label > 30 then label = label:sub(1, 27) .. "..." endterm.write(label .. string.rep(" ", 31 - #label))term.setCursorPos(35, y)if i == selectedIndex thenterm.setTextColor(colors.black)elseterm.setTextColor(trashColor)endterm.write(trashLabel)endend-- Instructionsui.label(4, 17, "Arrows: Move/Scroll  Enter: Toggle  Esc: Save")local event, p1 = os.pullEvent()if event == "char" thensearchTerm = searchTerm .. p1updateFilter()selectedIndex = 1scroll = 0elseif event == "key" thenif p1 == keys.backspace thensearchTerm = searchTerm:sub(1, -2)updateFilter()selectedIndex = 1scroll = 0elseif p1 == keys.up thenif selectedIndex > 1 thenselectedIndex = selectedIndex - 1elseif scroll > 0 thenscroll = scroll - 1endelseif p1 == keys.down thenif selectedIndex < math.min(listHeight, #filteredBlocks) thenselectedIndex = selectedIndex + 1elseif scroll < maxScroll thenscroll = scroll + 1endelseif p1 == keys.enter thenlocal idx = selectedIndex + scrollif filteredBlocks[idx] thenlocal block = filteredBlocks[idx]if mining.TRASH_BLOCKS[block.id] thenmining.TRASH_BLOCKS[block.id] = nil -- Remove from trashelsemining.TRASH_BLOCKS[block.id] = true -- Add to trashendendelseif p1 == keys.enter or p1 == keys.escape thenmining.saveConfig()returnendendendendreturn trash_config]=========]
files['ae2_drive_monitor.lua'] = [=======[-- AE2 Drive Monitor
-- Shows ME item/fluid usage on a 2x3 advanced monitor with color, bars, and trends.
-- Requires an Advanced Peripherals ME Bridge connected to the network.

local REFRESH_SECONDS = 5
local TEXT_SCALE = 0.75 -- Larger text while still fitting a 2x3 monitor

local palette = {
    bg = colors.black,
    frame = colors.gray,
    accent = colors.cyan,
    item = colors.lime,
    fluid = colors.blue,
    energy = colors.yellow,
    warn = colors.orange,
    danger = colors.red,
    text = colors.white,
    muted = colors.lightGray,
}

local function findPeripheral(kind)
    local obj = peripheral.find(kind)
    if obj then return obj end
    error("Missing peripheral: " .. kind .. " (attach and restart)", 0)
end

local mon = findPeripheral("monitor")
local me = findPeripheral("meBridge")

mon.setTextScale(TEXT_SCALE)
mon.setBackgroundColor(palette.bg)
mon.clear()

local function fmtNumber(n)
    if type(n) ~= "number" then return "?" end
    local abs = math.abs(n)
    if abs >= 1e9 then
        return string.format("%.1fG", n / 1e9)
    elseif abs >= 1e6 then
        return string.format("%.1fM", n / 1e6)
    elseif abs >= 1e3 then
        return string.format("%.1fk", n / 1e3)
    else
        return tostring(math.floor(n + 0.5))
    end
end

local function parseStorage(tbl)
    if type(tbl) ~= "table" then return nil, nil, nil, nil end
    local used = tbl.used or tbl.stored or tbl.usage or tbl.usedBytes
    local total = tbl.total or tbl.max or tbl.capacity or tbl.totalBytes
    local usedTypes = tbl.types or tbl.usedTypes or tbl.storedTypes
    local typeCap = tbl.typeCapacity or tbl.typeCap or tbl.maxTypes or tbl.totalTypes
    if type(used) ~= "number" then used = nil end
    if type(total) ~= "number" then total = nil end
    if type(usedTypes) ~= "number" then usedTypes = nil end
    if type(typeCap) ~= "number" then typeCap = nil end
    return used, total, usedTypes, typeCap
end

local function safeCall(fn, ...)
    local ok, res = pcall(fn, ...)
    if ok then return res end
    return nil
end

local function fetchStorage(kind)
    local suffix = kind == "fluid" and "FluidStorage" or "ItemStorage"
    local used, total, usedTypes, typeCap

    used, total, usedTypes, typeCap = parseStorage(safeCall(me["get" .. suffix]))
    if not total then total = safeCall(me["getMax" .. suffix]) end
    if not used then used = safeCall(me["getUsed" .. suffix]) end
    if type(used) == "table" then
        local u, t, ut, tc = parseStorage(used)
        used = u or used
        total = t or total
        usedTypes = ut or usedTypes
        typeCap = tc or typeCap
    end
    if type(total) == "table" then
        local _, t, ut, tc = parseStorage(total)
        total = t or total
        usedTypes = ut or usedTypes
        typeCap = tc or typeCap
    end

    if type(used) ~= "number" then used = nil end
    if type(total) ~= "number" then total = nil end
    if type(usedTypes) ~= "number" then usedTypes = nil end
    if type(typeCap) ~= "number" then typeCap = nil end
    return used, total, usedTypes, typeCap
end

local itemHistory = {}
local fluidHistory = {}

local function pushHistory(history, value, maxLen)
    table.insert(history, value or 0)
    while #history > maxLen do
        table.remove(history, 1)
    end
end

local function drawHeader(w)
    mon.setBackgroundColor(palette.accent)
    mon.setTextColor(palette.bg)
    mon.setCursorPos(1, 1)
    mon.write(string.rep(" ", w))
    local title = "AE2 DRIVE STATUS"
    mon.setCursorPos(math.max(1, math.floor((w - #title) / 2)), 1)
    mon.write(title)
    mon.setBackgroundColor(palette.bg)
    mon.setTextColor(palette.text)
end

local function drawBar(y, label, used, total, color)
    local w, _ = mon.getSize()
    local pct = (used and total and total > 0) and (used / total) or 0
    pct = math.min(math.max(pct, 0), 1)
    local barWidth = math.max(6, w - 4)
    local fill = math.floor(barWidth * pct)

    mon.setCursorPos(1, y)
    mon.setTextColor(palette.muted)
    mon.clearLine()
    mon.write(label)
    local pctText = string.format("%3d%%", math.floor(pct * 100 + 0.5))
    mon.setCursorPos(w - #pctText + 1, y)
    mon.setTextColor(palette.text)
    mon.write(pctText)

    mon.setCursorPos(2, y + 1)
    mon.setBackgroundColor(palette.frame)
    mon.write(string.rep(" ", barWidth))
    mon.setCursorPos(2, y + 1)
    mon.setBackgroundColor(color)
    mon.write(string.rep(" ", fill))
    mon.setBackgroundColor(palette.bg)

    mon.setCursorPos(2, y + 2)
    mon.setTextColor(color)
    if used and total then
        mon.write(string.format("%s / %s", fmtNumber(used), fmtNumber(total)))
    elseif used then
        mon.write(fmtNumber(used))
    else
        mon.write("No data")
    end
    mon.setTextColor(palette.text)
end

local function drawTypes(y, usedTypes, typeCap)
    local w, _ = mon.getSize()
    mon.setCursorPos(1, y)
    mon.setTextColor(palette.muted)
    mon.clearLine()
    local txt
    if usedTypes and typeCap then
        txt = string.format("Item types: %s / %s", fmtNumber(usedTypes), fmtNumber(typeCap))
    elseif usedTypes then
        txt = string.format("Item types: %s", fmtNumber(usedTypes))
    else
        txt = "Item types: ?"
    end
    mon.write(txt:sub(1, w))
end

local function drawEnergy(y, energyUse, storedEnergy, maxEnergy)
    local w, _ = mon.getSize()
    mon.setCursorPos(1, y)
    mon.clearLine()
    mon.setTextColor(palette.energy)
    local line
    if energyUse and storedEnergy and maxEnergy then
        line = string.format("Energy: %s/t  %s/%s", fmtNumber(energyUse), fmtNumber(storedEnergy), fmtNumber(maxEnergy))
    elseif energyUse then
        line = string.format("Energy: %s/t", fmtNumber(energyUse))
    elseif storedEnergy and maxEnergy then
        line = string.format("Energy: %s/%s", fmtNumber(storedEnergy), fmtNumber(maxEnergy))
    else
        line = "Energy: ?"
    end
    mon.write(line:sub(1, w))
    mon.setTextColor(palette.text)
end

local ramp = { " ", ".", ":", "-", "=", "+", "*", "#", "@" }
local function drawTrend(y, label, history, color)
    local w, _ = mon.getSize()
    local maxLen = w - 2
    mon.setCursorPos(1, y)
    mon.setTextColor(palette.muted)
    mon.clearLine()
    mon.write(label)

    mon.setCursorPos(1, y + 1)
    mon.clearLine()
    local len = math.min(#history, maxLen)
    local start = #history - len + 1
    mon.setTextColor(color)
    for i = start, #history do
        local pct = history[i] or 0
        local idx = math.floor(pct * (#ramp - 1) + 1)
        idx = math.max(1, math.min(idx, #ramp))
        mon.write(ramp[idx])
    end
    mon.setTextColor(palette.text)
end

local function draw()
    local w, h = mon.getSize()
    mon.setBackgroundColor(palette.bg)
    mon.setTextColor(palette.text)
    mon.clear()

    drawHeader(w)

    local itemUsed, itemTotal, itemTypes, itemTypeCap = fetchStorage("item")
    local fluidUsed, fluidTotal = fetchStorage("fluid")
    local energyUse = safeCall(me.getEnergyUsage)
    local energyCap = safeCall(me.getEnergyStorage) -- Some versions return { stored=?, max=? }
    local storedEnergy, maxEnergy = parseStorage(energyCap)
    if type(energyUse) ~= "number" then energyUse = nil end

    local row = 3
    drawBar(row, "ITEM STORAGE", itemUsed, itemTotal, palette.item)
    drawTypes(row + 3, itemTypes, itemTypeCap)
    row = row + 4
    drawBar(row, "FLUID STORAGE", fluidUsed, fluidTotal, palette.fluid)
    row = row + 4
    drawEnergy(row, energyUse, storedEnergy, maxEnergy)
    row = row + 2

    -- Trends live near the bottom to form a mini graph for quick glances.
    local trendStart = h - 3
    local itemPct = (itemUsed and itemTotal and itemTotal > 0) and (itemUsed / itemTotal) or 0
    local fluidPct = (fluidUsed and fluidTotal and fluidTotal > 0) and (fluidUsed / fluidTotal) or 0
    pushHistory(itemHistory, itemPct, w - 2)
    pushHistory(fluidHistory, fluidPct, w - 2)
    drawTrend(trendStart, "Items trend", itemHistory, palette.item)
    drawTrend(trendStart + 2, "Fluids trend", fluidHistory, palette.fluid)

    mon.setCursorPos(1, h)
    mon.setTextColor(palette.muted)
    mon.clearLine()
    mon.write("Updated: " .. textutils.formatTime(os.time(), true))
    mon.setTextColor(palette.text)
end

while true do
    draw()
    sleep(REFRESH_SECONDS)
end]=======]
files['ae2_me_bridge_monitor.lua'] = [===[-- AE2 ME Bridge Monitor
-- Monitors AE2 storage via Advanced Peripherals meBridge.
-- Features:
--   * Item/energy/CPU overview UI on an attached monitor or terminal.
--   * Track specific items with min/max thresholds and optional auto-crafting.
--   * ChatBox/Redstone alarms with cooldowns to avoid spam.
--   * Config persisted to disk for tuning without code edits.
--
-- Place requirements nearby:
--   - meBridge attached to AE2 network.
--   - monitor (optional, for UI; computer terminal works too).
--   - chatBox (optional) for alerts.
--   - redstoneIntegrator (optional) for alarm channel.

local CONFIG_PATH = "/etc/ae2_monitor.cfg"
local POLL_TICKS = 20 -- Default poll interval (seconds ~= ticks on computers)
local ALERT_COOLDOWN = 60

local function findPeripheral(kind)
    local obj = peripheral.find(kind)
    if obj then return obj end
    error("Missing peripheral: " .. kind .. " (attach and restart)", 0)
end

local me = findPeripheral("meBridge")
local mon = peripheral.find("monitor")
local chat = peripheral.find("chatBox")
local rsInt = peripheral.find("redstoneIntegrator")

local cfg = {
    poll = POLL_TICKS,
    track = {
        -- ["minecraft:redstone"] = { min = 1024, max = 32768, autocraft = false },
    },
    redstone = {
        side = "front",
        mode = "pulse", -- "pulse" or "hold"
    },
    alerts = true,
}

local function loadConfig()
    if not fs.exists(CONFIG_PATH) then return end
    local ok, data = pcall(function()
        local h = fs.open(CONFIG_PATH, "r")
        if not h then return nil end
        local text = h.readAll()
        h.close()
        return text and textutils.unserialize(text)
    end)
    if ok and type(data) == "table" then
        for k, v in pairs(data) do
            cfg[k] = v
        end
    end
end

local function saveConfig()
    fs.makeDir(fs.getDir(CONFIG_PATH))
    local h = fs.open(CONFIG_PATH, "w")
    if not h then return end
    h.write(textutils.serialize(cfg))
    h.close()
end

local function fmtNumber(n)
    if type(n) ~= "number" then return "?" end
    local abs = math.abs(n)
    if abs >= 1e9 then
        return string.format("%.1fG", n / 1e9)
    elseif abs >= 1e6 then
        return string.format("%.1fM", n / 1e6)
    elseif abs >= 1e3 then
        return string.format("%.1fk", n / 1e3)
    else
        return tostring(math.floor(n + 0.5))
    end
end

local function debounceLog(lastTimes, key, cooldown)
    local now = os.epoch("utc") / 1000
    if not lastTimes[key] or now - lastTimes[key] >= cooldown then
        lastTimes[key] = now
        return true
    end
    return false
end

local function sendAlert(message, color)
    if not cfg.alerts then return end
    if chat then
        chat.sendMessage(message)
    end
    if rsInt then
        if cfg.redstone.mode == "pulse" then
            rsInt.setOutput(cfg.redstone.side, true)
            sleep(0.2)
            rsInt.setOutput(cfg.redstone.side, false)
        else
            rsInt.setOutput(cfg.redstone.side, true)
        end
    end
    if mon then
        mon.setTextColor(color or colors.red)
        local w, h = mon.getSize()
        mon.setCursorPos(1, h)
        mon.clearLine()
        mon.write(message:sub(1, w))
        mon.setTextColor(colors.white)
    end
    print(message)
end

local function clearRedstone()
    if rsInt and cfg.redstone.mode == "hold" then
        rsInt.setOutput(cfg.redstone.side, false)
    end
end

local function fetchSummary()
    local summary = {
        items = me.getItemStorage(),
        fluids = me.getFluidStorage and me.getFluidStorage() or nil,
        energy = me.getEnergyStorage and me.getEnergyStorage() or nil,
        usage = me.getEnergyUsage and me.getEnergyUsage() or nil,
        cpus = me.getCraftingCPUs and me.getCraftingCPUs() or nil,
    }
    return summary
end

local function getTrackedCounts()
    local items = {}
    for name, rule in pairs(cfg.track) do
        local detail = me.getItem({ name = name })
        local count = detail and detail.amount or 0
        items[name] = { count = count, rule = rule }
    end
    return items
end

local function requestCraft(name, rule)
    if not rule.autocraft then return false end
    if not me.requestCrafting then return false end
    local craftAmount = math.max(1, (rule.min or 0) * 2)
    local ok, err = pcall(function()
        return me.requestCrafting({ name = name, count = craftAmount })
    end)
    if not ok then
        print("Craft failed for " .. name .. ": " .. tostring(err))
        return false
    end
    return true
end

local function drawUI(summary, tracked)
    local w, h
    if mon then
        mon.setTextScale(0.5)
        mon.setBackgroundColor(colors.black)
        mon.setTextColor(colors.white)
        mon.clear()
        mon.setCursorPos(1, 1)
        w, h = mon.getSize()
    else
        term.clear()
        term.setCursorPos(1, 1)
        w, h = term.getSize()
    end

    local function writeLine(y, text, color)
        if mon then
            mon.setCursorPos(1, y)
            mon.setTextColor(color or colors.white)
            mon.clearLine()
            mon.write(text:sub(1, w))
        else
            term.setCursorPos(1, y)
            term.clearLine()
            term.setTextColor(color or colors.white)
            term.write(text:sub(1, w))
        end
    end

    writeLine(1, "AE2 MONITOR (" .. textutils.formatTime(os.time(), true) .. ")", colors.cyan)

    local itemUsed = summary.items and summary.items.used or summary.items and summary.items.stored
    local itemTotal = summary.items and summary.items.total or summary.items and summary.items.max or summary.items and summary.items.capacity
    writeLine(3, string.format("Items: %s / %s", fmtNumber(itemUsed), fmtNumber(itemTotal)), colors.lime)

    if summary.fluids then
        local fluidUsed = summary.fluids.used or summary.fluids.stored
        local fluidTotal = summary.fluids.total or summary.fluids.max or summary.fluids.capacity
        writeLine(4, string.format("Fluids: %s / %s", fmtNumber(fluidUsed), fmtNumber(fluidTotal)), colors.lightBlue)
    else
        writeLine(4, "Fluids: (bridge lacks fluid methods)", colors.lightGray)
    end

    local energyStored = summary.energy and (summary.energy.stored or summary.energy.used)
    local energyMax = summary.energy and (summary.energy.max or summary.energy.total or summary.energy.capacity)
    if energyStored and energyMax then
        writeLine(5, string.format("Energy: %s / %s", fmtNumber(energyStored), fmtNumber(energyMax)), colors.yellow)
    else
        writeLine(5, "Energy: " .. fmtNumber(summary.usage) .. "/t", colors.yellow)
    end

    local cpuCount = summary.cpus and #summary.cpus or 0
    local busy = 0
    if summary.cpus then
        for _, cpu in ipairs(summary.cpus) do
            if cpu.busy then busy = busy + 1 end
        end
    end
    writeLine(6, string.format("Crafting CPUs: %d total, %d busy", cpuCount, busy), colors.orange)

    writeLine(8, "Tracked:", colors.white)
    local row = 9
    for name, data in pairs(tracked) do
        if row > h then break end
        local rule = data.rule
        local warn = (rule.min and data.count < rule.min) or (rule.max and data.count > rule.max)
        local color = warn and colors.red or colors.white
        local ruleText = string.format("min %s max %s", rule.min or "-", rule.max or "-")
        writeLine(row, string.format("%s: %s (%s)", name, fmtNumber(data.count), ruleText), color)
        row = row + 1
    end
end

local function printHelp()
    print("Commands:")
    print("  watch <item> <min> [max] [autocraft:true|false]")
    print("  unwatch <item>")
    print("  poll <seconds>")
    print("  alerts <on|off>")
    print("  side <left|right|front|back|top|bottom>")
    print("  mode <pulse|hold>")
    print("  help")
end

loadConfig()

local lastAlert = {}
local function evaluate(tracked)
    for name, data in pairs(tracked) do
        local rule = data.rule
        if rule.min and data.count < rule.min then
            if debounceLog(lastAlert, name .. ":low", ALERT_COOLDOWN) then
                sendAlert(string.format("[AE] Low %s: %s / %s (min)", name, fmtNumber(data.count), fmtNumber(rule.min)))
                requestCraft(name, rule)
            end
        elseif rule.max and data.count > rule.max then
            if debounceLog(lastAlert, name .. ":high", ALERT_COOLDOWN) then
                sendAlert(string.format("[AE] High %s: %s / %s (max)", name, fmtNumber(data.count), fmtNumber(rule.max)))
            end
        else
            clearRedstone()
        end
    end
end

local function commandLoop()
    while true do
        io.write("> ")
        local line = read()
        if not line then break end
        local args = {}
        for part in string.gmatch(line, "%S+") do
            table.insert(args, part)
        end
        local cmd = args[1]
        if cmd == "watch" and args[2] and args[3] then
            local item = args[2]
            local min = tonumber(args[3])
            local max = args[4] and tonumber(args[4]) or nil
            local autocraft = args[5] == "true"
            cfg.track[item] = { min = min, max = max, autocraft = autocraft }
            saveConfig()
            print("Watching " .. item)
        elseif cmd == "unwatch" and args[2] then
            cfg.track[args[2]] = nil
            saveConfig()
            print("Stopped watching " .. args[2])
        elseif cmd == "poll" and args[2] then
            cfg.poll = tonumber(args[2]) or cfg.poll
            saveConfig()
            print("Poll set to " .. tostring(cfg.poll))
        elseif cmd == "alerts" and args[2] then
            cfg.alerts = args[2] == "on"
            saveConfig()
            print("Alerts " .. (cfg.alerts and "on" or "off"))
        elseif cmd == "side" and args[2] then
            cfg.redstone.side = args[2]
            saveConfig()
            print("Redstone side " .. args[2])
        elseif cmd == "mode" and args[2] then
            cfg.redstone.mode = args[2]
            saveConfig()
            print("Redstone mode " .. args[2])
        elseif cmd == "help" then
            printHelp()
        elseif cmd == "" or cmd == nil then
            -- ignore
        else
            print("Unknown command. Type 'help'.")
        end
    end
end

local function main()
    local lastPoll = 0
    parallel.waitForAny(function()
        while true do
            local now = os.clock()
            if now - lastPoll >= (cfg.poll or POLL_TICKS) then
                local summary = fetchSummary()
                local tracked = getTrackedCounts()
                drawUI(summary, tracked)
                evaluate(tracked)
                lastPoll = now
            end
            sleep(0.5)
        end
    end, commandLoop)
end

print("AE2 monitor starting...")
print("Type 'help' for commands.")
main()]===]
files['arcadesys_os.lua'] = [=========[---@diagnostic disable: undefined-global

local VERSION = "2.0.2"

if type(package) ~= "table" then package = { path = "" } end
if type(package.path) ~= "string" then package.path = package.path or "" end
package.loaded = package.loaded or {}

local upstreamRequire = _G.require

local function requireCompat(name)
    if package.loaded[name] ~= nil then return package.loaded[name] end
    if upstreamRequire and upstreamRequire ~= requireCompat then
        local result = upstreamRequire(name)
        package.loaded[name] = result
        return result
    end

    local lastErr
    for pattern in string.gmatch(package.path or "", "([^;]+)") do
        local candidate = pattern:gsub("%?", name)
        if fs.exists(candidate) and not fs.isDir(candidate) then
            local fn, err = loadfile(candidate)
            if not fn then
                lastErr = err
            else
                local ok, res = pcall(fn)
                if not ok then
                    lastErr = res
                else
                    package.loaded[name] = res
                    return res
                end
            end
        end
    end
    error(string.format("module '%s' not found%s", name, lastErr and (": " .. tostring(lastErr)) or ""))
end

_G.require = _G.require or requireCompat

local DEFAULT_MANIFEST_URL =
    "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/manifest.json"

local function ensurePackagePaths(baseDir)
    local root = baseDir == "" and "/" or baseDir
    local paths = {
        "/?.lua",
        "/lib/?.lua",
        fs.combine(root, "?.lua"),
        fs.combine(root, "lib/?.lua"),
        fs.combine(root, "arcade/?.lua"),
        fs.combine(root, "arcade/ui/?.lua"),
        fs.combine(root, "factory/?.lua"),
        fs.combine(root, "ui/?.lua"),
        fs.combine(root, "tools/?.lua"),
    }

    -- Rebuild path with guaranteed leading entries, plus any existing paths.
    local current = package.path or ""
    if current ~= "" then table.insert(paths, current) end
    -- Deduplicate while preserving order.
    local seen, final = {}, {}
    for _, p in ipairs(paths) do
        if p and p ~= "" and not seen[p] then
            seen[p] = true
            table.insert(final, p)
        end
    end
    package.path = table.concat(final, ";")
end

local function detectBaseDir()
    if shell and shell.getRunningProgram then
        return fs.getDir(shell.getRunningProgram())
    end
    if debug and debug.getinfo then
        local info = debug.getinfo(1, "S")
        if info and info.source then
            local src = info.source
            if src:sub(1, 1) == "@" then src = src:sub(2) end
            return fs.getDir(src)
        end
    end
    return ""
end

local function readAll(handle)
    local content = handle.readAll()
    handle.close()
    return content
end

local function fetch(url)
    if not http then
        return nil, "HTTP API is disabled"
    end

    local response, err = http.get(url)
    if not response then
        return nil, err or "unknown HTTP error"
    end

    return readAll(response)
end

local function decodeJson(payload)
    local ok, result = pcall(textutils.unserializeJSON, payload)
    if not ok then
        return nil, "Invalid JSON: " .. tostring(result)
    end
    return result
end

local function sanitizeManifest(manifest)
    if type(manifest) ~= "table" then
        return nil, "Manifest is not a table"
    end
    if type(manifest.files) ~= "table" or #manifest.files == 0 then
        return nil, "Manifest contains no files"
    end
    return manifest
end

local function loadManifest(url)
    if not url then
        return nil, "No manifest URL provided"
    end

    local body, err = fetch(url)
    if not body then
        return nil, err
    end

    local manifest, decodeErr = decodeJson(body)
    if not manifest then
        return nil, decodeErr
    end

    local valid, reason = sanitizeManifest(manifest)
    if not valid then
        return nil, reason
    end

    return manifest
end

local function downloadFiles(manifest)
    local bundle = {
        name = manifest.name or "Arcadesys",
        version = manifest.version or "unknown",
        files = {},
    }

    for _, file in ipairs(manifest.files) do
        if not file.path then
            return nil, "File entry missing 'path'"
        end

        if file.content then
            table.insert(bundle.files, { path = file.path, content = file.content })
        elseif file.url then
            local data, err = fetch(file.url)
            if not data then
                return nil, err or ("Failed to download " .. file.url)
            end
            table.insert(bundle.files, { path = file.path, content = data })
        else
            return nil, "File entry for " .. file.path .. " needs 'url' or 'content'"
        end
    end

    return bundle
end

local function writeFile(path, content)
    local dir = fs.getDir(path)
    if dir ~= "" then
        fs.makeDir(dir)
    end

    local handle = fs.open(path, "wb") or fs.open(path, "w")
    if not handle then
        error("Unable to write to " .. path)
    end

    handle.write(content or "")
    handle.close()
end

local function performUpdate(ui)
    if not http then
        ui:notify("Update requires HTTP; enable it in the ComputerCraft config.")
        return
    end

    ui:notify("Checking for updates...")
    local manifest, err = loadManifest(DEFAULT_MANIFEST_URL)
    if not manifest then
        ui:notify("Manifest error: " .. tostring(err))
        return
    end

    local bundle, downloadErr = downloadFiles(manifest)
    if not bundle then
        ui:notify("Download failed: " .. tostring(downloadErr))
        return
    end

    ui:notify(string.format("Installing %s (%s)...", bundle.name, bundle.version))
    for _, file in ipairs(bundle.files) do
        writeFile(file.path, file.content)
    end

    ui:notify("Update complete. Designs and saved work were left untouched.")
end

local function logError(msg)
    local stamp = textutils and textutils.formatTime and textutils.formatTime(os.epoch and os.epoch("utc") / 1000 or 0, true)
        or tostring(os.time and os.time() or "")
    local line = string.format("[%s] %s", stamp, msg)
    local f = fs.open("/arcadesys_error.log", "a")
    if f then
        f.writeLine(line)
        f.close()
    end
end

local baseDir = detectBaseDir()
ensurePackagePaths(baseDir == "" and "/" or baseDir)

local okBoot, boot = pcall(require, "arcade.boot")
if okBoot and type(boot) == "table" and boot.setupPaths then
    pcall(boot.setupPaths)
end

print(string.format("Arcadesys %s - launching Turtle UI", VERSION))

local function runProgram(path, ui, ...)
    local args = { ... }
    local function go()
        local fn, loadErr = loadfile(path)
        if not fn then
            error("Unable to load " .. path .. ": " .. tostring(loadErr))
        end
        _G.arg = args
        return fn(table.unpack(args))
    end

    local ok, err = pcall(go)
    if not ok then
        local msg = "Failed to run " .. path .. ": " .. tostring(err)
        logError(msg)
        if ui and ui.notify then
            ui:notify(msg)
            ui:pause("(Press Enter to return)")
        else
            print(msg)
            if _G.read then
                print("(Press Enter to continue)")
                pcall(read)
            elseif _G.sleep then
                sleep(2)
            end
        end
    end
end

local function installMockTurtle()
    local original = _G.turtle
    if type(original) == "table" then return function() end end

    local function okReturn()
        return true
    end

    local function detectReturn()
        return false
    end

    local function inspectReturn()
        return true, { name = "minecraft:air", state = {}, tags = {} }
    end

    local stub = {
        forward = okReturn,
        back = okReturn,
        up = okReturn,
        down = okReturn,
        turnLeft = okReturn,
        turnRight = okReturn,
        dig = okReturn,
        digUp = okReturn,
        digDown = okReturn,
        place = okReturn,
        placeUp = okReturn,
        placeDown = okReturn,
        attack = okReturn,
        attackUp = okReturn,
        attackDown = okReturn,
        select = okReturn,
        getSelectedSlot = function() return 1 end,
        compare = okReturn,
        compareUp = okReturn,
        compareDown = okReturn,
        compareTo = okReturn,
        transferTo = okReturn,
        drop = okReturn,
        dropUp = okReturn,
        dropDown = okReturn,
        suck = okReturn,
        suckUp = okReturn,
        suckDown = okReturn,
        detect = detectReturn,
        detectUp = detectReturn,
        detectDown = detectReturn,
        inspect = inspectReturn,
        inspectUp = inspectReturn,
        inspectDown = inspectReturn,
        getItemDetail = function() return nil end,
        getItemCount = function() return 0 end,
        getItemSpace = function() return 64 end,
        getItemLimit = function() return 64 end,
        getFuelLevel = function() return math.huge end,
        getFuelLimit = function() return math.huge end,
        refuel = okReturn,
        craft = okReturn,
        equipLeft = okReturn,
        equipRight = okReturn,
    }

    setmetatable(stub, { __index = function()
        return okReturn
    end })

    _G.turtle = stub
    return function()
        _G.turtle = original
    end
end

local function maybe(label, path, hint)
    if not fs.exists(path) then return nil end
    return {
        label = label,
        hint = hint,
        action = function(_, ui)
            ui:notify("Launching " .. label .. "...")
            runProgram(path, ui)
        end
    }
end

local isTurtle = type(_G.turtle) == "table"

local function launchTurtleUi()
    local cleanup
    if not isTurtle then
        cleanup = installMockTurtle()
    end

    if fs.exists("factory/turtle_os.lua") then
        runProgram("factory/turtle_os.lua")
    elseif fs.exists("/factory/turtle_os.lua") then
        runProgram("/factory/turtle_os.lua")
    else
        print("Turtle UI missing. Try running 'Update Arcadesys' or reinstall.")
        if _G.read then
            print("(Press Enter to continue)")
            pcall(read)
        elseif _G.sleep then
            sleep(2)
        end
    end

    if cleanup then cleanup() end
end

launchTurtleUi()]=========]
files['factory_planner.lua'] = [=====[---@diagnostic disable: undefined-global, undefined-field-- Factory Designer Launcher-- Thin wrapper around lib_designer so players always get the full feature set.local function ensurePackagePath()if not package or type(package.path) ~= "string" thenpackage = package or {}package.path = package.path or ""endif not string.find(package.path, "/lib/?.lua", 1, true) thenpackage.path = package.path .. ";/?.lua;/lib/?.lua;/factory/?.lua;/arcade/?.lua"endendensurePackagePath()local designer = require("lib_designer")local parser = require("lib_parser")local args = { ... }local function printUsage()print([[Factory DesignerUsage: factory_planner.lua [--load <schema-file>] [--farm <tree|potato>] [--help]Controls are available inside the designer (press M for menu).]])endlocal function resolveSchemaPath(rawPath)if fs.exists(rawPath) thenreturn rawPathendif fs.exists(rawPath .. ".json") thenreturn rawPath .. ".json"endif fs.exists(rawPath .. ".txt") thenreturn rawPath .. ".txt"endreturn rawPathendlocal function loadInitialSchema(path)local resolved = resolveSchemaPath(path)if not fs.exists(resolved) thenprint("Warning: schema file not found: " .. resolved)return nilendlocal ok, schema, metadata = parser.parseFile(nil, resolved)if not ok thenprint("Failed to load schema: " .. tostring(schema))return nilendprint("Loaded schema: " .. resolved)return {schema = schema,metadata = metadata,}endlocal function main()local config, handled = parseArgs()if handled then return endlocal runOpts = {}if config and config.loadPath thenlocal initial = loadInitialSchema(config.loadPath)if initial thenrunOpts.schema = initial.schemarunOpts.metadata = initial.metadataendendif config and config.farmType thenif config.farmType == "tree" thenrunOpts.meta = { mode = "treefarm" }runOpts.palette = {{ id = "minecraft:stone_bricks", color = colors.gray, sym = "#" },{ id = "minecraft:dirt", color = colors.brown, sym = "D" },{ id = "minecraft:oak_sapling", color = colors.green, sym = "S" },{ id = "minecraft:torch", color = colors.yellow, sym = "i" },{ id = "minecraft:chest", color = colors.orange, sym = "C" },}elseif config.farmType == "potato" thenrunOpts.meta = { mode = "potatofarm" }runOpts.palette = {{ id = "minecraft:stone_bricks", color = colors.gray, sym = "#" },{ id = "minecraft:dirt", color = colors.brown, sym = "D" },{ id = "minecraft:water_bucket", color = colors.blue, sym = "W" },{ id = "minecraft:potato", color = colors.yellow, sym = "P" },{ id = "minecraft:chest", color = colors.orange, sym = "C" },}elseprint("Unknown farm type: " .. config.farmType)returnendendlocal ok, err = pcall(designer.run, runOpts)if not ok thenprint("Designer crashed: " .. tostring(err))endendmain()]=====]

-- Installer Logic
print('Installing files (Part 3)...')
for path, content in pairs(files) do
    local dir = fs.getDir(path)
    if not fs.exists(dir) then
        fs.makeDir(dir)
    end
    local f = fs.open(path, 'w')
    f.write(content)
    f.close()
    print('Installed: ' .. path)
end
print('Part 3 complete.')
print('Run the next part if available.')
