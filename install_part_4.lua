--[[ Local Installer Part 4 generated by bundle.ps1 ]]
local files = {}

files['install.lua'] = [=========[local tArgs = { ... }-- Change this to point at your canonical Workstation manifest.local DEFAULT_MANIFEST_URL ="https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/manifest.json"-- Minimal offline image that keeps the computer usable even if remote-- downloads fail.local EMBEDDED_IMAGE = {name = "Workstation",version = "embedded",files = {}}local function addEmbeddedFile(path, content)table.insert(EMBEDDED_IMAGE.files, { path = path, content = content })end-- START_EMBEDDED_FILESaddEmbeddedFile("startup.lua", [[local version = "Workstation (embedded)"term.clear()term.setCursorPos(1, 1)print(version)print("Booting...")local home = "home.lua"if fs.exists(home) thenshell.run(home)elseprint("Home program missing.")end]])addEmbeddedFile("home.lua", [[local version = "Workstation (embedded)"term.clear()term.setCursorPos(1, 1)print(version)print(string.rep("-", string.len(version)))print("This is the built-in rescue image installed by install.lua.")print("Replace it by running the installer with a proper manifest URL.")print()print("Suggestions:")print(" - Verify HTTP is enabled in your ComputerCraft/CC:Tweaked config.")print(" - Run: install <https://your.domain/manifest.json>")print()print("Shell available below. Type 'reboot' when finished.")print()shell.run("shell")]])addEmbeddedFile("factory/schema_farm_tree.txt", [[legend:. = minecraft:airD = minecraft:dirtS = minecraft:oak_sapling# = minecraft:stone_bricksmeta:mode = treefarmlayer:0######DDD##DDD##DDD######layer:1......S.S.......S.S......]])addEmbeddedFile("factory/schema_farm_potato.txt", [[legend:. = minecraft:airD = minecraft:dirtW = minecraft:water_bucketP = minecraft:potatoes# = minecraft:stone_bricksmeta:mode = potatofarmlayer:0######DDD##DWD##DDD######layer:1......PPP..P.P..PPP......]])addEmbeddedFile("factory_planner.lua", [=[---@diagnostic disable: undefined-global, undefined-field-- Factory Designer Launcher-- Thin wrapper around lib_designer so players always get the full feature set.local function ensurePackagePath()if not package or type(package.path) ~= "string" thenpackage = package or {}package.path = package.path or ""endif not string.find(package.path, "/lib/?.lua", 1, true) thenpackage.path = package.path .. ";/?.lua;/lib/?.lua;/factory/?.lua;/arcade/?.lua"endendensurePackagePath()local designer = require("lib_designer")local parser = require("lib_parser")local args = { ... }local function printUsage()print([[Factory DesignerUsage: factory_planner.lua [--load <schema-file>] [--farm <tree|potato>] [--help]Controls are available inside the designer (press M for menu).]])endlocal function resolveSchemaPath(rawPath)if fs.exists(rawPath) thenreturn rawPathendif fs.exists(rawPath .. ".json") thenreturn rawPath .. ".json"endif fs.exists(rawPath .. ".txt") thenreturn rawPath .. ".txt"endreturn rawPathendlocal function loadInitialSchema(path)local resolved = resolveSchemaPath(path)if not fs.exists(resolved) thenprint("Warning: schema file not found: " .. resolved)return nilendlocal ok, schema, metadata = parser.parseFile(nil, resolved)if not ok thenprint("Failed to load schema: " .. tostring(schema))return nilendprint("Loaded schema: " .. resolved)return {schema = schema,metadata = metadata,}endlocal function main()local config, handled = parseArgs()if handled then return endlocal runOpts = {}if config and config.loadPath thenlocal initial = loadInitialSchema(config.loadPath)if initial thenrunOpts.schema = initial.schemarunOpts.metadata = initial.metadataendendif config and config.farmType thenif config.farmType == "tree" thenrunOpts.meta = { mode = "treefarm" }runOpts.palette = {{ id = "minecraft:stone_bricks", color = colors.gray, sym = "#" },{ id = "minecraft:dirt", color = colors.brown, sym = "D" },{ id = "minecraft:oak_sapling", color = colors.green, sym = "S" },{ id = "minecraft:torch", color = colors.yellow, sym = "i" },{ id = "minecraft:chest", color = colors.orange, sym = "C" },}elseif config.farmType == "potato" thenrunOpts.meta = { mode = "potatofarm" }runOpts.palette = {{ id = "minecraft:stone_bricks", color = colors.gray, sym = "#" },{ id = "minecraft:dirt", color = colors.brown, sym = "D" },{ id = "minecraft:water_bucket", color = colors.blue, sym = "W" },{ id = "minecraft:potato", color = colors.yellow, sym = "P" },{ id = "minecraft:chest", color = colors.orange, sym = "C" },}elseprint("Unknown farm type: " .. config.farmType)returnendendlocal ok, err = pcall(designer.run, runOpts)if not ok thenprint("Designer crashed: " .. tostring(err))endendmain()]=])addEmbeddedFile("lib/version.lua", [=[local version = {}version.MAJOR = 2version.MINOR = 1version.PATCH = 1version.BUILD = 47--- Format version string (e.g., "v2.1.1 (build 42)")function version.toString()return string.format("v%d.%d.%d (build %d)",version.MAJOR, version.MINOR, version.PATCH, version.BUILD)end--- Format short display (e.g., "TurtleOS v2.1.1 #42")function version.display()return string.format("TurtleOS v%d.%d.%d #%d",version.MAJOR, version.MINOR, version.PATCH, version.BUILD)endreturn version]=])addEmbeddedFile("lib/lib_json.lua", [=[---@diagnostic disable: undefined-globallocal json_utils = {}function json_utils.encode(data)if textutils and textutils.serializeJSON thenreturn textutils.serializeJSON(data)endreturn nil, "json_encoder_unavailable"endfunction json_utils.decodeJson(text)if type(text) ~= "string" thenreturn nil, "invalid_json"endif textutils and textutils.unserializeJSON thenlocal ok, result = pcall(textutils.unserializeJSON, text)if ok and result ~= nil thenreturn resultendreturn nil, "json_parse_failed"endlocal ok, json = pcall(require, "json")if ok and type(json) == "table" and type(json.decode) == "function" thenlocal okDecode, result = pcall(json.decode, text)if okDecode thenreturn resultendreturn nil, "json_parse_failed"endreturn nil, "json_decoder_unavailable"endreturn json_utils]=])addEmbeddedFile("lib/lib_ui.lua", [=[local ui = {}local colors_bg = colors.bluelocal colors_fg = colors.whitelocal colors_btn = colors.lightGraylocal colors_btn_text = colors.blacklocal colors_input = colors.blacklocal colors_input_text = colors.whitefunction ui.clear()term.setBackgroundColor(colors_bg)term.setTextColor(colors_fg)term.clear()endfunction ui.drawBox(x, y, w, h, bg, fg)term.setBackgroundColor(bg)term.setTextColor(fg)for i = 0, h - 1 doterm.setCursorPos(x, y + i)term.write(string.rep(" ", w))endendfunction ui.drawFrame(x, y, w, h, title)ui.drawBox(x, y, w, h, colors.gray, colors.white)ui.drawBox(x + 1, y + 1, w - 2, h - 2, colors_bg, colors_fg)-- Shadowterm.setBackgroundColor(colors.black)for i = 1, h doterm.setCursorPos(x + w, y + i)term.write(" ")endfor i = 1, w doterm.setCursorPos(x + i, y + h)term.write(" ")endif title thenterm.setCursorPos(x + 2, y + 1)term.setBackgroundColor(colors.white)term.setTextColor(colors.black)term.write(" " .. title .. " ")endendfunction ui.button(x, y, text, active)term.setCursorPos(x, y)if active thenterm.setBackgroundColor(colors.white)term.setTextColor(colors.black)elseterm.setBackgroundColor(colors_btn)term.setTextColor(colors_btn_text)endterm.write(" " .. text .. " ")endfunction ui.label(x, y, text)term.setCursorPos(x, y)term.setBackgroundColor(colors_bg)term.setTextColor(colors_fg)term.write(text)endfunction ui.inputText(x, y, width, value, active)term.setCursorPos(x, y)term.setBackgroundColor(colors_input)term.setTextColor(colors_input_text)local display = value or ""if #display > width thendisplay = display:sub(-width)endterm.write(display .. string.rep(" ", width - #display))if active thenterm.setCursorPos(x + #display, y)term.setCursorBlink(true)elseterm.setCursorBlink(false)endendfunction ui.drawPreview(schema, x, y, w, h)-- Find boundslocal minX, maxX, minZ, maxZ = 9999, -9999, 9999, -9999for sx, row in pairs(schema) dolocal nx = tonumber(sx)if nx thenif nx < minX then minX = nx endif nx > maxX then maxX = nx endfor sy, col in pairs(row) dofor sz, block in pairs(col) dolocal nz = tonumber(sz)if nz thenif nz < minZ then minZ = nz endif nz > maxZ then maxZ = nz endendendendendendif minX > maxX then return end -- Empty schemalocal scaleX = w / (maxX - minX + 1)local scaleZ = h / (maxZ - minZ + 1)local scale = math.min(scaleX, scaleZ, 1) -- Keep aspect ratio, max 1:1-- Draw backgroundterm.setBackgroundColor(colors.black)for i = 0, h - 1 doterm.setCursorPos(x, y + i)term.write(string.rep(" ", w))end-- Draw blocksfor sx, row in pairs(schema) dolocal nx = tonumber(sx)if nx thenfor sy, col in pairs(row) dofor sz, block in pairs(col) dolocal nz = tonumber(sz)if nz then-- Map to screenlocal scrX = math.floor((nx - minX) * scale) + xlocal scrY = math.floor((nz - minZ) * scale) + yif scrX >= x and scrX < x + w and scrY >= y and scrY < y + h thenterm.setCursorPos(scrX, scrY)-- Color mappinglocal mat = block.materiallocal color = colors.graylocal char = " "if mat:find("water") then color = colors.blueelseif mat:find("log") then color = colors.brownelseif mat:find("leaves") then color = colors.greenelseif mat:find("sapling") then color = colors.green; char = "T"elseif mat:find("sand") then color = colors.yellowelseif mat:find("dirt") then color = colors.brownelseif mat:find("grass") then color = colors.greenelseif mat:find("stone") then color = colors.lightGrayelseif mat:find("cane") then color = colors.lime; char = "!"elseif mat:find("potato") then color = colors.orange; char = "."elseif mat:find("torch") then color = colors.orange; char = "i"endterm.setBackgroundColor(color)if color == colors.black then term.setTextColor(colors.white) else term.setTextColor(colors.black) endterm.write(char)endendendendendendend-- Simple Event Loop for a Form-- form = { title = "", elements = { {type="button", x=, y=, text=, id=}, ... } }function ui.runForm(form)local w, h = term.getSize()local fw, fh = math.floor(w * 0.8), math.floor(h * 0.8)local fx, fy = math.floor((w - fw) / 2) + 1, math.floor((h - fh) / 2) + 1local running = truelocal result = nillocal activeInput = nil-- Identify focusable elementslocal focusableIndices = {}for i, el in ipairs(form.elements) doif el.type == "input" or el.type == "button" thentable.insert(focusableIndices, i)endendlocal currentFocusIndex = 1if #focusableIndices > 0 thenlocal el = form.elements[focusableIndices[currentFocusIndex]]if el.type == "input" then activeInput = el endendwhile running doui.clear()ui.drawFrame(fx, fy, fw, fh, form.title)-- Custom Drawif form.onDraw thenform.onDraw(fx, fy, fw, fh)end-- Draw elementsfor i, el in ipairs(form.elements) dolocal ex, ey = fx + el.x, fy + el.ylocal isFocused = falseif #focusableIndices > 0 and focusableIndices[currentFocusIndex] == i thenisFocused = trueendif el.type == "button" thenui.button(ex, ey, el.text, isFocused)elseif el.type == "label" thenui.label(ex, ey, el.text)elseif el.type == "input" thenui.inputText(ex, ey, el.width, el.value, activeInput == el or isFocused)endendlocal event, p1, p2, p3 = os.pullEvent()if event == "mouse_click" thenlocal btn, mx, my = p1, p2, p3local clickedSomething = falsefor i, el in ipairs(form.elements) dolocal ex, ey = fx + el.x, fy + el.yif el.type == "button" thenif my == ey and mx >= ex and mx < ex + #el.text + 2 thenui.button(ex, ey, el.text, true) -- Flashsleep(0.1)if el.callback thenlocal res = el.callback(form)if res then return res endendclickedSomething = true-- Update focusfor fi, idx in ipairs(focusableIndices) doif idx == i then currentFocusIndex = fi; break endendactiveInput = nilendelseif el.type == "input" thenif my == ey and mx >= ex and mx < ex + el.width thenactiveInput = elclickedSomething = true-- Update focusfor fi, idx in ipairs(focusableIndices) doif idx == i then currentFocusIndex = fi; break endendendendendif not clickedSomething thenactiveInput = nilendelseif event == "char" and activeInput thenif not activeInput.stepper thenactiveInput.value = (activeInput.value or "") .. p1endelseif event == "key" thenlocal key = p1local focusedEl = (#focusableIndices > 0) and form.elements[focusableIndices[currentFocusIndex]] or nillocal function adjustStepper(el, delta)if not el or not el.stepper then return endlocal step = el.step or 1local current = tonumber(el.value) or 0local nextVal = current + (delta * step)if el.min then nextVal = math.max(el.min, nextVal) endif el.max then nextVal = math.min(el.max, nextVal) endel.value = tostring(nextVal)endif key == keys.backspace and activeInput thenlocal val = activeInput.value or ""if #val > 0 thenactiveInput.value = val:sub(1, -2)endelseif (key == keys.left or key == keys.right) and focusedEl and focusedEl.stepper thenlocal delta = key == keys.left and -1 or 1adjustStepper(focusedEl, delta)activeInput = nilelseif key == keys.tab or key == keys.down thenif #focusableIndices > 0 thencurrentFocusIndex = currentFocusIndex + 1if currentFocusIndex > #focusableIndices then currentFocusIndex = 1 endlocal el = form.elements[focusableIndices[currentFocusIndex]]activeInput = (el.type == "input") and el or nilendelseif key == keys.up thenif #focusableIndices > 0 thencurrentFocusIndex = currentFocusIndex - 1if currentFocusIndex < 1 then currentFocusIndex = #focusableIndices endlocal el = form.elements[focusableIndices[currentFocusIndex]]activeInput = (el.type == "input") and el or nilendelseif key == keys.enter thenif activeInput thenactiveInput = nil-- Move to nextif #focusableIndices > 0 thencurrentFocusIndex = currentFocusIndex + 1if currentFocusIndex > #focusableIndices then currentFocusIndex = 1 endlocal el = form.elements[focusableIndices[currentFocusIndex]]activeInput = (el.type == "input") and el or nilendelse-- Activate buttonif #focusableIndices > 0 thenlocal el = form.elements[focusableIndices[currentFocusIndex]]if el.type == "button" thenui.button(fx + el.x, fy + el.y, el.text, true) -- Flashsleep(0.1)if el.callback thenlocal res = el.callback(form)if res then return res endendelseif el.type == "input" thenactiveInput = elendendendendendendend-- Simple Scrollable Menu-- items = { { text="Label", callback=function() end }, ... }function ui.runMenu(title, items)local w, h = term.getSize()local fw, fh = math.floor(w * 0.8), math.floor(h * 0.8)local fx, fy = math.floor((w - fw) / 2) + 1, math.floor((h - fh) / 2) + 1local scroll = 0local maxVisible = fh - 4 -- Title + padding (top/bottom)local selectedIndex = 1while true doui.clear()ui.drawFrame(fx, fy, fw, fh, title)-- Draw itemsfor i = 1, maxVisible dolocal idx = i + scrollif idx <= #items thenlocal item = items[idx]local isSelected = (idx == selectedIndex)ui.button(fx + 2, fy + 1 + i, item.text, isSelected)endend-- Scroll indicatorsif scroll > 0 thenui.label(fx + fw - 2, fy + 2, "^")endif scroll + maxVisible < #items thenui.label(fx + fw - 2, fy + fh - 2, "v")endlocal event, p1, p2, p3 = os.pullEvent()if event == "mouse_click" thenlocal btn, mx, my = p1, p2, p3-- Check itemsfor i = 1, maxVisible dolocal idx = i + scrollif idx <= #items thenlocal item = items[idx]local bx, by = fx + 2, fy + 1 + i-- Button width is text length + 2 spacesif my == by and mx >= bx and mx < bx + #item.text + 2 thenui.button(bx, by, item.text, true) -- Flashsleep(0.1)if item.callback thenlocal res = item.callback()if res then return res endendselectedIndex = idxendendendelseif event == "mouse_scroll" thenlocal dir = p1if dir > 0 thenif scroll + maxVisible < #items then scroll = scroll + 1 endelseif scroll > 0 then scroll = scroll - 1 endendelseif event == "key" thenlocal key = p1if key == keys.up thenif selectedIndex > 1 thenselectedIndex = selectedIndex - 1if selectedIndex <= scroll thenscroll = selectedIndex - 1endendelseif key == keys.down thenif selectedIndex < #items thenselectedIndex = selectedIndex + 1if selectedIndex > scroll + maxVisible thenscroll = selectedIndex - maxVisibleendendelseif key == keys.enter thenlocal item = items[selectedIndex]if item and item.callback thenui.button(fx + 2, fy + 1 + (selectedIndex - scroll), item.text, true) -- Flashsleep(0.1)local res = item.callback()if res then return res endendendendendend-- Form Classfunction ui.Form(title)local self = {title = title,elements = {},_row = 0,}function self:addInput(id, label, value)local y = 2 + self._rowtable.insert(self.elements, { type = "label", x = 2, y = y, text = label })table.insert(self.elements, { type = "input", x = 15, y = y, width = 20, value = value, id = id })self._row = self._row + 1endfunction self:addStepper(id, label, value, opts)opts = opts or {}local y = 2 + self._rowtable.insert(self.elements, { type = "label", x = 2, y = y, text = label })table.insert(self.elements, {type = "input",x = 15,y = y,width = 12,value = tostring(value or 0),id = id,stepper = true,step = opts.step or 1,min = opts.min,max = opts.max,})self._row = self._row + 1endfunction self:addButton(id, label, callback)local y = 2 + self._rowtable.insert(self.elements, { type = "button", x = 2, y = y, text = label, id = id, callback = callback })self._row = self._row + 1endfunction self:run()-- Add OK/Cancel buttonslocal y = 2 + self._row + 2table.insert(self.elements, {type = "button", x = 2, y = y, text = "OK",callback = function(form) return "ok" end})table.insert(self.elements, {type = "button", x = 10, y = y, text = "Cancel",callback = function(form) return "cancel" end})return ui.runForm(self)endreturn selfendfunction ui.toBlit(color)if colors.toBlit then return colors.toBlit(color) endlocal exponent = math.log(color) / math.log(2)return string.sub("0123456789abcdef", exponent + 1, exponent + 1)endreturn ui]=])addEmbeddedFile("lib/lib_parser.lua", [=[---@diagnostic disable: undefined-globallocal parser = {}local logger = require("lib_logger")local table_utils = require("lib_table")local fs_utils = require("lib_fs")local json_utils = require("lib_json")local schema_utils = require("lib_schema")local function parseLayerRows(schema, bounds, counts, layerDef, legend, opts)local rows = layerDef.rowsif type(rows) ~= "table" thenreturn false, "invalid_layer"endlocal height = #rowsif height == 0 thenreturn trueendlocal width = nilfor rowIndex, row in ipairs(rows) doif type(row) ~= "string" thenreturn false, "invalid_row"endif width == nil thenwidth = #rowif width == 0 thenreturn false, "empty_row"endelseif width ~= #row thenreturn false, "ragged_row"endfor col = 1, #row dolocal symbol = row:sub(col, col)local entry, err = schema_utils.resolveSymbol(symbol, legend, opts)if err thenreturn false, string.format("legend_error:%s", symbol)endif entry thenlocal x = (layerDef.x or 0) + (col - 1)local y = layerDef.y or 0local z = (layerDef.z or 0) + (rowIndex - 1)local ok, addErr = schema_utils.addBlock(schema, bounds, counts, x, y, z, entry.material, entry.meta)if not ok thenreturn false, addErrendendendendreturn trueendlocal function toLayerRows(layer)if type(layer) == "string" thenlocal rows = {}for line in layer:gmatch("([^\r\n]+)") dorows[#rows + 1] = lineendreturn { rows = rows }endif type(layer) == "table" thenif layer.rows thenlocal rows = {}for i = 1, #layer.rows dorows[i] = tostring(layer.rows[i])endreturn {rows = rows,y = layer.y or layer.height or layer.level or 0,x = layer.x or layer.offsetX or 0,z = layer.z or layer.offsetZ or 0,}endlocal rows = {}local count = 0for _, value in ipairs(layer) dorows[#rows + 1] = tostring(value)count = count + 1endif count > 0 thenreturn { rows = rows, y = layer.y or 0, x = layer.x or 0, z = layer.z or 0 }endendreturn nilendlocal function parseLayers(schema, bounds, counts, def, legend, opts)local layers = def.layersif type(layers) ~= "table" thenreturn false, "invalid_layers"endlocal used = 0for index, layer in ipairs(layers) dolocal layerRows = toLayerRows(layer)if not layerRows thenreturn false, "invalid_layer"endif not layerRows.y thenlayerRows.y = (def.baseY or 0) + (index - 1)elselayerRows.y = layerRows.y + (def.baseY or 0)endif def.baseX thenlayerRows.x = (layerRows.x or 0) + def.baseXendif def.baseZ thenlayerRows.z = (layerRows.z or 0) + def.baseZendlocal ok, err = parseLayerRows(schema, bounds, counts, layerRows, legend, opts)if not ok thenreturn false, errendused = used + 1endif used == 0 thenreturn false, "empty_layers"endreturn trueendlocal function parseBlockList(schema, bounds, counts, blocks)local used = 0for _, block in ipairs(blocks) doif type(block) ~= "table" thenreturn false, "invalid_block"endlocal x = block.x or block[1]local y = block.y or block[2]local z = block.z or block[3]local material = block.material or block.name or block.blocklocal meta = block.meta or block.dataif type(meta) ~= "table" thenmeta = {}endlocal ok, err = schema_utils.addBlock(schema, bounds, counts, x, y, z, material, meta)if not ok thenreturn false, errendused = used + 1endif used == 0 thenreturn false, "empty_blocks"endreturn trueendlocal function parseVoxelGrid(schema, bounds, counts, grid)if type(grid) ~= "table" thenreturn false, "invalid_grid"endlocal used = 0for xKey, xColumn in pairs(grid) dolocal x = tonumber(xKey) or xKeyif type(x) ~= "number" thenreturn false, "invalid_coordinate"endif type(xColumn) ~= "table" thenreturn false, "invalid_grid"endfor yKey, yColumn in pairs(xColumn) dolocal y = tonumber(yKey) or yKeyif type(y) ~= "number" thenreturn false, "invalid_coordinate"endif type(yColumn) ~= "table" thenreturn false, "invalid_grid"endfor zKey, entry in pairs(yColumn) dolocal z = tonumber(zKey) or zKeyif type(z) ~= "number" thenreturn false, "invalid_coordinate"endif entry ~= nil thenlocal materiallocal meta = {}if type(entry) == "string" thenmaterial = entryelseif type(entry) == "table" thenmaterial = entry.material or entry.name or entry.blockmeta = type(entry.meta) == "table" and entry.meta or {}elsereturn false, "invalid_block"endif material and material ~= "" thenlocal ok, err = schema_utils.addBlock(schema, bounds, counts, x, y, z, material, meta)if not ok thenreturn false, errendused = used + 1endendendendendif used == 0 thenreturn false, "empty_grid"endreturn trueendlocal function summarise(bounds, counts, meta)local materials = {}for material, count in pairs(counts) domaterials[#materials + 1] = { material = material, count = count }endtable.sort(materials, function(a, b)if a.count == b.count thenreturn a.material < b.materialendreturn a.count > b.countend)local total = 0for _, entry in ipairs(materials) dototal = total + entry.countendreturn {bounds = {min = table_utils.shallowCopy(bounds.min),max = table_utils.shallowCopy(bounds.max),},materials = materials,totalBlocks = total,meta = meta}endlocal function buildCanonical(def, opts)local schema = {}local bounds = schema_utils.newBounds()local counts = {}local ok, errif def.blocks thenok, err = parseBlockList(schema, bounds, counts, def.blocks)elseif def.layers thenok, err = parseLayers(schema, bounds, counts, def, def.legend, opts)elseif def.grid thenok, err = parseVoxelGrid(schema, bounds, counts, def.grid)elsereturn nil, "unknown_definition"endif not ok thenreturn nil, errendif bounds.min.x == math.huge thenreturn nil, "empty_schema"endreturn schema, summarise(bounds, counts, def.meta)endlocal function detectFormatFromExtension(path)if type(path) ~= "string" thenreturn nilendlocal ext = path:match("%.([%w_%-]+)$")if not ext thenreturn nilendext = ext:lower()if ext == "json" or ext == "schem" thenreturn "json"endif ext == "txt" or ext == "grid" thenreturn "grid"endif ext == "vox" or ext == "voxel" thenreturn "voxel"endreturn nilendlocal function detectFormatFromText(text)if type(text) ~= "string" thenreturn nilendlocal trimmed = text:match("^%s*(.-)%s*$") or textlocal firstChar = trimmed:sub(1, 1)if firstChar == "{" or firstChar == "[" thenreturn "json"endreturn "grid"endlocal function parseLegendBlock(lines, index)local legend = {}local pos = indexwhile pos <= #lines dolocal line = lines[pos]if line == "" thenbreakendif line:match("^layer") thenbreakendlocal symbol, rest = line:match("^(%S+)%s*[:=]%s*(.+)$")if not symbol thensymbol, rest = line:match("^(%S+)%s+(.+)$")endif symbol and rest thenrest = rest:gsub("^%s+", ""):gsub("%s+$", "")local valueif rest:sub(1, 1) == "{" thenlocal parsed = json_utils.decodeJson(rest)if parsed thenvalue = parsedelsevalue = restendelsevalue = restendlegend[symbol] = valueendpos = pos + 1endreturn legend, posendlocal function parseTextGridContent(text, opts)local lines = {}for line in (text .. "\n"):gmatch("([^\n]*)\n") doline = line:gsub("\r$", "")lines[#lines + 1] = lineendlocal legend = schema_utils.mergeLegend(opts and opts.legend or nil, nil)local layers = {}local current = {}local currentY = nillocal lineIndex = 1while lineIndex <= #lines dolocal line = lines[lineIndex]local trimmed = line:match("^%s*(.-)%s*$")if trimmed == "" thenif #current > 0 thenlayers[#layers + 1] = { rows = current, y = currentY or (#layers) }current = {}currentY = nilendlineIndex = lineIndex + 1elseif trimmed:lower() == "legend:" thenlocal legendBlock, nextIndex = parseLegendBlock(lines, lineIndex + 1)legend = schema_utils.mergeLegend(legend, legendBlock)lineIndex = nextIndexelseif trimmed:lower() == "meta:" thenlocal metaBlock, nextIndex = parseLegendBlock(lines, lineIndex + 1) -- Reuse parseLegendBlock as format is identicalif not opts then opts = {} endopts.meta = schema_utils.mergeLegend(opts.meta, metaBlock)lineIndex = nextIndexelseif trimmed:match("^layer") thenif #current > 0 thenlayers[#layers + 1] = { rows = current, y = currentY or (#layers) }current = {}endlocal yValue = trimmed:match("layer%s*[:=]%s*(-?%d+)")currentY = yValue and tonumber(yValue) or (#layers)lineIndex = lineIndex + 1elsecurrent[#current + 1] = linelineIndex = lineIndex + 1endendif #current > 0 thenlayers[#layers + 1] = { rows = current, y = currentY or (#layers) }endif not legend or next(legend) == nil thenreturn nil, "missing_legend"endif #layers == 0 thenreturn nil, "empty_layers"endreturn {layers = layers,legend = legend,}endlocal function parseJsonContent(obj, opts)if type(obj) ~= "table" thenreturn nil, "invalid_json_root"endlocal legend = schema_utils.mergeLegend(opts and opts.legend or nil, obj.legend or nil)if obj.blocks thenreturn {blocks = obj.blocks,legend = legend,}endif obj.layers thenreturn {layers = obj.layers,legend = legend,baseX = obj.baseX,baseY = obj.baseY,baseZ = obj.baseZ,}endif obj.grid or obj.voxels thenreturn {grid = obj.grid or obj.voxels,legend = legend,}endif #obj > 0 thenreturn {blocks = obj,legend = legend,}endreturn nil, "unrecognised_json"endlocal function assignToContext(ctx, schema, info)if type(ctx) ~= "table" thenreturnendctx.schema = schemactx.schemaInfo = infoendlocal function ensureSpecTable(spec)if type(spec) == "table" thenreturn table_utils.shallowCopy(spec)endif type(spec) == "string" thenreturn { source = spec }endreturn {}endfunction parser.parse(ctx, spec)spec = ensureSpecTable(spec)local format = spec.formatlocal text = spec.textlocal data = spec.datalocal path = spec.path or spec.sourcePathlocal source = spec.sourceif not format and spec.path thenformat = detectFormatFromExtension(spec.path)endif not format and spec.formatHint thenformat = spec.formatHintendif not text and not data thenif spec.textContent thentext = spec.textContentelseif spec.raw thentext = spec.rawelseif spec.sourceText thentext = spec.sourceTextendendif not path and type(source) == "string" and text == nil and data == nil thenlocal maybeFormat = detectFormatFromExtension(source)if maybeFormat thenpath = sourceformat = format or maybeFormatelsetext = sourceendendif text == nil and path thenlocal contents, err = fs_utils.readFile(path)if not contents thenreturn false, err or "read_failed"endtext = contentsif not format thenformat = detectFormatFromExtension(path) or detectFormatFromText(text)endendif not format thenif data thenif data.layers thenformat = "grid"elseif data.blocks thenformat = "json"elseif data.grid or data.voxels thenformat = "voxel"endelseif text thenformat = detectFormatFromText(text)endendif not format thenreturn false, "unknown_format"endlocal definition, errif format == "json" thenif data thendefinition, err = parseJsonContent(data, spec)elselocal obj, decodeErr = json_utils.decodeJson(text)if not obj thenreturn false, decodeErrenddefinition, err = parseJsonContent(obj, spec)endelseif format == "grid" thenif data and (data.layers or data.rows) thendefinition = {layers = data.layers or { data.rows },legend = schema_utils.mergeLegend(spec.legend or nil, data.legend or nil),meta = spec.meta or data.meta}elsedefinition, err = parseTextGridContent(text, spec)if definition and spec.meta thendefinition.meta = schema_utils.mergeLegend(definition.meta, spec.meta)endendelseif format == "voxel" thenif data thendefinition = {grid = data.grid or data.voxels or data,}elselocal obj, decodeErr = json_utils.decodeJson(text)if not obj thenreturn false, decodeErrendif obj.grid or obj.voxels thendefinition = {grid = obj.grid or obj.voxels,}elsedefinition, err = parseJsonContent(obj, spec)endendelsereturn false, "unsupported_format"endif not definition thenreturn false, err or "invalid_definition"endif spec.legend thendefinition.legend = schema_utils.mergeLegend(definition.legend, spec.legend)endlocal schema, metadata = buildCanonical(definition, spec)if not schema thenreturn false, metadata or "parse_failed"endif type(metadata) ~= "table" thenmetadata = { note = metadata }endmetadata = metadata or {}metadata.format = formatmetadata.path = pathassignToContext(ctx, schema, metadata)logger.log(ctx, "debug", string.format("Parsed schema with %d blocks", metadata.totalBlocks or 0))return true, schema, metadataendfunction parser.parseFile(ctx, path, opts)opts = opts or {}opts.path = pathreturn parser.parse(ctx, opts)endfunction parser.parseText(ctx, text, opts)opts = opts or {}opts.text = textopts.format = opts.format or "grid"return parser.parse(ctx, opts)endfunction parser.parseJson(ctx, data, opts)opts = opts or {}opts.data = dataopts.format = "json"return parser.parse(ctx, opts)endreturn parser]=])addEmbeddedFile("lib/lib_items.lua", [=[local items = {{ id = "minecraft:stone", sym = "#", color = colors.lightGray },{ id = "minecraft:cobblestone", sym = "c", color = colors.gray },{ id = "minecraft:dirt", sym = "d", color = colors.brown },{ id = "minecraft:grass_block", sym = "g", color = colors.green },{ id = "minecraft:planks", sym = "p", color = colors.orange },{ id = "minecraft:log", sym = "L", color = colors.brown },{ id = "minecraft:leaves", sym = "l", color = colors.green },{ id = "minecraft:glass", sym = "G", color = colors.lightBlue },{ id = "minecraft:sand", sym = "s", color = colors.yellow },{ id = "minecraft:gravel", sym = "v", color = colors.gray },{ id = "minecraft:coal_ore", sym = "C", color = colors.black },{ id = "minecraft:iron_ore", sym = "I", color = colors.white },{ id = "minecraft:gold_ore", sym = "O", color = colors.yellow },{ id = "minecraft:diamond_ore", sym = "D", color = colors.cyan },{ id = "minecraft:redstone_ore", sym = "R", color = colors.red },{ id = "minecraft:lapis_ore", sym = "B", color = colors.blue },{ id = "minecraft:chest", sym = "H", color = colors.orange },{ id = "minecraft:furnace", sym = "F", color = colors.gray },{ id = "minecraft:crafting_table", sym = "T", color = colors.brown },{ id = "minecraft:torch", sym = "i", color = colors.yellow },{ id = "minecraft:water_bucket", sym = "W", color = colors.blue },{ id = "minecraft:lava_bucket", sym = "A", color = colors.orange },{ id = "minecraft:bucket", sym = "u", color = colors.lightGray },{ id = "minecraft:wheat_seeds", sym = ".", color = colors.green },{ id = "minecraft:wheat", sym = "w", color = colors.yellow },{ id = "minecraft:carrot", sym = "r", color = colors.orange },{ id = "minecraft:potato", sym = "o", color = colors.yellow },{ id = "minecraft:sugar_cane", sym = "|", color = colors.lime },{ id = "minecraft:oak_sapling", sym = "S", color = colors.green },{ id = "minecraft:spruce_sapling", sym = "S", color = colors.green },{ id = "minecraft:birch_sapling", sym = "S", color = colors.green },{ id = "minecraft:jungle_sapling", sym = "S", color = colors.green },{ id = "minecraft:acacia_sapling", sym = "S", color = colors.green },{ id = "minecraft:dark_oak_sapling", sym = "S", color = colors.green },{ id = "minecraft:stone_bricks", sym = "#", color = colors.gray },}return items]=])addEmbeddedFile("lib/lib_schema.lua", [=[local schema_utils = {}local items = require("lib_items")local table_utils = require("lib_table")function schema_utils.newBounds()return {min = { x = math.huge, y = math.huge, z = math.huge },max = { x = -math.huge, y = -math.huge, z = -math.huge },}endfunction schema_utils.updateBounds(bounds, x, y, z)if x < bounds.min.x then bounds.min.x = x endif y < bounds.min.y then bounds.min.y = y endif z < bounds.min.z then bounds.min.z = z endif x > bounds.max.x then bounds.max.x = x endif y > bounds.max.y then bounds.max.y = y endif z > bounds.max.z then bounds.max.z = z endendfunction schema_utils.resolveSymbol(symbol, legend, opts)local entry = legend and legend[symbol]if not entry then-- Default fallbacksif symbol == "." then return nil end -- Airreturn nil, "unknown_symbol"endlocal material, metaif type(entry) == "table" thenmaterial = entry.material or entry.block or entry.namemeta = entry.meta or entry.data or {}elsematerial = entrymeta = {}endif material == "minecraft:air" or material == "air" thenreturn nilend-- Apply global meta overrides if presentif opts and opts.meta thenmeta = table_utils.merge(meta, opts.meta)endreturn { material = material, meta = meta }endfunction schema_utils.addBlock(schema, bounds, counts, x, y, z, material, meta)if not material then return true end -- Skip air/nilif not schema[x] then schema[x] = {} endif not schema[x][y] then schema[x][y] = {} end-- Check for conflict? For now, overwrite.schema[x][y][z] = {material = material,meta = meta}schema_utils.updateBounds(bounds, x, y, z)counts[material] = (counts[material] or 0) + 1return trueendfunction schema_utils.mergeLegend(base, override)if not base and not override then return {} endif not base then return override endif not override then return base endlocal merged = table_utils.shallowCopy(base)for k, v in pairs(override) domerged[k] = vendreturn mergedendfunction schema_utils.cloneMeta(meta)if not meta then return {} endreturn table_utils.deepCopy(meta)endfunction schema_utils.canonicalToVoxelDefinition(schema)-- Convert canonical [x][y][z] format back to a voxel grid format suitable for JSON export-- This is essentially just the schema table itself, but we might want to ensure keys are strings for JSON-- However, CC's textutils.serializeJSON handles number keys as array indices if contiguous, or object keys if strings.-- To be safe and consistent with "grid" format, we can keep it as is, or convert to a list of blocks.-- Let's stick to the grid format as it's more compact for dense structures.-- Actually, to ensure JSON compatibility (string keys for sparse arrays), we might need to be careful.-- But for now, let's just return the schema structure.return { grid = schema }endreturn schema_utils]=])local lib_designer_part1 = [=[local ui = require("lib_ui")local json = require("lib_json")local items = require("lib_items")local schema_utils = require("lib_schema")local parser = require("lib_parser")local version = require("version")local designer = {}-- --- Constants & Config ---local COLORS = {bg = colors.gray,canvas_bg = colors.black,grid = colors.lightGray,text = colors.white,btn_active = colors.blue,btn_inactive = colors.lightGray,btn_text = colors.black,}local DEFAULT_MATERIALS = {{ id = "minecraft:stone", color = colors.lightGray, sym = "#" },{ id = "minecraft:dirt", color = colors.brown, sym = "d" },{ id = "minecraft:cobblestone", color = colors.gray, sym = "c" },{ id = "minecraft:planks", color = colors.orange, sym = "p" },{ id = "minecraft:glass", color = colors.lightBlue, sym = "g" },{ id = "minecraft:log", color = colors.brown, sym = "L" },{ id = "minecraft:torch", color = colors.yellow, sym = "i" },{ id = "minecraft:iron_block", color = colors.white, sym = "I" },{ id = "minecraft:gold_block", color = colors.yellow, sym = "G" },{ id = "minecraft:diamond_block", color = colors.cyan, sym = "D" },}local TOOLS = {PENCIL = "Pencil",LINE = "Line",RECT = "Rect",RECT_FILL = "FillRect",CIRCLE = "Circle",CIRCLE_FILL = "FillCircle",BUCKET = "Bucket",PICKER = "Picker"}-- --- State ---local state = {}local function resetState()state.running = truestate.w = 14state.h = 14state.d = 5state.data = {} -- [x][y][z] = material_index (0 or nil for air)state.meta = {} -- [x][y][z] = meta tablestate.fileMeta = nil -- Global file metadatastate.palette = {}state.paletteEditMode = falsestate.offset = { x = 0, y = 0, z = 0 }state.view = {layer = 0, -- Current Y leveloffsetX = 4, -- Screen X offset of canvasoffsetY = 3, -- Screen Y offset of canvasscrollX = 0,scrollY = 0,cursorX = 0,cursorY = 0,}state.menuOpen = falsestate.inventoryOpen = falsestate.searchOpen = falsestate.searchQuery = ""state.searchResults = {}state.searchScroll = 0state.dragItem = nil -- { id, sym, color }state.tool = TOOLS.PENCILstate.primaryColor = 1 -- Index in palettestate.secondaryColor = 0 -- 0 = Air/Eraserstate.mouse = {down = false,drag = false,startX = 0, startY = 0, -- Canvas coordscurrX = 0, currY = 0,   -- Canvas coordsbtn = 1}state.status = "Ready"for i, m in ipairs(DEFAULT_MATERIALS) dostate.palette[i] = { id = m.id, color = m.color, sym = m.sym }endendresetState()-- --- Helpers ---local function getMaterial(idx)if idx == 0 or not idx then return nil endreturn state.palette[idx]endlocal function getBlock(x, y, z)if not state.data[x] then return 0 endif not state.data[x][y] then return 0 endreturn state.data[x][y][z] or 0endlocal function setBlock(x, y, z, matIdx, meta)if x < 0 or x >= state.w or z < 0 or z >= state.h or y < 0 or y >= state.d then return endif not state.data[x] then state.data[x] = {} endif not state.data[x][y] then state.data[x][y] = {} endif not state.meta[x] then state.meta[x] = {} endif not state.meta[x][y] then state.meta[x][y] = {} endif matIdx == 0 thenstate.data[x][y][z] = nilif state.meta[x] and state.meta[x][y] thenstate.meta[x][y][z] = nilendelsestate.data[x][y][z] = matIdxstate.meta[x][y][z] = meta or {}endendlocal function getBlockMeta(x, y, z)if not state.meta[x] or not state.meta[x][y] then return {} endreturn schema_utils.cloneMeta(state.meta[x][y][z])endlocal function findItemDef(id)for _, item in ipairs(items) doif item.id == id thenreturn itemendendreturn nilendlocal function ensurePaletteMaterial(material)for idx, mat in ipairs(state.palette) doif mat.id == material thenreturn idxendendlocal fallback = findItemDef(material)local entry = {id = material,color = fallback and fallback.color or colors.white,sym = fallback and fallback.sym or "?",}table.insert(state.palette, entry)return #state.paletteendlocal function clearCanvas()state.data = {}state.meta = {}endlocal function loadCanonical(schema, metadata)if type(schema) ~= "table" thenreturn false, "invalid_schema"endclearCanvas()local bounds = schema_utils.newBounds()local blockCount = 0for xKey, xColumn in pairs(schema) doif type(xColumn) == "table" thenlocal x = tonumber(xKey) or xKeyif type(x) ~= "number" then return false, "invalid_coordinate" endfor yKey, yColumn in pairs(xColumn) doif type(yColumn) == "table" thenlocal y = tonumber(yKey) or yKeyif type(y) ~= "number" then return false, "invalid_coordinate" endfor zKey, block in pairs(yColumn) doif type(block) == "table" and block.material thenlocal z = tonumber(zKey) or zKeyif type(z) ~= "number" then return false, "invalid_coordinate" endschema_utils.updateBounds(bounds, x, y, z)blockCount = blockCount + 1endendendendendendif blockCount == 0 thenstate.status = "Loaded empty schema"return trueendstate.offset = {x = bounds.min.x,y = bounds.min.y,z = bounds.min.z,}state.w = math.max(1, (bounds.max.x - bounds.min.x) + 1)state.d = math.max(1, (bounds.max.y - bounds.min.y) + 1)state.h = math.max(1, (bounds.max.z - bounds.min.z) + 1)for xKey, xColumn in pairs(schema) doif type(xColumn) == "table" thenlocal x = tonumber(xKey) or xKeyif type(x) ~= "number" then return false, "invalid_coordinate" endfor yKey, yColumn in pairs(xColumn) doif type(yColumn) == "table" thenlocal y = tonumber(yKey) or yKeyif type(y) ~= "number" then return false, "invalid_coordinate" endfor zKey, block in pairs(yColumn) doif type(block) == "table" and block.material thenlocal z = tonumber(zKey) or zKeyif type(z) ~= "number" then return false, "invalid_coordinate" endlocal matIdx = ensurePaletteMaterial(block.material)local localX = x - state.offset.xlocal localY = y - state.offset.ylocal localZ = z - state.offset.zsetBlock(localX, localY, localZ, matIdx, schema_utils.cloneMeta(block.meta))endendendendendendstate.status = string.format("Loaded %d blocks", blockCount)if metadata and metadata.path thenstate.status = state.status .. " from " .. metadata.pathendif metadata and metadata.meta thenstate.fileMeta = metadata.metaendreturn trueendlocal function exportCanonical()local schema = {}local bounds = schema_utils.newBounds()local total = 0for x, xColumn in pairs(state.data) dofor y, yColumn in pairs(xColumn) dofor z, matIdx in pairs(yColumn) dolocal mat = getMaterial(matIdx)if mat thenlocal worldX = x + state.offset.xlocal worldY = y + state.offset.ylocal worldZ = z + state.offset.zschema[worldX] = schema[worldX] or {}schema[worldX][worldY] = schema[worldX][worldY] or {}schema[worldX][worldY][worldZ] = {material = mat.id,meta = getBlockMeta(x, y, z),}schema_utils.updateBounds(bounds, worldX, worldY, worldZ)total = total + 1endendendendlocal info = { totalBlocks = total }if total > 0 theninfo.bounds = boundsendreturn schema, infoendlocal function exportVoxelDefinition()local canonical, info = exportCanonical()return schema_utils.canonicalToVoxelDefinition(canonical), infoend-- --- Algorithms ---local function drawLine(x0, y0, x1, y1, callback)local dx = math.abs(x1 - x0)local dy = math.abs(y1 - y0)local sx = x0 < x1 and 1 or -1local sy = y0 < y1 and 1 or -1local err = dx - dywhile true docallback(x0, y0)if x0 == x1 and y0 == y1 then break endlocal e2 = 2 * errif e2 > -dy thenerr = err - dyx0 = x0 + sxendif e2 < dx thenerr = err + dxy0 = y0 + syendendendlocal function drawRect(x0, y0, x1, y1, filled, callback)local minX, maxX = math.min(x0, x1), math.max(x0, x1)local minY, maxY = math.min(y0, y1), math.max(y0, y1)for x = minX, maxX dofor y = minY, maxY doif filled or (x == minX or x == maxX or y == minY or y == maxY) thencallback(x, y)endendendendlocal function drawCircle(x0, y0, x1, y1, filled, callback)-- Midpoint circle algorithm adapted for ellipse/boundslocal r = math.floor(math.min(math.abs(x1 - x0), math.abs(y1 - y0)) / 2)local cx = math.floor((x0 + x1) / 2)local cy = math.floor((y0 + y1) / 2)local x = rlocal y = 0local err = 0while x >= y doif filled thenfor i = cx - x, cx + x do callback(i, cy + y); callback(i, cy - y) endfor i = cx - y, cx + y do callback(i, cy + x); callback(i, cy - x) endelsecallback(cx + x, cy + y)callback(cx + y, cy + x)callback(cx - y, cy + x)callback(cx - x, cy + y)callback(cx - x, cy - y)callback(cx - y, cy - x)callback(cx + y, cy - x)callback(cx + x, cy - y)endif err <= 0 theny = y + 1err = err + 2 * y + 1endif err > 0 thenx = x - 1err = err - 2 * x + 1endendendlocal function floodFill(startX, startY, targetColor, replaceColor)if targetColor == replaceColor then return endlocal queue = { {x = startX, y = startY} }local visited = {}local function key(x, y) return x .. "," .. y endwhile #queue > 0 dolocal p = table.remove(queue, 1)local k = key(p.x, p.y)if not visited[k] thenvisited[k] = truelocal curr = getBlock(p.x, state.view.layer, p.y)if curr == targetColor thensetBlock(p.x, state.view.layer, p.y, replaceColor)local neighbors = {{x = p.x + 1, y = p.y},{x = p.x - 1, y = p.y},{x = p.x, y = p.y + 1},{x = p.x, y = p.y - 1}}for _, n in ipairs(neighbors) doif n.x >= 0 and n.x < state.w and n.y >= 0 and n.y < state.h thentable.insert(queue, n)endendendendendend-- --- Rendering ---local drawSearchlocal function drawMenu()if not state.menuOpen then return endlocal w, h = term.getSize()local mx, my = w - 12, 2local mw, mh = 12, 8ui.drawFrame(mx, my, mw, mh, "Menu")local options = { "Resize", "Save", "Load", "Clear", "Inventory", "Quit" }for i, opt in ipairs(options) doterm.setCursorPos(mx + 1, my + i)term.setBackgroundColor(COLORS.bg)term.setTextColor(COLORS.text)if opt == "Inventory" and state.inventoryOpen thenterm.setTextColor(colors.yellow)endterm.write(opt)endendlocal function drawInventory()if not state.inventoryOpen then return endlocal w, h = term.getSize()local iw, ih = 18, 6 -- 4x4 grid + borderlocal ix, iy = math.floor((w - iw)/2), math.floor((h - ih)/2)ui.drawFrame(ix, iy, iw, ih, "Inventory")-- Draw 4x4 gridfor row = 0, 3 dofor col = 0, 3 dolocal slot = row * 4 + col + 1local item = turtle.getItemDetail(slot)term.setCursorPos(ix + 1 + (col * 4), iy + 1 + row)local sym = "."local color = colors.grayif item thensym = item.name:sub(11, 11):upper() -- First char of name after minecraft:color = colors.whiteendterm.setBackgroundColor(colors.black)term.setTextColor(color)term.write(" " .. sym .. " ")endendterm.setCursorPos(ix + 1, iy + ih)term.setBackgroundColor(COLORS.bg)term.setTextColor(COLORS.text)term.write("Drag to Palette")endlocal function drawDragItem()if state.dragItem and state.mouse.screenX thenterm.setCursorPos(state.mouse.screenX, state.mouse.screenY)term.setBackgroundColor(colors.black)term.setTextColor(colors.white)term.write(state.dragItem.sym)endendlocal function drawUI()ui.clear()-- Toolbar (Top)term.setBackgroundColor(COLORS.bg)term.setCursorPos(1, 1)term.clearLine()-- [M] Buttonterm.setBackgroundColor(colors.lightGray)term.setTextColor(colors.black)term.write(" M ")term.setBackgroundColor(COLORS.bg)term.setTextColor(COLORS.text)term.write(string.format(" Designer [%d,%d,%d] Layer: %d/%d", state.w, state.h, state.d, state.view.layer, state.d - 1))-- Tools (Left Side)local toolsList = { TOOLS.PENCIL, TOOLS.LINE, TOOLS.RECT, TOOLS.RECT_FILL, TOOLS.CIRCLE, TOOLS.CIRCLE_FILL, TOOLS.BUCKET, TOOLS.PICKER }for i, t in ipairs(toolsList) doterm.setCursorPos(1, 2 + i)if state.tool == t thenterm.setBackgroundColor(COLORS.btn_active)term.setTextColor(colors.white)term.write(" " .. t:sub(1,1) .. " ")elseterm.setBackgroundColor(COLORS.btn_inactive)term.setTextColor(COLORS.btn_text)term.write(" " .. t:sub(1,1) .. " ")endend-- Palette (Right Side)local palX = 2 + state.w + 2term.setCursorPos(palX, 2)term.setBackgroundColor(COLORS.bg)term.setTextColor(COLORS.text)local editLabel = state.paletteEditMode and "[EDITING]" or "[Edit]"if state.paletteEditMode then term.setTextColor(colors.red) endterm.write("Pal " .. editLabel)-- Search Buttonterm.setCursorPos(palX + 14, 2)term.setBackgroundColor(COLORS.btn_inactive)term.setTextColor(COLORS.btn_text)term.write("Find")for i, mat in ipairs(state.palette) doterm.setCursorPos(palX, 3 + i)-- Indicator for selectionlocal indicator = " "if state.primaryColor == i then indicator = "L" endif state.secondaryColor == i then indicator = "R" endif state.primaryColor == i and state.secondaryColor == i then indicator = "B" endterm.setBackgroundColor(COLORS.bg)term.setTextColor(COLORS.text)term.write(indicator)term.setBackgroundColor(mat.color)term.setTextColor(colors.black)term.write(" " .. mat.sym .. " ")term.setBackgroundColor(COLORS.bg)term.setTextColor(COLORS.text)local name = mat.id:match(":(.+)") or mat.idterm.write(" " .. name)end-- Status Bar (Bottom)local w, h = term.getSize()term.setCursorPos(1, h)term.setBackgroundColor(COLORS.bg)term.clearLine()term.write(state.status)-- Display version in bottom right cornerlocal versionText = version.display()term.setCursorPos(w - #versionText + 1, h)term.setTextColor(colors.lightGray)term.write(versionText)term.setTextColor(COLORS.text)-- Instructionsterm.setCursorPos(1, h-1)term.write("S:Save L:Load F:Find R:Resize C:Clear Q:Quit PgUp/Dn:Layer")drawMenu()drawInventory()drawSearch()drawDragItem()endlocal function drawCanvas()local ox, oy = state.view.offsetX, state.view.offsetYlocal sx, sy = state.view.scrollX, state.view.scrollY-- Draw Borderterm.setBackgroundColor(COLORS.bg)term.setTextColor(colors.white)ui.drawBox(ox - 1, oy - 1, state.w + 2, state.h + 2, COLORS.bg, colors.white)-- Draw Pixelsfor x = 0, state.w - 1 dofor z = 0, state.h - 1 do-- Apply scrolllocal screenX = ox + x - sxlocal screenY = oy + z - sy-- Only draw if within canvas view area (roughly)-- Actually, we should clip to the border box-- For simplicity, let's just draw if it fits on screenlocal w, h = term.getSize()if screenX >= ox and screenX < w and screenY >= oy and screenY < h - 2 thenlocal matIdx = getBlock(x, state.view.layer, z)local mat = getMaterial(matIdx)local bg = COLORS.canvas_bglocal char = "."local fg = COLORS.gridif mat then]=]local lib_designer_part2 = [=[                    bg = mat.colorchar = mat.symfg = colors.blackif bg == colors.black then fg = colors.white endend-- Ghost drawingif state.mouse.down and state.mouse.drag thenlocal isGhost = falselocal ghostColor = (state.mouse.btn == 1) and state.primaryColor or state.secondaryColorlocal function checkGhost(gx, gy)if gx == x and gy == z then isGhost = true endendif state.tool == TOOLS.PENCIL thencheckGhost(state.mouse.currX, state.mouse.currY)elseif state.tool == TOOLS.LINE thendrawLine(state.mouse.startX, state.mouse.startY, state.mouse.currX, state.mouse.currY, checkGhost)elseif state.tool == TOOLS.RECT thendrawRect(state.mouse.startX, state.mouse.startY, state.mouse.currX, state.mouse.currY, false, checkGhost)elseif state.tool == TOOLS.RECT_FILL thendrawRect(state.mouse.startX, state.mouse.startY, state.mouse.currX, state.mouse.currY, true, checkGhost)elseif state.tool == TOOLS.CIRCLE thendrawCircle(state.mouse.startX, state.mouse.startY, state.mouse.currX, state.mouse.currY, false, checkGhost)elseif state.tool == TOOLS.CIRCLE_FILL thendrawCircle(state.mouse.startX, state.mouse.startY, state.mouse.currX, state.mouse.currY, true, checkGhost)endif isGhost thenlocal gMat = getMaterial(ghostColor)if gMat thenbg = gMat.colorchar = gMat.symfg = colors.blackelsebg = COLORS.canvas_bgchar = "x"fg = colors.redendendendterm.setCursorPos(screenX, screenY)term.setBackgroundColor(bg)term.setTextColor(fg)term.write(char)endendend-- Draw Cursorlocal cx, cy = state.view.cursorX, state.view.cursorYlocal screenX = ox + cx - sxlocal screenY = oy + cy - sylocal w, h = term.getSize()if screenX >= ox and screenX < w and screenY >= oy and screenY < h - 2 thenterm.setCursorPos(screenX, screenY)if os.clock() % 0.8 < 0.4 thenterm.setBackgroundColor(colors.white)term.setTextColor(colors.black)elselocal matIdx = getBlock(cx, state.view.layer, cy)local mat = getMaterial(matIdx)if mat thenterm.setBackgroundColor(mat.color == colors.white and colors.black or colors.white)term.setTextColor(mat.color)elseterm.setBackgroundColor(colors.white)term.setTextColor(colors.black)endendlocal matIdx = getBlock(cx, state.view.layer, cy)local mat = getMaterial(matIdx)term.write(mat and mat.sym or "+")endend-- --- Logic ---local function applyTool(x, y, btn)local color = (btn == 1) and state.primaryColor or state.secondaryColorif state.tool == TOOLS.PENCIL thensetBlock(x, state.view.layer, y, color)elseif state.tool == TOOLS.BUCKET thenlocal target = getBlock(x, state.view.layer, y)floodFill(x, y, target, color)elseif state.tool == TOOLS.PICKER thenlocal picked = getBlock(x, state.view.layer, y)if btn == 1 then state.primaryColor = picked else state.secondaryColor = picked endstate.tool = TOOLS.PENCIL -- Auto switch backendendlocal function applyShape(x0, y0, x1, y1, btn)local color = (btn == 1) and state.primaryColor or state.secondaryColorlocal function plot(x, y)setBlock(x, state.view.layer, y, color)endif state.tool == TOOLS.LINE thendrawLine(x0, y0, x1, y1, plot)elseif state.tool == TOOLS.RECT thendrawRect(x0, y0, x1, y1, false, plot)elseif state.tool == TOOLS.RECT_FILL thendrawRect(x0, y0, x1, y1, true, plot)elseif state.tool == TOOLS.CIRCLE thendrawCircle(x0, y0, x1, y1, false, plot)elseif state.tool == TOOLS.CIRCLE_FILL thendrawCircle(x0, y0, x1, y1, true, plot)endendlocal function loadSchema()ui.clear()term.setCursorPos(1, 1)print("Load Schema")term.write("Filename: ")local name = read()if name == "" then return end-- Try to load fileif not fs.exists(name) thenif fs.exists(name .. ".json") then name = name .. ".json"elseif fs.exists(name .. ".txt") then name = name .. ".txt"elsestate.status = "File not found"returnendendlocal ok, schema, meta = parser.parseFile(nil, name)if ok thenlocal ok2, err = loadCanonical(schema, meta)if ok2 thenstate.status = "Loaded " .. nameelsestate.status = "Error loading: " .. errendelsestate.status = "Parse error: " .. schemaendendlocal function saveSchema()ui.clear()term.setCursorPos(1, 1)print("Save Schema")term.write("Filename: ")local name = read()if name == "" then return endif not name:find("%.json$") then name = name .. ".json" endlocal exportDef, info = exportVoxelDefinition()-- Inject file metadata if presentif state.fileMeta thenexportDef.meta = state.fileMetaendlocal f = fs.open(name, "w")f.write(json.encode(exportDef))f.close()state.status = "Saved to " .. nameendlocal function resizeCanvas()ui.clear()print("Resize Canvas")term.write("Width (" .. state.w .. "): ")local w = tonumber(read()) or state.wterm.write("Height/Depth (" .. state.h .. "): ")local h = tonumber(read()) or state.hterm.write("Layers (" .. state.d .. "): ")local d = tonumber(read()) or state.dstate.w = wstate.h = hstate.d = dendlocal function editPaletteItem(idx)ui.clear()term.setCursorPos(1, 1)print("Edit Palette Item #" .. idx)local current = state.palette[idx]term.write("ID (" .. current.id .. "): ")local newId = read()if newId == "" then newId = current.id endterm.write("Symbol (" .. current.sym .. "): ")local newSym = read()if newSym == "" then newSym = current.sym endnewSym = newSym:sub(1, 1)-- Color selection is tricky in text mode, let's skip for now or cycle-- For now, keep colorstate.palette[idx].id = newIdstate.palette[idx].sym = newSymstate.status = "Updated Item #" .. idxendlocal function updateSearchResults()state.searchResults = {}local query = state.searchQuery:lower()for _, item in ipairs(items) doif item.name:lower():find(query, 1, true) or item.id:lower():find(query, 1, true) thentable.insert(state.searchResults, item)endendstate.searchScroll = 0enddrawSearch = function()if not state.searchOpen then return endlocal w, h = term.getSize()local sw, sh = 24, 14local sx, sy = math.floor((w - sw)/2), math.floor((h - sh)/2)ui.drawFrame(sx, sy, sw, sh, "Item Search")-- Search Boxterm.setCursorPos(sx + 1, sy + 1)term.setBackgroundColor(colors.black)term.setTextColor(colors.white)term.write(state.searchQuery .. "_")local padding = sw - 2 - #state.searchQuery - 1if padding > 0 then term.write(string.rep(" ", padding)) end-- Results Listlocal maxLines = sh - 3for i = 1, maxLines dolocal idx = state.searchScroll + ilocal item = state.searchResults[idx]term.setCursorPos(sx + 1, sy + 2 + i)if item thenterm.setBackgroundColor(colors.black)term.setTextColor(item.color or colors.white)local label = item.name or item.idif #label > sw - 4 then label = label:sub(1, sw - 4) endterm.write(" " .. item.sym .. " " .. label)local pad = sw - 2 - 3 - #labelif pad > 0 then term.write(string.rep(" ", pad)) endelseterm.setBackgroundColor(COLORS.bg)term.write(string.rep(" ", sw - 2))endendend-- --- Main ---function designer.run(opts)opts = opts or {}resetState()if opts.palette thenstate.palette = {}for i, item in ipairs(opts.palette) dotable.insert(state.palette, {id = item.id,color = item.color,sym = item.sym})endendif opts.meta thenstate.fileMeta = opts.metaendif opts.schema thenlocal ok, err = loadCanonical(opts.schema, opts.metadata)if not ok thenreturn false, errendendstate.running = truewhile state.running dodrawUI()drawCanvas()drawMenu()drawInventory()drawSearch()drawDragItem()local event, p1, p2, p3 = os.pullEvent()if event == "char" and state.searchOpen thenstate.searchQuery = state.searchQuery .. p1updateSearchResults()elseif event == "mouse_scroll" and state.searchOpen thenlocal dir = p1state.searchScroll = math.max(0, state.searchScroll + dir)elseif event == "mouse_click" thenlocal btn, mx, my = p1, p2, p3state.mouse.screenX = mxstate.mouse.screenY = mylocal handled = false-- 0. Check Search (Topmost)if state.searchOpen thenlocal w, h = term.getSize()local sw, sh = 24, 14local sx, sy = math.floor((w - sw)/2), math.floor((h - sh)/2)if mx >= sx and mx < sx + sw and my >= sy and my < sy + sh then-- Inside Search Windowif my >= sy + 3 thenlocal idx = state.searchScroll + (my - (sy + 2))local item = state.searchResults[idx]if item thenstate.dragItem = { id = item.id, sym = item.sym, color = item.color }state.searchOpen = falseendendhandled = trueelsestate.searchOpen = falsehandled = trueendend-- 1. Check Menu (Topmost)if not handled and state.menuOpen thenlocal w, h = term.getSize()local menuX, menuY = w - 12, 2if mx >= menuX and mx < menuX + 12 and my >= menuY and my < menuY + 8 thenlocal idx = my - menuYlocal options = { "Resize", "Save", "Load", "Clear", "Inventory", "Quit" }if options[idx] thenif options[idx] == "Quit" then state.running = falseelseif options[idx] == "Inventory" then state.inventoryOpen = not state.inventoryOpenelseif options[idx] == "Resize" then resizeCanvas()elseif options[idx] == "Save" then saveSchema()elseif options[idx] == "Clear" then clearCanvas()elseif options[idx] == "Load" then loadSchema()endif options[idx] ~= "Inventory" then state.menuOpen = false endendhandled = trueelse-- Click outside menu closes itstate.menuOpen = falsehandled = true -- Consume clickendend-- 2. Check Inventory (Topmost)if not handled and state.inventoryOpen thenlocal w, h = term.getSize()local iw, ih = 18, 6local ix, iy = math.floor((w - iw)/2), math.floor((h - ih)/2)if mx >= ix and mx < ix + iw and my >= iy and my < iy + ih then-- Check slot clicklocal relX, relY = mx - ix - 1, my - iy - 1if relX >= 0 and relY >= 0 thenlocal col = math.floor(relX / 4)local row = relYif col >= 0 and col <= 3 and row >= 0 and row <= 3 thenlocal slot = row * 4 + col + 1local item = turtle.getItemDetail(slot)if item thenstate.dragItem = {id = item.name,sym = item.name:sub(11, 11):upper(),color = colors.white}endendendhandled = trueendend-- 3. Check [M] Buttonif not handled and mx >= 1 and mx <= 3 and my == 1 thenstate.menuOpen = not state.menuOpenhandled = trueend-- 4. Check Palette (Drop Target & Selection)local palX = 2 + state.w + 2if not handled and mx >= palX and mx <= palX + 18 then -- Expanded for Search buttonif my == 2 then-- Check Edit vs Searchif mx >= palX + 14 and mx <= palX + 17 thenstate.searchOpen = not state.searchOpenif state.searchOpen thenstate.searchQuery = ""updateSearchResults()endelseif mx <= palX + 13 thenstate.paletteEditMode = not state.paletteEditModeendhandled = trueelseif my >= 4 and my < 4 + #state.palette thenlocal idx = my - 3if state.paletteEditMode theneditPaletteItem(idx)elseif btn == 1 then state.primaryColor = idxelseif btn == 2 then state.secondaryColor = idx endendhandled = trueendend-- 5. Check Toolsif not handled and mx >= 1 and mx <= 3 and my >= 3 and my < 3 + 8 thenlocal idx = my - 2local toolsList = { TOOLS.PENCIL, TOOLS.LINE, TOOLS.RECT, TOOLS.RECT_FILL, TOOLS.CIRCLE, TOOLS.CIRCLE_FILL, TOOLS.BUCKET, TOOLS.PICKER }if toolsList[idx] then state.tool = toolsList[idx] endhandled = trueend-- 6. Check Canvasif not handled thenlocal cx = mx - state.view.offsetXlocal cy = my - state.view.offsetYif cx >= 0 and cx < state.w and cy >= 0 and cy < state.h thenstate.mouse.down = truestate.mouse.btn = btnstate.mouse.startX = cxstate.mouse.startY = cystate.mouse.currX = cxstate.mouse.currY = cyif state.tool == TOOLS.PENCIL or state.tool == TOOLS.BUCKET or state.tool == TOOLS.PICKER thenapplyTool(cx, cy, btn)endendendelseif event == "mouse_drag" thenlocal btn, mx, my = p1, p2, p3state.mouse.screenX = mxstate.mouse.screenY = mylocal cx = mx - state.view.offsetXlocal cy = my - state.view.offsetYif state.mouse.down then-- Clamp to canvascx = math.max(0, math.min(state.w - 1, cx))cy = math.max(0, math.min(state.h - 1, cy))state.mouse.currX = cxstate.mouse.currY = cystate.mouse.drag = trueif state.tool == TOOLS.PENCIL thenapplyTool(cx, cy, state.mouse.btn)endendelseif event == "mouse_up" thenlocal btn, mx, my = p1, p2, p3-- Handle Drag Drop to Paletteif state.dragItem thenlocal palX = 2 + state.w + 2if mx >= palX and mx <= palX + 15 and my >= 4 and my < 4 + #state.palette thenlocal idx = my - 3state.palette[idx].id = state.dragItem.idstate.palette[idx].sym = state.dragItem.symstate.status = "Assigned " .. state.dragItem.id .. " to slot " .. idxendstate.dragItem = nilendif state.mouse.down and state.mouse.drag then-- Commit shapeif state.tool == TOOLS.LINE or state.tool == TOOLS.RECT or state.tool == TOOLS.RECT_FILL or state.tool == TOOLS.CIRCLE thenapplyShape(state.mouse.startX, state.mouse.startY, state.mouse.currX, state.mouse.currY, state.mouse.btn)endendstate.mouse.down = falsestate.mouse.drag = falseelseif event == "key" thenlocal key = p1if state.searchOpen thenif key == keys.backspace thenstate.searchQuery = state.searchQuery:sub(1, -2)updateSearchResults()elseif key == keys.enter thenif #state.searchResults > 0 thenlocal item = state.searchResults[1]state.dragItem = { id = item.id, sym = item.sym, color = item.color }state.searchOpen = falseendelseif key == keys.up thenstate.searchScroll = math.max(0, state.searchScroll - 1)elseif key == keys.down thenstate.searchScroll = state.searchScroll + 1endelse-- Cursor Movementif key == keys.up thenstate.view.cursorY = math.max(0, state.view.cursorY - 1)if state.view.cursorY < state.view.scrollY then state.view.scrollY = state.view.cursorY endif state.mouse.drag then state.mouse.currY = state.view.cursorY endelseif key == keys.down thenstate.view.cursorY = math.min(state.h - 1, state.view.cursorY + 1)local h = term.getSize()local viewH = h - 2 - state.view.offsetYif state.view.cursorY >= state.view.scrollY + viewH then state.view.scrollY = state.view.cursorY - viewH + 1 endif state.mouse.drag then state.mouse.currY = state.view.cursorY endelseif key == keys.left thenstate.view.cursorX = math.max(0, state.view.cursorX - 1)if state.view.cursorX < state.view.scrollX then state.view.scrollX = state.view.cursorX endif state.mouse.drag then state.mouse.currX = state.view.cursorX endelseif key == keys.right thenstate.view.cursorX = math.min(state.w - 1, state.view.cursorX + 1)local w = term.getSize()local viewW = w - state.view.offsetXif state.view.cursorX >= state.view.scrollX + viewW then state.view.scrollX = state.view.cursorX - viewW + 1 endif state.mouse.drag then state.mouse.currX = state.view.cursorX end-- Actionselseif key == keys.space or key == keys.enter thenif state.tool == TOOLS.PENCIL or state.tool == TOOLS.BUCKET or state.tool == TOOLS.PICKER thenapplyTool(state.view.cursorX, state.view.cursorY, 1)else-- Shape tools: Toggle dragif not state.mouse.drag thenstate.mouse.startX = state.view.cursorXstate.mouse.startY = state.view.cursorYstate.mouse.currX = state.view.cursorXstate.mouse.currY = state.view.cursorYstate.mouse.drag = truestate.mouse.down = truestate.mouse.btn = 1elsestate.mouse.currX = state.view.cursorXstate.mouse.currY = state.view.cursorYapplyShape(state.mouse.startX, state.mouse.startY, state.mouse.currX, state.mouse.currY, 1)state.mouse.drag = falsestate.mouse.down = falseendend-- Paletteelseif key == keys.leftBracket thenstate.primaryColor = math.max(1, state.primaryColor - 1)elseif key == keys.rightBracket thenstate.primaryColor = math.min(#state.palette, state.primaryColor + 1)-- Tools (Number keys 1-8)elseif key >= keys.one and key <= keys.eight thenlocal idx = key - keys.one + 1local toolsList = { TOOLS.PENCIL, TOOLS.LINE, TOOLS.RECT, TOOLS.RECT_FILL, TOOLS.CIRCLE, TOOLS.CIRCLE_FILL, TOOLS.BUCKET, TOOLS.PICKER }if toolsList[idx] then state.tool = toolsList[idx] endendif key == keys.q then state.running = false endif key == keys.f thenstate.searchOpen = not state.searchOpenif state.searchOpen thenstate.searchQuery = ""updateSearchResults()endendif key == keys.s then saveSchema() endif key == keys.r then resizeCanvas() endif key == keys.c then clearCanvas() end -- Clear allif key == keys.pageUp then state.view.layer = math.min(state.d - 1, state.view.layer + 1) endif key == keys.pageDown then state.view.layer = math.max(0, state.view.layer - 1) endendendendif opts.returnSchema thenreturn exportCanonical()endenddesigner.loadCanonical = loadCanonicaldesigner.exportCanonical = exportCanonicaldesigner.exportVoxelDefinition = exportVoxelDefinitionreturn designer]=]addEmbeddedFile("lib/lib_designer.lua", lib_designer_part1 .. lib_designer_part2)addEmbeddedFile("factory/turtle_os.lua", [=[---@diagnostic disable: undefined-global-- Minimal require compat so this file can run even when Arcadesys didn't-- install a global require (eg. when invoked directly on CraftOS turtles).if type(package) ~= "table" then package = { path = "" } endif type(package.path) ~= "string" then package.path = package.path or "" endpackage.loaded = package.loaded or {}local function requireCompat(name)if package.loaded[name] ~= nil then return package.loaded[name] endlocal lastErrfor pattern in string.gmatch(package.path or "", "([^;]+)") dolocal candidate = pattern:gsub("%?", name)if fs.exists(candidate) and not fs.isDir(candidate) thenlocal fn, err = loadfile(candidate)if not fn thenlastErr = errelselocal ok, res = pcall(fn)if not ok thenlastErr = reselsepackage.loaded[name] = resreturn resendendendenderror(string.format("module '%s' not found%s", name, lastErr and (": " .. tostring(lastErr)) or ""))endlocal function ensurePackagePaths(baseDir)local root = baseDir == "" and "/" or baseDirlocal paths = {"/?.lua","/lib/?.lua",fs.combine(root, "?.lua"),fs.combine(root, "lib/?.lua"),fs.combine(root, "factory/?.lua"),fs.combine(root, "ui/?.lua"),fs.combine(root, "tools/?.lua"),}local current = package.path or ""if current ~= "" then table.insert(paths, current) endlocal seen, final = {}, {}for _, p in ipairs(paths) doif p and p ~= "" and not seen[p] thenseen[p] = truetable.insert(final, p)endendpackage.path = table.concat(final, ";")endlocal function detectBaseDir()if shell and shell.getRunningProgram thenreturn fs.getDir(shell.getRunningProgram())endif debug and debug.getinfo thenlocal info = debug.getinfo(1, "S")if info and info.source thenlocal src = info.sourceif src:sub(1, 1) == "@" then src = src:sub(2) endreturn fs.getDir(src)endendreturn ""endensurePackagePaths(detectBaseDir())local require = _G.require or requireCompat_G.require = requirelocal ui = require("lib_ui")local parser = require("lib_parser")local json = require("lib_json")local schema_utils = require("lib_schema")-- Hack to load factory without running it immediately_G.__FACTORY_EMBED__ = truelocal factory = require("factory")_G.__FACTORY_EMBED__ = nil-- Helper to pause before returninglocal function pauseAndReturn(retVal)print("\nOperation finished.")print("Press Enter to continue...")read()return retValend-- --- ACTIONS ---local function runMining(form)local length = 64local interval = 3local torch = 6for _, el in ipairs(form.elements) doif el.id == "length" then length = tonumber(el.value) or 64 endif el.id == "interval" then interval = tonumber(el.value) or 3 endif el.id == "torch" then torch = tonumber(el.value) or 6 endendui.clear()print("Starting Mining Operation...")print(string.format("Length: %d, Interval: %d", length, interval))sleep(1)factory.run({ "mine", "--length", tostring(length), "--branch-interval", tostring(interval), "--torch-interval", tostring(torch) })return pauseAndReturn("stay")endlocal function runTunnel()local length = 16local width = 1local height = 2local torch = 6local form = ui.Form("Tunnel Configuration")form:addInput("length", "Length", tostring(length))form:addInput("width", "Width", tostring(width))form:addInput("height", "Height", tostring(height))form:addInput("torch", "Torch Interval", tostring(torch))local result = form:run()if result == "cancel" then return "stay" endfor _, el in ipairs(form.elements) doif el.id == "length" then length = tonumber(el.value) or 16 endif el.id == "width" then width = tonumber(el.value) or 1 endif el.id == "height" then height = tonumber(el.value) or 2 endif el.id == "torch" then torch = tonumber(el.value) or 6 endendui.clear()print("Starting Tunnel Operation...")print(string.format("L: %d, W: %d, H: %d", length, width, height))sleep(1)factory.run({ "tunnel", "--length", tostring(length), "--width", tostring(width), "--height", tostring(height), "--torch-interval", tostring(torch) })return pauseAndReturn("stay")endlocal function runExcavate()local length = 8local width = 8local depth = 3local form = ui.Form("Excavation Configuration")form:addInput("length", "Length", tostring(length))form:addInput("width", "Width", tostring(width))form:addInput("depth", "Depth", tostring(depth))local result = form:run()if result == "cancel" then return "stay" endfor _, el in ipairs(form.elements) doif el.id == "length" then length = tonumber(el.value) or 8 endif el.id == "width" then width = tonumber(el.value) or 8 endif el.id == "depth" then depth = tonumber(el.value) or 3 endendui.clear()print("Starting Excavation Operation...")print(string.format("L: %d, W: %d, D: %d", length, width, depth))sleep(1)factory.run({ "excavate", "--length", tostring(length), "--width", tostring(width), "--depth", tostring(depth) })return pauseAndReturn("stay")endlocal function runTreeFarm()ui.clear()print("Starting Tree Farm...")sleep(1)factory.run({ "treefarm" })return pauseAndReturn("stay")endlocal function runPotatoFarm()local width = 9local length = 9local form = ui.Form("Potato Farm Configuration")form:addStepper("width", "Width", width, { min = 3, max = 25 })form:addStepper("length", "Length", length, { min = 3, max = 25 })local result = form:run()if result == "cancel" then return "stay" endfor _, el in ipairs(form.elements) doif el.id == "width" then width = tonumber(el.value) or 9 endif el.id == "length" then length = tonumber(el.value) or 9 endendui.clear()print("Starting Potato Farm Build...")print(string.format("W: %d, L: %d", width, length))sleep(1)factory.run({ "farm", "--farm-type", "potato", "--width", tostring(width), "--length", tostring(length) })return pauseAndReturn("stay")endlocal function runBuild(schemaFile)ui.clear()print("Starting Build Operation...")print("Schema: " .. schemaFile)endlocal function main()while true doui.clear()print("TurtleOS v2.0")print("-------------")local options = {{ text = "Tree Farm", action = runTreeFarm },{ text = "Potato Farm", action = runPotatoFarm },{ text = "Excavate", action = runExcavate },{ text = "Tunnel", action = runTunnel },{ text = "Mine", action = runMining },{ text = "Farm Designer", action = function()local sub = ui.Menu("Farm Designer")sub:addOption("Tree Farm Design", function()ui.clear()shell.run("factory_planner.lua", "--farm", "tree")end)sub:addOption("Potato Farm Design", function()ui.clear()shell.run("factory_planner.lua", "--farm", "potato")end)sub:addOption("Back", function() return "back" end)sub:run()end },{ text = "Exit", action = function() return "exit" end }}local menu = ui.Menu("Main Menu")for _, opt in ipairs(options) domenu:addOption(opt.text, opt.action)endlocal result = menu:run()if result == "exit" then break endendendmain()]=])addEmbeddedFile("factory/factory.lua", [=[local logger = require("lib_logger")local diagnostics = require("lib_diagnostics")local debug = debug-- Force reload of state modules to ensure updates are appliedlocal function requireForce(name)package.loaded[name] = nilreturn require(name)endlocal states = {INITIALIZE = requireForce("state_initialize"),CHECK_REQUIREMENTS = requireForce("state_check_requirements"),BUILD = requireForce("state_build"),MINE = requireForce("state_mine"),TREEFARM = requireForce("state_treefarm"),POTATOFARM = requireForce("state_potatofarm"),RESTOCK = requireForce("state_restock"),REFUEL = requireForce("state_refuel"),BLOCKED = requireForce("state_blocked"),ERROR = requireForce("state_error"),DONE = requireForce("state_done"),}local function mergeTables(base, extra)if type(base) ~= "table" thenbase = {}endif type(extra) == "table" thenfor key, value in pairs(extra) dobase[key] = valueendendreturn baseendlocal function buildPayload(ctx, extra)local payload = { context = diagnostics.snapshot(ctx) }if extra thenmergeTables(payload, extra)endreturn payloadendlocal function run(args)local ctx = {state = "INITIALIZE",config = {verbose = false,schemaPath = nil,},origin = { x = 0, y = 0, z = 0, facing = "north" },pointer = 1,schema = nil,strategy = nil,inventoryState = {},fuelState = {},retries = 0,}local index = 1while index <= #args dolocal value = args[index]if value == "--verbose" thenctx.config.verbose = trueelseif value == "mine" thenctx.config.mode = "mine"elseif value == "tunnel" thenctx.config.mode = "tunnel"elseif value == "excavate" thenctx.config.mode = "excavate"elseif value == "treefarm" thenctx.config.mode = "treefarm"-- ctx.state = "TREEFARM" -- Let INITIALIZE handle setupelseif value == "potatofarm" thenctx.config.mode = "potatofarm"elseif value == "farm" thenctx.config.mode = "farm"elseif value == "--farm-type" thenindex = index + 1ctx.config.farmType = args[index]elseif value == "--width" thenindex = index + 1ctx.config.width = tonumber(args[index])elseif value == "--height" thenindex = index + 1ctx.config.height = tonumber(args[index])elseif value == "--depth" thenindex = index + 1ctx.config.depth = tonumber(args[index])elseif value == "--length" thenindex = index + 1ctx.config.length = tonumber(args[index])elseif value == "--branch-interval" thenindex = index + 1ctx.config.branchInterval = tonumber(args[index])elseif value == "--branch-length" thenindex = index + 1ctx.config.branchLength = tonumber(args[index])elseif value == "--torch-interval" thenindex = index + 1ctx.config.torchInterval = tonumber(args[index])elseif not value:find("^--") and not ctx.config.schemaPath and ctx.config.mode ~= "mine" and ctx.config.mode ~= "farm" thenctx.config.schemaPath = valueendindex = index + 1endif not ctx.config.schemaPath and ctx.config.mode ~= "mine" and ctx.config.mode ~= "farm" thenctx.config.schemaPath = "schema.json"end-- Initialize loggerlocal logOpts = {level = ctx.config.verbose and "debug" or "info",timestamps = true}logger.attach(ctx, logOpts)ctx.logger:info("Agent starting...")-- Load previous state if availablelocal persistence = require("lib_persistence")local savedState = persistence.load(ctx)if savedState thenctx.logger:info("Resuming from saved state...")-- Merge saved state into contextmergeTables(ctx, savedState)-- Restore movement state explicitly if neededif ctx.movement thenlocal movement = require("lib_movement")movement.ensureState(ctx)-- Force the library to recognize the loaded position/facing-- (ensureState does this by checking ctx.movement, which we just loaded)endend-- Initial fuel checkif turtle and turtle.getFuelLevel thenlocal level = turtle.getFuelLevel()local limit = turtle.getFuelLimit()ctx.logger:info(string.format("Fuel: %s / %s", tostring(level), tostring(limit)))if level ~= "unlimited" and type(level) == "number" and level < 100 thenctx.logger:warn("Fuel is very low on startup!")-- Attempt emergency refuellocal fuelLib = require("lib_fuel")fuelLib.refuel(ctx, { target = 2000 })endend-- Helper to save statectx.save = function()persistence.save(ctx)endwhile ctx.state ~= "EXIT" do-- Save state before executing the next stepctx.save()local stateHandler = states[ctx.state]if not stateHandler thenctx.logger:error("Unknown state: " .. tostring(ctx.state), buildPayload(ctx))breakendctx.logger:debug("Entering state: " .. ctx.state)local ok, nextStateOrErr = pcall(stateHandler, ctx)if not ok thenlocal trace = debug and debug.traceback and debug.traceback() or nilctx.logger:error("Crash in state " .. ctx.state .. ": " .. tostring(nextStateOrErr),buildPayload(ctx, { error = tostring(nextStateOrErr), traceback = trace }))ctx.lastError = nextStateOrErrctx.state = "ERROR"elseif type(nextStateOrErr) ~= "string" or nextStateOrErr == "" thenctx.logger:error("State returned invalid transition", buildPayload(ctx, { result = tostring(nextStateOrErr) }))ctx.lastError = nextStateOrErrctx.state = "ERROR"elseif not states[nextStateOrErr] and nextStateOrErr ~= "EXIT" thenctx.logger:error("Transitioned to unknown state: " .. tostring(nextStateOrErr), buildPayload(ctx))ctx.state = "ERROR"elsectx.state = nextStateOrErrendend---@diagnostic disable-next-line: undefined-globalsleep(0)end-- Clear state on clean exitpersistence.clear(ctx)ctx.logger:info("Agent finished.")endlocal module = { run = run }---@diagnostic disable-next-line: undefined-fieldif not _G.__FACTORY_EMBED__ thenlocal argv = { ... }run(argv)endreturn module]=])addEmbeddedFile("factory/state_initialize.lua", [=[---@diagnostic disable: undefined-globallocal parser = require("lib_parser")local orientation = require("lib_orientation")local logger = require("lib_logger")local strategyTunnel = require("lib_strategy_tunnel")local strategyExcavate = require("lib_strategy_excavate")local strategyFarm = require("lib_strategy_farm")local ui = require("lib_ui")local startup = require("lib_startup")local inventory = require("lib_inventory")local function validateSchema(schema)if type(schema) ~= "table" then return false, "Schema is not a table" endlocal count = 0for _ in pairs(schema) do count = count + 1 endif count == 0 then return false, "Schema is empty" endreturn trueendlocal function getBlock(schema, x, y, z)local xLayer = schema[x] or schema[tostring(x)]if not xLayer then return nil endlocal yLayer = xLayer[y] or xLayer[tostring(y)]if not yLayer then return nil endreturn yLayer[z] or yLayer[tostring(z)]endlocal function isPlaceable(block)if not block then return false endlocal name = block.materialif not name or name == "" then return false endif name == "minecraft:air" or name == "air" then return false endreturn trueendlocal function computeApproachLocal(localPos, side)side = side or "down"if side == "up" thenreturn { x = localPos.x, y = localPos.y - 1, z = localPos.z }, sideelseif side == "down" thenreturn { x = localPos.x, y = localPos.y + 1, z = localPos.z }, sideelsereturn { x = localPos.x, y = localPos.y, z = localPos.z }, sideendendlocal function computeLocalXZ(bounds, x, z, orientationKey)local orient = orientation.resolveOrientationKey(orientationKey)local relativeX = x - bounds.minXlocal relativeZ = z - bounds.minZlocal localZ = - (relativeZ + 1)local localXif orient == "forward_right" thenlocalX = relativeX + 1elselocalX = - (relativeX + 1)endreturn localX, localZendlocal function normaliseBounds(info)if not info or not info.bounds then return nil, "missing_bounds" endlocal minB = info.bounds.minlocal maxB = info.bounds.maxif not (minB and maxB) then return nil, "missing_bounds" endlocal function norm(t, k) return tonumber(t[k]) endreturn {minX = norm(minB, "x") or 0,minY = norm(minB, "y") or 0,minZ = norm(minB, "z") or 0,maxX = norm(maxB, "x") or 0,maxY = norm(maxB, "y") or 0,maxZ = norm(maxB, "z") or 0,}endlocal function buildOrder(schema, info, opts)local bounds, err = normaliseBounds(info)if not bounds then return nil, err or "missing_bounds" endopts = opts or {}local offsetLocal = opts.offsetLocal or { x = 0, y = 0, z = 0 }local offsetXLocal = offsetLocal.x or 0local offsetYLocal = offsetLocal.y or 0local offsetZLocal = offsetLocal.z or 0-- Default to forward_left if not specifiedlocal orientKey = opts.orientation or "forward_left"local order = {}for y = bounds.minY, bounds.maxY dofor row = 0, bounds.maxZ - bounds.minZ dolocal z = bounds.minZ + rowlocal forward = (row % 2) == 0local xStart = forward and bounds.minX or bounds.maxXlocal xEnd = forward and bounds.maxX or bounds.minXlocal step = forward and 1 or -1local x = xStartwhile true dolocal block = getBlock(schema, x, y, z)if isPlaceable(block) thenlocal baseX, baseZ = computeLocalXZ(bounds, x, z, orientKey)local localPos = {x = baseX + offsetXLocal,y = y + offsetYLocal,z = baseZ + offsetZLocal,}local meta = (block and type(block.meta) == "table") and block.meta or nillocal side = (meta and meta.side) or "down"local approach, resolvedSide = computeApproachLocal(localPos, side)order[#order + 1] = {schemaPos = { x = x, y = y, z = z },localPos = localPos,approachLocal = approach,block = block,side = resolvedSide,}endif x == xEnd then break endx = x + stependendendreturn order, boundsendlocal function INITIALIZE(ctx)logger.log(ctx, "info", "Initializing...")-- Startup Logic (Fuel & Chests)if not ctx.chests thenctx.chests = startup.runChestSetup(ctx)endif not startup.runFuelCheck(ctx, ctx.chests) thenreturn "INITIALIZE"endif ctx.config.mode == "mine" thenlogger.log(ctx, "info", "Starting Branch Mine mode...")ctx.branchmine = {length = tonumber(ctx.config.length) or 60,branchInterval = tonumber(ctx.config.branchInterval) or 3,branchLength = tonumber(ctx.config.branchLength) or 16,torchInterval = tonumber(ctx.config.torchInterval) or 6,currentDist = 0,state = "SPINE",spineY = 0, -- Assuming we start at 0 relative to startchests = ctx.chests}ctx.nextState = "BRANCHMINE"return "CHECK_REQUIREMENTS"endif ctx.config.mode == "tunnel" thenlogger.log(ctx, "info", "Generating tunnel strategy...")local length = tonumber(ctx.config.length) or 16local width = tonumber(ctx.config.width) or 1local height = tonumber(ctx.config.height) or 2local torchInterval = tonumber(ctx.config.torchInterval) or 6ctx.strategy = strategyTunnel.generate(length, width, height, torchInterval)ctx.pointer = 1logger.log(ctx, "info", string.format("Tunnel Plan: %d steps.", #ctx.strategy))ctx.nextState = "MINE"return "CHECK_REQUIREMENTS"endif ctx.config.mode == "excavate" thenlogger.log(ctx, "info", "Generating excavation strategy...")local length = tonumber(ctx.config.length) or 8local width = tonumber(ctx.config.width) or 8local depth = tonumber(ctx.config.depth) or 3ctx.strategy = strategyExcavate.generate(length, width, depth)ctx.pointer = 1logger.log(ctx, "info", string.format("Excavation Plan: %d steps.", #ctx.strategy))ctx.nextState = "MINE"return "CHECK_REQUIREMENTS"endif ctx.config.mode == "treefarm" thenlogger.log(ctx, "info", "Starting Tree Farm mode...")ctx.treefarm = {width = tonumber(ctx.config.width) or 9,height = tonumber(ctx.config.height) or 9,currentX = 0,currentZ = 0, -- Using Z for the second dimension to match Minecraft coordinates usuallystate = "SCAN",chests = ctx.chests}return "TREEFARM"endif ctx.config.mode == "potatofarm" thenlogger.log(ctx, "info", "Starting Potato Farm mode...")ctx.potatofarm = {width = tonumber(ctx.config.width) or 9,height = tonumber(ctx.config.height) or 9,currentX = 0,currentZ = 0,nextX = 0,nextZ = 0,state = "SCAN",chests = ctx.chests}return "POTATOFARM"endif ctx.config.mode == "farm" thenlogger.log(ctx, "info", "Generating farm strategy...")local farmType = ctx.config.farmType or "tree"local width = tonumber(ctx.config.width) or 9local length = tonumber(ctx.config.length) or 9local schema = strategyFarm.generate(farmType, width, length)local valid, err = validateSchema(schema)if not valid thenctx.lastError = "Generated schema invalid: " .. tostring(err)return "ERROR"end-- Previewui.clear()ui.drawPreview(schema, 2, 2, 30, 15)term.setCursorPos(1, 18)print("Previewing " .. farmType .. " farm.")print("Press Enter to confirm, 'q' to quit.")local input = read()if input == "q" or input == "Q" thenreturn "DONE"end-- Normalize schema for buildOrder-- We need to calculate bounds manually since we don't have parser infolocal minX, maxX, minZ, maxZ = 9999, -9999, 9999, -9999local minY, maxY = 0, 1 -- Assuming 2 layers for nowfor sx, row in pairs(schema) dolocal nx = tonumber(sx)if nx thenif nx < minX then minX = nx endif nx > maxX then maxX = nx endfor sy, col in pairs(row) dofor sz, block in pairs(col) dolocal nz = tonumber(sz)if nz thenif nz < minZ then minZ = nz endif nz > maxZ then maxZ = nz endendendendendendctx.schema = schemactx.schemaInfo = {bounds = {min = { x = minX, y = minY, z = minZ },max = { x = maxX, y = maxY, z = maxZ }}}logger.log(ctx, "info", "Computing build strategy...")local order, boundsOrErr = buildOrder(ctx.schema, ctx.schemaInfo, ctx.config)if not order thenctx.lastError = "Failed to compute build order: " .. tostring(boundsOrErr)return "ERROR"endctx.strategy = orderctx.pointer = 1logger.log(ctx, "info", string.format("Plan: %d steps.", #order))ctx.nextState = "BUILD"return "CHECK_REQUIREMENTS"endif not ctx.config.schemaPath thenctx.lastError = "No schema path provided"return "ERROR"endlogger.log(ctx, "info", "Loading schema: " .. ctx.config.schemaPath)local ok, schemaOrErr, info = parser.parseFile(ctx, ctx.config.schemaPath, { formatHint = nil })if not ok thenctx.lastError = "Failed to parse schema: " .. tostring(schemaOrErr)return "ERROR"endctx.schema = schemaOrErrctx.schemaInfo = infolocal valid, err = validateSchema(ctx.schema)if not valid thenctx.lastError = "Loaded schema invalid: " .. tostring(err)return "ERROR"endlogger.log(ctx, "info", "Computing build strategy...")local order, boundsOrErr = buildOrder(ctx.schema, ctx.schemaInfo, ctx.config)if not order thenctx.lastError = "Failed to compute build order: " .. tostring(boundsOrErr)return "ERROR"endctx.strategy = orderctx.pointer = 1logger.log(ctx, "info", string.format("Plan: %d steps.", #order))-- Check for schema metadata to trigger next stateif ctx.schemaInfo and ctx.schemaInfo.meta thenlocal meta = ctx.schemaInfo.metaif meta.mode == "treefarm" thenlogger.log(ctx, "info", "Schema defines a Tree Farm. Will transition to TREEFARM after build.")ctx.onBuildComplete = "TREEFARM"-- Calculate dimensions from boundslocal bounds = ctx.schemaInfo.boundslocal width = (bounds.max.x - bounds.min.x) + 1local height = (bounds.max.z - bounds.min.z) + 1ctx.treefarm = {width = width,height = height,currentX = 0,currentZ = 0,state = "SCAN",chests = ctx.chests,useSchema = true -- Flag to tell TREEFARM to use schema locations}elseif meta.mode == "potatofarm" thenlogger.log(ctx, "info", "Schema defines a Potato Farm. Will transition to POTATOFARM after build.")ctx.onBuildComplete = "POTATOFARM"local bounds = ctx.schemaInfo.boundslocal width = (bounds.max.x - bounds.min.x) + 1local height = (bounds.max.z - bounds.min.z) + 1ctx.potatofarm = {width = width,height = height,currentX = 0,currentZ = 0,nextX = 0,nextZ = 0,state = "SCAN",chests = ctx.chests,useSchema = true}endendctx.nextState = "BUILD"return "CHECK_REQUIREMENTS"endreturn INITIALIZE]=])addEmbeddedFile("factory/state_check_requirements.lua", [=[---@diagnostic disable: undefined-globallocal inventory = require("lib_inventory")local logger = require("lib_logger")local fuel = require("lib_fuel")local diagnostics = require("lib_diagnostics")local movement = require("lib_movement")local MATERIAL_ALIASES = {["minecraft:potatoes"] = { "minecraft:potato" }, -- Blocks vs. item name["minecraft:water_bucket"] = { "minecraft:water_bucket_bucket" }, -- Allow buckets to satisfy water needs}local function countWithAliases(invCounts, material)local total = invCounts[material] or 0local aliases = MATERIAL_ALIASES[material]if aliases thenfor _, alias in ipairs(aliases) dototal = total + (invCounts[alias] or 0)endendreturn totalendlocal function buildPullList(missing)local pull = {}for mat, count in pairs(missing) dolocal aliases = MATERIAL_ALIASES[mat]if aliases thenfor _, alias in ipairs(aliases) dopull[alias] = math.max(pull[alias] or 0, count)endelsepull[mat] = countendendreturn pullendlocal function calculateRequirements(ctx, strategy)-- Potatofarm: assume soil is prepped at y=0; only require fuel and potatoes for replanting.if ctx.potatofarm thenlocal width = tonumber(ctx.potatofarm.width) or tonumber(ctx.config.width) or 9local height = tonumber(ctx.potatofarm.height) or tonumber(ctx.config.height) or 9-- Rough fuel budget: sweep the inner grid twice plus margin.local inner = math.max(1, (width - 2)) * math.max(1, (height - 2))local fuelNeeded = math.ceil(inner * 2.0) + 100local potatoesNeeded = inner -- enough to replant every spot oncereturn {fuel = fuelNeeded,materials = { ["minecraft:potato"] = potatoesNeeded }}endlocal reqs = {fuel = 0,materials = {}}-- Estimate fuel-- A simple heuristic: 1 fuel per step.if strategy thenreqs.fuel = #strategyend-- Add a safety margin for fuel (e.g. 10% + 100)reqs.fuel = math.ceil(reqs.fuel * 1.1) + 100-- Calculate materialsif ctx.config.mode == "mine" then-- Mining mode-- Check for torches if strategy has place_torchfor _, step in ipairs(strategy) doif step.type == "place_torch" thenreqs.materials["minecraft:torch"] = (reqs.materials["minecraft:torch"] or 0) + 1elseif step.type == "place_chest" thenreqs.materials["minecraft:chest"] = (reqs.materials["minecraft:chest"] or 0) + 1endendelse-- Build modefor _, step in ipairs(strategy) doif step.block and step.block.material thenlocal mat = step.block.materialreqs.materials[mat] = (reqs.materials[mat] or 0) + 1endendendreturn reqsendlocal function calculateBranchmineRequirements(ctx)local bm = ctx.branchmine or {}local length = tonumber(bm.length or ctx.config.length) or 60local branchInterval = tonumber(bm.branchInterval or ctx.config.branchInterval) or 3local branchLength = tonumber(bm.branchLength or ctx.config.branchLength) or 16local torchInterval = tonumber(bm.torchInterval or ctx.config.torchInterval) or 6branchInterval = math.max(branchInterval, 1)torchInterval = math.max(torchInterval, 1)branchLength = math.max(branchLength, 1)local branchPairs = math.floor(length / branchInterval)local branchTravel = branchPairs * (4 * branchLength + 4)local totalTravel = length + branchTravellocal reqs = {fuel = math.ceil(totalTravel * 1.1) + 100,materials = {}}local torchItem = ctx.config.torchItem or "minecraft:torch"local torchCount = math.max(1, math.floor(length / torchInterval))reqs.materials[torchItem] = torchCountreturn reqsendlocal function CHECK_REQUIREMENTS(ctx)logger.log(ctx, "info", "Checking requirements...")local reqsif ctx.branchmine thenreqs = calculateBranchmineRequirements(ctx)elseif ctx.config.mode == "mine" thenlogger.log(ctx, "warn", "Branchmine context missing, re-initializing...")ctx.branchmine = {length = tonumber(ctx.config.length) or 60,branchInterval = tonumber(ctx.config.branchInterval) or 3,branchLength = tonumber(ctx.config.branchLength) or 16,torchInterval = tonumber(ctx.config.torchInterval) or 6,currentDist = 0,state = "SPINE",spineY = 0,chests = ctx.chests}ctx.nextState = "BRANCHMINE"reqs = calculateBranchmineRequirements(ctx)elselocal strategy, errMsg = diagnostics.requireStrategy(ctx)if not strategy thenctx.lastError = errMsg or "Strategy missing"return "ERROR"endreqs = calculateRequirements(ctx, strategy)endend-- Assume dirt is already placed in the world; do not require the turtle to carry dirt.if reqs and reqs.materials thenreqs.materials["minecraft:dirt"] = nil-- Do not require water buckets for farm strategies; assume water is pre-placed in the world.reqs.materials["minecraft:water_bucket"] = nilendlocal invCounts = inventory.getCounts(ctx)local currentFuel = turtle.getFuelLevel()if currentFuel == "unlimited" then currentFuel = 999999 endif type(currentFuel) ~= "number" then currentFuel = 0 endlocal missing = {fuel = 0,materials = {}}local hasMissing = false-- Check fuelif currentFuel < reqs.fuel then-- Attempt to refuel from inventory or nearby sourcesprint("Attempting to refuel to meet requirements...")logger.log(ctx, "info", "Attempting to refuel to meet requirements...")fuel.refuel(ctx, { target = reqs.fuel, excludeItems = { "minecraft:torch" } })currentFuel = turtle.getFuelLevel()if currentFuel == "unlimited" then currentFuel = 999999 endif type(currentFuel) ~= "number" then currentFuel = 0 endendif currentFuel < reqs.fuel thenmissing.fuel = reqs.fuel - currentFuelhasMissing = trueend-- Check materialsfor mat, count in pairs(reqs.materials) do-- Assume water is pre-placed; treat requirement as satisfied.if mat == "minecraft:water_bucket" theninvCounts[mat] = countend-- Assume dirt is already available in the world (don't require the turtle to carry it).if mat == "minecraft:dirt" theninvCounts[mat] = countendlocal have = countWithAliases(invCounts, mat)-- Special handling for chests: allow any chest/barrel if "minecraft:chest" is requestedif mat == "minecraft:chest" and have < count thenlocal totalChests = 0for invMat, invCount in pairs(invCounts) doif invMat:find("chest") or invMat:find("barrel") or invMat:find("shulker") thentotalChests = totalChests + invCountendendif totalChests >= count thenhave = count -- Satisfiedendendif have < count thenmissing.materials[mat] = count - havehasMissing = trueendendif hasMissing thenprint("Checking nearby chests for missing items...")local pullList = buildPullList(missing.materials)if inventory.retrieveFromNearby(ctx, pullList) then-- Re-check inventoryinvCounts = inventory.getCounts(ctx)-- Re-apply assumptions (water/dirt) after re-checkfor mat, count in pairs(reqs.materials) doif mat == "minecraft:water_bucket" or mat == "minecraft:dirt" theninvCounts[mat] = countendendhasMissing = falsemissing.materials = {}for mat, count in pairs(reqs.materials) dolocal have = countWithAliases(invCounts, mat)if have < count thenmissing.materials[mat] = count - havehasMissing = trueendendendend-- If we're still missing items, check whether nearby chests have enough-- even if we can't hold them all at once (e.g., lots of water buckets).local nearby = nilif hasMissing thennearby = inventory.checkNearby(ctx, buildPullList(missing.materials))for mat, deficit in pairs(missing.materials) dolocal total = countWithAliases(invCounts, mat)total = total + (nearby[mat] or 0)local aliases = MATERIAL_ALIASES[mat]if aliases thenfor _, alias in ipairs(aliases) dototal = total + (nearby[alias] or 0)endend-- If the material is dirt, assume it's available in-world and treat as satisfied.if mat == "minecraft:dirt" thentotal = reqs.materials[mat] or totalendif total >= (reqs.materials[mat] or 0) thenmissing.materials[mat] = nilendend-- Recompute hasMissing after relaxing for nearby stockhasMissing = missing.fuel > 0for _ in pairs(missing.materials) dohasMissing = truebreakendendif not hasMissing thenlogger.log(ctx, "info", "All requirements met.")return ctx.nextState or "DONE"end-- Report missingprint("\n=== MISSING REQUIREMENTS ===")if missing.fuel > 0 thenprint(string.format("- Fuel: %d (Have %d, Need %d)", missing.fuel, currentFuel, reqs.fuel))endfor mat, count in pairs(missing.materials) doprint(string.format("- %s: %d", mat, count))end-- Check nearbynearby = nearby or inventory.checkNearby(ctx, missing.materials)local foundNearby = falsefor mat, count in pairs(nearby) doif not foundNearby thenprint("\n=== FOUND IN NEARBY CHESTS ===")foundNearby = trueendprint(string.format("- %s: %d", mat, count))endprint("\nPress Enter to re-check, or type 'q' then Enter to quit.")local input = read()if input == "q" or input == "Q" thenreturn "DONE"endreturn "CHECK_REQUIREMENTS"endreturn CHECK_REQUIREMENTS]=])addEmbeddedFile("factory/state_build.lua", [=[local movement = require("lib_movement")local placement = require("lib_placement")local inventory = require("lib_inventory")local fuelLib = require("lib_fuel")local logger = require("lib_logger")local orientation = require("lib_orientation")local diagnostics = require("lib_diagnostics")local world = require("lib_world")local startup = require("lib_startup")-- Try a direct move first; if blocked (e.g. chests around origin), climb to a clearance height,-- move horizontally, then descend. This avoids needing to dig storage blocks.local function travelToBuildTarget(ctx, targetPos)local moveOpts = { axisOrder = { "y", "x", "z" }, dig = true, attack = true }local ok, err = movement.goTo(ctx, targetPos, moveOpts)if ok thenreturn trueendlocal clearance = (ctx.config and ctx.config.travelClearance) or 2local current = ctx.movement and ctx.movement.position or { x = 0, y = 0, z = 0 }local hopY = math.max(current.y or 0, targetPos.y or 0) + clearancelocal path = {{ x = current.x, y = hopY, z = current.z },{ x = targetPos.x, y = hopY, z = targetPos.z },targetPos,}ok, err = movement.stepPath(ctx, path, moveOpts)if ok thenreturn trueendreturn false, errendlocal function BUILD(ctx)local strategy, errMsg = diagnostics.requireStrategy(ctx)if not strategy thenreturn "ERROR"endif not startup.runFuelCheck(ctx, ctx.chests, 100, 1000) thenreturn "BUILD"endlocal step = strategy[ctx.pointer]if not step thenif ctx.onBuildComplete thenreturn ctx.onBuildCompleteendreturn "DONE"end-- 1. Identify Materiallocal material = step.block.materialif not material thenlogger.log(ctx, "warn", "Step missing material")ctx.pointer = ctx.pointer + 1return "BUILD"end-- 2. Check Inventorylocal count = inventory.countMaterial(ctx, material)if count == 0 thenlogger.log(ctx, "warn", "Out of material: " .. material)ctx.missingMaterial = materialctx.resumeState = "BUILD"return "RESTOCK"end-- 3. Move to position-- Convert local approach position to world position-- We assume ctx.origin is where we started.-- Start one block forward and one to the right of the origin to avoid starting chests.local offset = (ctx.config and ctx.config.buildOffset) or { x = 1, y = 0, z = 1 }local targetPos = world.localToWorldRelative(ctx.origin, {x = (step.approachLocal.x or 0) + (offset.x or 0),y = (step.approachLocal.y or 0) + (offset.y or 0),z = (step.approachLocal.z or 0) + (offset.z or 0),})-- Use movement lib to go there with a hop-over fallback to avoid digging storage blocks.local ok, err = travelToBuildTarget(ctx, targetPos)if not ok thenlogger.log(ctx, "warn", "Movement blocked: " .. tostring(err))ctx.resumeState = "BUILD"return "BLOCKED"end-- 4. Place Block-- Ensure we are facing the right way if needed, or just place.-- placement.placeMaterial handles orientation if we pass 'side'.-- step.side is the side of the block to place ON.-- We are at 'approachLocal'.local placed, placeErr = placement.placeMaterial(ctx, material, {side = step.side,block = step.block,dig = true, -- Clear obstaclesattack = true})if not placed thenif placeErr == "already_present" then-- It's fineelselocal failureMsg = "Placement failed: " .. tostring(placeErr)logger.log(ctx, "warn", failureMsg)ctx.lastError = failureMsg-- Could be empty inventory (handled above?) or something else.-- If it's "out of items", we should restock.-- But placeMaterial might not return specific enough error.-- Let's assume if we had count > 0, it's an obstruction or failure.-- Retry?return "ERROR" -- For now, fail hard so we can debug.endendctx.pointer = ctx.pointer + 1ctx.retries = 0return "BUILD"endreturn BUILD]=])addEmbeddedFile("factory/state_mine.lua", [=[---@diagnostic disable: undefined-globallocal movement = require("lib_movement")local inventory = require("lib_inventory")local mining = require("lib_mining")local fuelLib = require("lib_fuel")local logger = require("lib_logger")local diagnostics = require("lib_diagnostics")local world = require("lib_world")local startup = require("lib_startup")local function localToWorld(ctx, localPos)return world.localToWorldRelative(ctx.origin, localPos)endlocal function selectTorch(ctx)local torchItem = ctx.config.torchItem or "minecraft:torch"local ok = inventory.selectMaterial(ctx, torchItem)if ok thenreturn true, torchItemendctx.missingMaterial = torchItemreturn false, torchItemendlocal function MINE(ctx)logger.log(ctx, "info", "State: MINE")if not startup.runFuelCheck(ctx, ctx.chests, 100, 1000) thenreturn "MINE"end-- Get current steplocal stepIndex = ctx.pointer or 1local strategy, errMsg = diagnostics.requireStrategy(ctx)if not strategy thenreturn "ERROR"endif stepIndex > #strategy thenreturn "DONE"endlocal step = strategy[stepIndex]-- Execute step based on typeif step.type == "move" thenlocal dest = localToWorld(ctx, step)local ok, err = movement.goTo(ctx, dest, { dig = true, attack = true })if not ok thenlogger.log(ctx, "warn", "Mining movement blocked: " .. tostring(err))ctx.resumeState = "MINE"if err == "blocked" thenreturn "BLOCKED"endctx.lastError = "Mining movement failed: " .. tostring(err)return "ERROR"endelseif step.type == "turn" thenif step.data == "left" thenmovement.turnLeft(ctx)elseif step.data == "right" thenmovement.turnRight(ctx)endelseif step.type == "mine_neighbors" thenmining.scanAndMineNeighbors(ctx)elseif step.type == "place_torch" thenlocal ok = selectTorch(ctx)if not ok thenlogger.log(ctx, "warn", "No torches to place. Skipping.")-- ctx.resumeState = "MINE"-- return "RESTOCK"else-- Try standard placement (works if there is space)if turtle.placeDown() then-- Successelseif turtle.placeUp() then-- Successelse-- Try placing behind (turn 180)movement.turnRight(ctx)movement.turnRight(ctx)-- Clear obstruction behindif turtle.detect() thenturtle.dig()endif turtle.place() then-- Successelse-- Try placing on the right wall (relative to original facing)movement.turnLeft(ctx)if turtle.detect() thenturtle.dig()endif turtle.place() then-- Successmovement.turnRight(ctx) -- Restore to facing behindelsemovement.turnRight(ctx) -- Restore to facing behind-- Last resort: Dig down and place in holeif turtle.digDown() thenturtle.placeDown()elselogger.log(ctx, "warn", "Failed to place torch")endendend-- Restore facingmovement.turnRight(ctx)movement.turnRight(ctx)endendelseif step.type == "dump_trash" thenlocal dumped = inventory.dumpTrash(ctx)if not dumped thenlogger.log(ctx, "debug", "dumpTrash failed (probably empty inventory)")endelseif step.type == "done" thenreturn "DONE"elseif step.type == "place_chest" thenlocal chestItem = ctx.config.chestItem or "minecraft:chest"local ok = inventory.selectMaterial(ctx, chestItem)-- Fallback: Try to find any chest/barrel if the specific one isn't foundif not ok theninventory.scan(ctx)local state = inventory.ensureState(ctx)for slot, item in pairs(state.slots) doif item.name:find("chest") or item.name:find("barrel") or item.name:find("shulker") thenturtle.select(slot)ok = truebreakendendendif not ok thenlocal msg = "Pre-flight check failed: Missing chest"logger.log(ctx, "error", msg)ctx.lastError = msgreturn "ERROR"endif not turtle.placeDown() thenif turtle.detectDown() thenturtle.digDown()if not turtle.placeDown() thenlocal msg = "Pre-flight check failed: Could not place chest"logger.log(ctx, "error", msg)ctx.lastError = msgreturn "ERROR"endelselocal msg = "Pre-flight check failed: Could not place chest"logger.log(ctx, "error", msg)ctx.lastError = msgreturn "ERROR"endendendctx.pointer = stepIndex + 1ctx.retries = 0return "MINE"endreturn MINE]=])addEmbeddedFile("factory/state_treefarm.lua", [=[---@diagnostic disable: undefined-globallocal movement = require("lib_movement")local inventory = require("lib_inventory")local fuelLib = require("lib_fuel")local logger = require("lib_logger")local wizard = require("lib_wizard")local startup = require("lib_startup")local farming = require("lib_farming")local function selectSapling(ctx)inventory.scan(ctx)local state = ctx.inventoryif not state or not state.slots then return false endfor slot, info in pairs(state.slots) doif info.name and info.name:find("sapling") thenif turtle.select(slot) thenreturn trueendendendreturn falseendlocal function TREEFARM(ctx)logger.log(ctx, "info", "TREEFARM State (Fix Applied)")local tf = ctx.treefarmif not tf then return "INITIALIZE" end-- 1. Fuel Checkif not startup.runFuelCheck(ctx, tf.chests) thenreturn "TREEFARM"end-- 2. State Machineif tf.state == "SCAN" then-- Determine target spotslocal spots = {}if tf.useSchema and ctx.schema then-- Extract sapling locations from schemafor xStr, yLayer in pairs(ctx.schema) dofor yStr, zLayer in pairs(yLayer) dofor zStr, block in pairs(zLayer) doif block.material and (block.material:find("sapling") or block.material:find("log")) thentable.insert(spots, { x = tonumber(xStr), z = tonumber(zStr) })endendendend-- Sort spots for consistent traversaltable.sort(spots, function(a, b)if a.x == b.x then return a.z < b.z endreturn a.x < b.xend)else-- Generate grid spotslocal treeW = tonumber(tf.width) or 8local treeH = tonumber(tf.height) or 8local limitX = (treeW * 2) - 1local limitZ = (treeH * 2) - 1for x = 0, limitX dofor z = 0, limitZ doif (x % 2 == 0) and (z % 2 == 0) thentable.insert(spots, { x = x, z = z })endendendendif not tf.spotIndex then tf.spotIndex = 1 endif tf.spotIndex > #spots thentf.state = "DEPOSIT"tf.spotIndex = 1return "TREEFARM"endlocal spot = spots[tf.spotIndex]local x = spot.xlocal z = spot.zlogger.log(ctx, "debug", "Checking tree at " .. x .. "," .. z)-- Fly over to avoid obstacleslocal hoverHeight = 6-- Offset by 2 to avoid home base and provide a return path (adjust as needed based on schema origin)-- If using schema, we assume schema coordinates are relative to start.-- Existing logic used xOffset=2, zOffset=2. Let's keep it for now but might need adjustment for schema.-- Actually, for schema, the coordinates are usually 0-based from the start.-- The build offset in state_build was {x=1, y=0, z=1}.-- So if schema has a block at 0,0,0, it was built at world relative 1,0,1.-- We should probably respect that offset.local offset = (ctx.config and ctx.config.buildOffset) or { x = 1, y = 0, z = 1 }local target = {x = x + (offset.x or 0),y = hoverHeight,z = z + (offset.z or 0)}-- Move to targetif not movement.goTo(ctx, target, { axisOrder = { "y", "x", "z" } }) thenlogger.log(ctx, "warn", "Path blocked to " .. x .. "," .. z)-- Try to clear path?-- For now, skip or retryelse-- Descend and harvest-- We are at (x, hoverHeight, z)while movement.getPosition(ctx).y > 1 dolocal hasDown, dataDown = turtle.inspectDown()if hasDown and (dataDown.name:find("log") or dataDown.name:find("leaves")) thenturtle.digDown()sleep(0.2)while turtle.suckDown() do sleep(0.1) endelseif hasDown and not dataDown.name:find("air") then-- Don't dig non-tree blocks if using schema, unless it's leaves/logs-- But trees grow leaves.-- If we are strictly above the sapling spot, we should be fine digging down to it.turtle.digDown()sleep(0.2)while turtle.suckDown() do sleep(0.1) endendif not movement.down(ctx) thenturtle.digDown() -- Try againsleep(0.2)while turtle.suckDown() do sleep(0.1) endendend-- Now at y=1. Check base (y=0).local hasDown, dataDown = turtle.inspectDown()if hasDown and dataDown.name:find("log") thenlogger.log(ctx, "info", "Timber! Found a tree at " .. x .. "," .. z .. ". Chopping it down.")turtle.digDown()sleep(0.2)while turtle.suckDown() do sleep(0.1) endhasDown = falseend-- Replant-- If using schema, we know this is a spot.if not hasDown or dataDown.name:find("air") or dataDown.name:find("sapling") then-- Try to find any saplingif selectSapling(ctx) thenlogger.log(ctx, "info", "Replanting sapling at " .. x .. "," .. z .. ".")turtle.placeDown()endendend-- Nexttf.spotIndex = tf.spotIndex + 1return "TREEFARM"elseif tf.state == "DEPOSIT" thenlocal ok, err = farming.deposit(ctx, {safeHeight = 6,chests = tf.chests,keepItems = { ["sapling"] = 16 },refuel = true})if not ok thenlogger.log(ctx, "error", "Deposit failed: " .. tostring(err))return "ERROR"endtf.state = "WAIT"return "TREEFARM"elseif tf.state == "WAIT" thenlogger.log(ctx, "info", "All done for now. Taking a nap while trees grow.")sleep(30)tf.state = "SCAN"tf.spotIndex = 1return "TREEFARM"endreturn "TREEFARM"endreturn TREEFARM]=])addEmbeddedFile("factory/state_blocked.lua", [=[local logger = require("lib_logger")local function BLOCKED(ctx)local resume = ctx.resumeState or "BUILD"logger.log(ctx, "warn", string.format("Movement blocked while executing %s. Retrying in 5 seconds...", resume))---@diagnostic disable-next-line: undefined-globalsleep(5)ctx.retries = (ctx.retries or 0) + 1if ctx.retries > 5 thenlocal message = string.format("Too many retries while resuming %s", resume)logger.log(ctx, "error", message)ctx.lastError = messagectx.resumeState = nilreturn "ERROR"endctx.resumeState = nil-- ctx.retries is NOT reset here, so it accumulates if the next attempt fails immediatelyreturn resumeendreturn BLOCKED]=])addEmbeddedFile("factory/state_error.lua", [=[local logger = require("lib_logger")local diagnostics = require("lib_diagnostics")local function ERROR(ctx)local message = tostring(ctx.lastError or "Unknown fatal error")if ctx.logger then-- Avoid dumping the full context snapshot to console as it is too largectx.logger:error("Fatal Error: " .. message)elselogger.log(ctx, "error", "Fatal Error: " .. message)endlocal crashOk, crashResult = logger.writeCrashFile(ctx, message)if crashOk and crashResult thenprint("Crash details saved to " .. crashResult)elseif not crashOk and crashResult thenlogger.log(ctx, "warn", "Failed to write crash file: " .. tostring(crashResult))endprint("Press Enter to exit...")---@diagnostic disable-next-line: undefined-globalread()return "EXIT"endreturn ERROR]=])addEmbeddedFile("factory/state_done.lua", [=[local movement = require("lib_movement")local logger = require("lib_logger")local function DONE(ctx)logger.log(ctx, "info", "Build complete!")movement.goTo(ctx, ctx.origin)return "EXIT"endreturn DONE]=])addEmbeddedFile("lib/lib_logger.lua", [=[---@diagnostic disable: undefined-globallocal logger = {}local diagnosticslocal diagnosticsOk, diagnosticsModule = pcall(require, "lib_diagnostics")if diagnosticsOk thendiagnostics = diagnosticsModuleendlocal DEFAULT_CRASH_FILE = "crashfile"local DEFAULT_LEVEL = "info"local DEFAULT_CAPTURE_LIMIT = 200local LEVEL_VALUE = {debug = 10,info = 20,warn = 30,error = 40,}local LEVEL_LABEL = {debug = "DEBUG",info = "INFO",warn = "WARN",error = "ERROR",}local LEVEL_ALIAS = {warning = "warn",err = "error",trace = "debug",verbose = "debug",fatal = "error",}local function isoTimestamp()if os and type(os.date) == "function" thenreturn os.date("!%Y-%m-%dT%H:%M:%SZ")endif os and type(os.clock) == "function" thenreturn string.format("%.03f", os.clock())endreturn nilendlocal function getCrashFilePath(ctx)if ctx thenlocal config = ctx.configif config and type(config.crashFile) == "string" and config.crashFile ~= "" thenreturn config.crashFileendif type(ctx.crashFilePath) == "string" and ctx.crashFilePath ~= "" thenreturn ctx.crashFilePathendendreturn DEFAULT_CRASH_FILEendlocal function buildCrashPayload(ctx, message, metadata)local payload = {message = message or "Unknown fatal error",metadata = metadata,timestamp = isoTimestamp(),}if diagnostics and ctx thenlocal ok, snapshot = pcall(diagnostics.snapshot, ctx)if ok thenpayload.context = snapshotendendif ctx and ctx.logger and type(ctx.logger.getLastEntry) == "function" thenlocal ok, entry = pcall(ctx.logger.getLastEntry, ctx.logger)if ok thenpayload.lastLogEntry = entryendendreturn payloadendlocal function serializeCrashPayload(payload)if textutils and type(textutils.serializeJSON) == "function" thenlocal ok, serialized = pcall(textutils.serializeJSON, payload, { compact = true })if ok thenreturn serializedendendif textutils and type(textutils.serialize) == "function" thenlocal ok, serialized = pcall(textutils.serialize, payload)if ok thenreturn serializedendendlocal parts = {}for key, value in pairs(payload or {}) doparts[#parts + 1] = tostring(key) .. "=" .. tostring(value)endtable.sort(parts)return table.concat(parts, "\n")endlocal function writeFile(path, contents)if not fs or type(fs.open) ~= "function" thenreturn false, "fs_unavailable"endlocal handle, err = fs.open(path, "w")if not handle thenreturn false, err or "open_failed"endhandle.write(contents)handle.close()return trueendlocal function copyTable(value, depth, seen)if type(value) ~= "table" thenreturn valueendif depth and depth <= 0 thenreturn valueendseen = seen or {}if seen[value] thenreturn "<recursive>"endseen[value] = truelocal result = {}for k, v in pairs(value) dolocal newKey = copyTable(k, depth and (depth - 1) or nil, seen)local newValue = copyTable(v, depth and (depth - 1) or nil, seen)result[newKey] = newValueendseen[value] = nilreturn resultendlocal function trySerializers(meta)if type(meta) ~= "table" thenreturn nilendif textutils and type(textutils.serialize) == "function" thenlocal ok, serialized = pcall(textutils.serialize, meta)if ok thenreturn serializedendendif textutils and type(textutils.serializeJSON) == "function" thenlocal ok, serialized = pcall(textutils.serializeJSON, meta)if ok thenreturn serializedendendreturn nilendlocal function formatMetadata(meta)if meta == nil thenreturn ""endlocal metaType = type(meta)if metaType == "string" thenreturn metaelseif metaType == "number" or metaType == "boolean" thenreturn tostring(meta)elseif metaType == "table" thenlocal serialized = trySerializers(meta)if serialized thenreturn serializedendlocal parts = {}local count = 0for key, value in pairs(meta) doparts[#parts + 1] = tostring(key) .. "=" .. tostring(value)count = count + 1if count >= 16 thenbreakendendtable.sort(parts)return "{" .. table.concat(parts, ", ") .. "}"endreturn tostring(meta)endlocal function formatMessage(message)if message == nil thenreturn ""endlocal msgType = type(message)if msgType == "string" thenreturn messageelseif msgType == "number" or msgType == "boolean" thenreturn tostring(message)elseif msgType == "table" thenif message.message and type(message.message) == "string" thenreturn message.messageendlocal metaView = formatMetadata(message)if metaView ~= "" thenreturn metaViewendendreturn tostring(message)endlocal function resolveLevel(level)if type(level) == "string" thenlocal lowered = level:lower()lowered = LEVEL_ALIAS[lowered] or loweredif LEVEL_VALUE[lowered] thenreturn loweredendreturn nilelseif type(level) == "number" thenlocal closestlocal distancefor name, value in pairs(LEVEL_VALUE) dolocal diff = math.abs(value - level)if not closest or diff < distance thenclosest = namedistance = diffendendreturn closestendreturn nilendlocal function levelValue(level)return LEVEL_VALUE[level] or LEVEL_VALUE[DEFAULT_LEVEL]endlocal function shouldEmit(level, thresholdValue)return levelValue(level) >= thresholdValueendlocal function formatTimestamp(state)if not state.timestamps thenreturn nil, nilendlocal fmt = state.timestampFormat or "%H:%M:%S"if os and type(os.date) == "function" thenlocal timeNumber = os.time and os.time() or nillocal stamp = os.date(fmt)return stamp, timeNumberendif os and type(os.clock) == "function" thenlocal clockValue = os.clock()return string.format("%.03f", clockValue), clockValueendreturn nil, nilendlocal function cloneEntry(entry)return copyTable(entry, 3)endlocal function pushHistory(state, entry)local history = state.historyhistory[#history + 1] = cloneEntry(entry)local limit = state.captureLimit or DEFAULT_CAPTURE_LIMITwhile #history > limit dotable.remove(history, 1)endendlocal function defaultWriterFactory(state)return function(entry)local segments = {}if entry.timestamp thensegments[#segments + 1] = entry.timestampelseif state.timestamps and state.lastTimestamp thensegments[#segments + 1] = state.lastTimestampendif entry.tag thensegments[#segments + 1] = entry.tagelseif state.tag thensegments[#segments + 1] = state.tagendsegments[#segments + 1] = entry.levelLabel or entry.levellocal prefix = "[" .. table.concat(segments, "][") .. "]"local line = prefix .. " " .. entry.messagelocal metaStr = formatMetadata(entry.metadata)if metaStr ~= "" thenline = line .. " | " .. metaStrendif print thenprint(line)elseif io and io.write thenio.write(line .. "\n")endendendlocal function addWriter(state, writer)if type(writer) ~= "function" thenreturn false, "invalid_writer"endfor _, existing in ipairs(state.writers) doif existing == writer thenreturn false, "writer_exists"endendstate.writers[#state.writers + 1] = writerreturn trueendlocal function logInternal(state, level, message, metadata)local resolved = resolveLevel(level)if not resolved thenreturn false, "unknown_level"endif not shouldEmit(resolved, state.thresholdValue) thenreturn false, "level_filtered"endlocal timestamp, timeNumber = formatTimestamp(state)state.lastTimestamp = timestamp or state.lastTimestamplocal entry = {level = resolved,levelLabel = LEVEL_LABEL[resolved],message = formatMessage(message),metadata = metadata,timestamp = timestamp,time = timeNumber,sequence = state.sequence + 1,tag = state.tag,}state.sequence = entry.sequencestate.lastEntry = entryif state.capture thenpushHistory(state, entry)endfor _, writer in ipairs(state.writers) dolocal ok, err = pcall(writer, entry)if not ok thenstate.lastWriterError = errendendreturn true, entryendfunction logger.new(opts)local state = {capture = opts and opts.capture or false,captureLimit = (opts and type(opts.captureLimit) == "number" and opts.captureLimit > 0) and opts.captureLimit or DEFAULT_CAPTURE_LIMIT,history = {},sequence = 0,writers = {},timestamps = opts and (opts.timestamps or opts.timestamp) or false,timestampFormat = opts and opts.timestampFormat or nil,tag = opts and (opts.tag or opts.label) or nil,}local initialLevel = (opts and resolveLevel(opts.level)) or (opts and resolveLevel(opts.minLevel)) or DEFAULT_LEVELstate.threshold = initialLevelstate.thresholdValue = levelValue(initialLevel)local instance = {}state.instance = instanceif not (opts and opts.silent) thenaddWriter(state, defaultWriterFactory(state))endif opts and type(opts.writer) == "function" thenaddWriter(state, opts.writer)endif opts and type(opts.writers) == "table" thenfor _, writer in ipairs(opts.writers) doif type(writer) == "function" thenaddWriter(state, writer)endendendfunction instance:log(level, message, metadata)return logInternal(state, level, message, metadata)endfunction instance:debug(message, metadata)return logInternal(state, "debug", message, metadata)endfunction instance:info(message, metadata)return logInternal(state, "info", message, metadata)endfunction instance:warn(message, metadata)return logInternal(state, "warn", message, metadata)endfunction instance:error(message, metadata)return logInternal(state, "error", message, metadata)endfunction instance:setLevel(level)local resolved = resolveLevel(level)if not resolved thenreturn false, "unknown_level"endstate.threshold = resolvedstate.thresholdValue = levelValue(resolved)return true, resolvedendfunction instance:getLevel()return state.thresholdendfunction instance:enableCapture(limit)state.capture = trueif type(limit) == "number" and limit > 0 thenstate.captureLimit = limitendreturn trueendfunction instance:disableCapture()state.capture = falsestate.history = {}return trueendfunction instance:getHistory()local result = {}for index = 1, #state.history doresult[index] = cloneEntry(state.history[index])endreturn resultendfunction instance:clearHistory()state.history = {}return trueendfunction instance:addWriter(writer)return addWriter(state, writer)endfunction instance:removeWriter(writer)if type(writer) ~= "function" thenreturn false, "invalid_writer"endfor index, existing in ipairs(state.writers) doif existing == writer thentable.remove(state.writers, index)return trueendendreturn false, "writer_missing"endfunction instance:setTag(tag)state.tag = tagreturn trueendfunction instance:getTag()return state.tagendfunction instance:getLastEntry()if not state.lastEntry thenreturn nilendreturn cloneEntry(state.lastEntry)endfunction instance:getLastWriterError()return state.lastWriterErrorendfunction instance:setTimestamps(enabled, format)state.timestamps = not not enabledif format thenstate.timestampFormat = formatendreturn trueendreturn instanceendfunction logger.attach(ctx, opts)if type(ctx) ~= "table" thenerror("logger.attach requires a context table", 2)endlocal instance = logger.new(opts)ctx.logger = instancereturn instanceendfunction logger.isLogger(candidate)if type(candidate) ~= "table" thenreturn falseendreturn type(candidate.log) == "function"and type(candidate.info) == "function"and type(candidate.warn) == "function"and type(candidate.error) == "function"endlogger.DEFAULT_LEVEL = DEFAULT_LEVELlogger.DEFAULT_CAPTURE_LIMIT = DEFAULT_CAPTURE_LIMITlogger.LEVELS = copyTable(LEVEL_VALUE, 1)logger.LABELS = copyTable(LEVEL_LABEL, 1)logger.resolveLevel = resolveLevellogger.DEFAULT_CRASH_FILE = DEFAULT_CRASH_FILEfunction logger.log(ctx, level, message)if type(ctx) ~= "table" thenreturnendlocal logInst = ctx.loggerif type(logInst) == "table" thenlocal fn = logInst[level]if type(fn) == "function" thenfn(logInst, message)returnendif type(logInst.log) == "function" thenlogInst.log(logInst, level, message)returnendendif (level == "warn" or level == "error") and message thenprint(string.format("[%s] %s", level:upper(), message))endendfunction logger.writeCrashFile(ctx, message, metadata)local path = getCrashFilePath(ctx)local payload = buildCrashPayload(ctx, message, metadata)local body = serializeCrashPayload(payload)if not body or body == "" thenbody = tostring(message or "Unknown fatal error")endlocal ok, err = writeFile(path, body .. "\n")if not ok thenreturn false, errendif ctx thenctx.crashFilePath = pathendreturn true, pathendreturn logger]=])addEmbeddedFile("lib/lib_diagnostics.lua", [=[local diagnostics = {}local function safeOrigin(origin)if type(origin) ~= "table" thenreturn nilendreturn {x = origin.x,y = origin.y,z = origin.z,facing = origin.facing}endlocal function normalizeStrategy(strategy)if type(strategy) == "table" thenreturn strategyendreturn nilendlocal function snapshot(ctx)if type(ctx) ~= "table" thenreturn { error = "missing context" }endlocal config = type(ctx.config) == "table" and ctx.config or {}local origin = safeOrigin(ctx.origin)local strategyLen = 0if type(ctx.strategy) == "table" thenstrategyLen = #ctx.strategyendlocal stampif os and type(os.time) == "function" thenstamp = os.time()endreturn {state = ctx.state,mode = config.mode,pointer = ctx.pointer,strategySize = strategyLen,retries = ctx.retries,missingMaterial = ctx.missingMaterial,lastError = ctx.lastError,origin = origin,timestamp = stamp}endlocal function requireStrategy(ctx)local strategy = normalizeStrategy(ctx.strategy)if strategy thenreturn strategyendlocal message = "Build strategy unavailable"if ctx and ctx.logger thenctx.logger:error(message, { context = snapshot(ctx) })endctx.lastError = ctx.lastError or messagereturn nil, messageenddiagnostics.snapshot = snapshotdiagnostics.requireStrategy = requireStrategyreturn diagnostics]=])addEmbeddedFile("lib/lib_movement.lua", [=[---@diagnostic disable: undefined-global, undefined-fieldlocal movement = {}local logger = require("lib_logger")local CARDINALS = {"north", "east", "south", "west"}local DIRECTION_VECTORS = {north = { x = 0, y = 0, z = -1 },east = { x = 1, y = 0, z = 0 },south = { x = 0, y = 0, z = 1 },west = { x = -1, y = 0, z = 0 },}local AXIS_FACINGS = {x = { positive = "east", negative = "west" },z = { positive = "south", negative = "north" },}local DEFAULT_SOFT_BLOCKS = {["minecraft:snow"] = true,["minecraft:snow_layer"] = true,["minecraft:powder_snow"] = true,["minecraft:tall_grass"] = true,["minecraft:large_fern"] = true,["minecraft:grass"] = true,["minecraft:fern"] = true,["minecraft:cave_vines"] = true,["minecraft:cave_vines_plant"] = true,["minecraft:kelp"] = true,["minecraft:kelp_plant"] = true,["minecraft:sweet_berry_bush"] = true,}local DEFAULT_SOFT_TAGS = {["minecraft:snow"] = true,["minecraft:replaceable_plants"] = true,["minecraft:flowers"] = true,["minecraft:saplings"] = true,["minecraft:carpets"] = true,}local DEFAULT_SOFT_NAME_HINTS = {"sapling","propagule","seedling",}local function cloneLookup(source)local lookup = {}for key, value in pairs(source) doif value thenlookup[key] = trueendendreturn lookupendlocal function extendLookup(lookup, entries)if type(entries) ~= "table" thenreturn lookupendif #entries > 0 thenfor _, name in ipairs(entries) doif type(name) == "string" thenlookup[name] = trueendendelsefor name, enabled in pairs(entries) doif enabled and type(name) == "string" thenlookup[name] = trueendendendreturn lookupendlocal function buildSoftNameHintList(configHints)local seen = {}local list = {}local function append(value)if type(value) ~= "string" thenreturnendlocal normalized = value:lower()if normalized == "" or seen[normalized] thenreturnendseen[normalized] = truelist[#list + 1] = normalizedendfor _, hint in ipairs(DEFAULT_SOFT_NAME_HINTS) doappend(hint)endif type(configHints) == "table" thenif #configHints > 0 thenfor _, entry in ipairs(configHints) doappend(entry)endelsefor name, enabled in pairs(configHints) doif enabled thenappend(name)endendendelseif type(configHints) == "string" thenappend(configHints)endreturn listendlocal function matchesSoftNameHint(hints, blockName)if type(blockName) ~= "string" thenreturn falseendlocal lowered = blockName:lower()for _, hint in ipairs(hints or {}) doif lowered:find(hint, 1, true) thenreturn trueendendreturn falseendlocal function isSoftBlock(state, inspectData)if type(state) ~= "table" or type(inspectData) ~= "table" thenreturn falseendlocal name = inspectData.nameif type(name) == "string" thenif state.softBlockLookup and state.softBlockLookup[name] thenreturn trueendif matchesSoftNameHint(state.softNameHints, name) thenreturn trueendendlocal tags = inspectData.tagsif type(tags) == "table" and state.softTagLookup thenfor tag, value in pairs(tags) doif value and state.softTagLookup[tag] thenreturn trueendendendreturn falseendlocal function canonicalFacing(name)if type(name) ~= "string" thenreturn nilendname = name:lower()if DIRECTION_VECTORS[name] thenreturn nameendreturn nilendlocal function copyPosition(pos)if not pos thenreturn { x = 0, y = 0, z = 0 }endreturn { x = pos.x or 0, y = pos.y or 0, z = pos.z or 0 }endlocal function vecAdd(a, b)return { x = (a.x or 0) + (b.x or 0), y = (a.y or 0) + (b.y or 0), z = (a.z or 0) + (b.z or 0) }endlocal function getPlannedMaterial(ctx, pos)if type(ctx) ~= "table" or type(pos) ~= "table" thenreturn nilendlocal plan = ctx.buildPlanif type(plan) ~= "table" thenreturn nilendlocal x = pos.xlocal xLayer = plan[x] or plan[tostring(x)]if type(xLayer) ~= "table" thenreturn nilendlocal y = pos.ylocal yLayer = xLayer[y] or xLayer[tostring(y)]if type(yLayer) ~= "table" thenreturn nilendlocal z = pos.zreturn yLayer[z] or yLayer[tostring(z)]endlocal function tryInspect(inspectFn)if type(inspectFn) ~= "function" thenreturn nilendlocal ok, success, data = pcall(inspectFn)if not ok or not success thenreturn nilendif type(data) == "table" thenreturn dataendreturn nilendlocal function ensureMovementState(ctx)if type(ctx) ~= "table" thenerror("movement library requires a context table", 2)endctx.movement = ctx.movement or {}local state = ctx.movementlocal cfg = ctx.config or {}if not state.position thenif ctx.origin thenstate.position = copyPosition(ctx.origin)elsestate.position = { x = 0, y = 0, z = 0 }endendif not state.homeFacing thenstate.homeFacing = canonicalFacing(cfg.homeFacing) or canonicalFacing(cfg.initialFacing) or "north"endif not state.facing thenstate.facing = canonicalFacing(cfg.initialFacing) or state.homeFacingendstate.position = copyPosition(state.position)if not state.softBlockLookup thenstate.softBlockLookup = extendLookup(cloneLookup(DEFAULT_SOFT_BLOCKS), cfg.movementSoftBlocks)endif not state.softTagLookup thenstate.softTagLookup = extendLookup(cloneLookup(DEFAULT_SOFT_TAGS), cfg.movementSoftTags)endif not state.softNameHints thenstate.softNameHints = buildSoftNameHintList(cfg.movementSoftNameHints)endstate.hasSoftClearRules = (next(state.softBlockLookup) ~= nil)or (next(state.softTagLookup) ~= nil)or ((state.softNameHints and #state.softNameHints > 0) or false)return stateendfunction movement.ensureState(ctx)return ensureMovementState(ctx)endfunction movement.getPosition(ctx)local state = ensureMovementState(ctx)return copyPosition(state.position)endfunction movement.setPosition(ctx, pos)local state = ensureMovementState(ctx)state.position = copyPosition(pos)return trueendfunction movement.getFacing(ctx)local state = ensureMovementState(ctx)return state.facingendfunction movement.setFacing(ctx, facing)local state = ensureMovementState(ctx)local canonical = canonicalFacing(facing)if not canonical thenreturn false, "unknown facing: " .. tostring(facing)endstate.facing = canonicallogger.log(ctx, "debug", "Set facing to " .. canonical)if ctx.save then ctx.save() endreturn trueendlocal function turn(ctx, direction)local state = ensureMovementState(ctx)if not turtle thenreturn false, "turtle API unavailable"endlocal rotateFnif direction == "left" thenrotateFn = turtle.turnLeftelseif direction == "right" thenrotateFn = turtle.turnRightelsereturn false, "invalid turn direction"endif not rotateFn thenreturn false, "turn function missing"endlocal ok = rotateFn()if not ok thenreturn false, "turn " .. direction .. " failed"endlocal current = state.facinglocal indexfor i, name in ipairs(CARDINALS) doif name == current thenindex = ibreakendendif not index thenindex = 1current = CARDINALS[index]endif direction == "left" thenindex = ((index - 2) % #CARDINALS) + 1elseindex = (index % #CARDINALS) + 1endstate.facing = CARDINALS[index]logger.log(ctx, "debug", "Turned " .. direction .. ", now facing " .. state.facing)if ctx.save then ctx.save() endreturn trueendfunction movement.turnLeft(ctx)return turn(ctx, "left")endfunction movement.turnRight(ctx)return turn(ctx, "right")endfunction movement.turnAround(ctx)local ok, err = movement.turnRight(ctx)if not ok thenreturn false, errendok, err = movement.turnRight(ctx)if not ok thenreturn false, errendreturn trueendfunction movement.faceDirection(ctx, targetFacing)local state = ensureMovementState(ctx)local canonical = canonicalFacing(targetFacing)if not canonical thenreturn false, "unknown facing: " .. tostring(targetFacing)endlocal currentIndexlocal targetIndexfor i, name in ipairs(CARDINALS) doif name == state.facing thencurrentIndex = iendif name == canonical thentargetIndex = iendendif not targetIndex thenreturn false, "cannot face unknown cardinal"endif currentIndex == targetIndex thenreturn trueendif not currentIndex thenstate.facing = canonicalreturn trueendlocal diff = (targetIndex - currentIndex) % #CARDINALSif diff == 0 thenreturn trueelseif diff == 1 thenreturn movement.turnRight(ctx)elseif diff == 2 thenlocal ok, err = movement.turnRight(ctx)if not ok thenreturn false, errendok, err = movement.turnRight(ctx)if not ok thenreturn false, errendreturn trueelse -- diff == 3return movement.turnLeft(ctx)endendlocal function getMoveConfig(ctx, opts)local cfg = ctx.config or {}local maxRetries = (opts and opts.maxRetries) or cfg.maxMoveRetries or 5local allowDig = opts and opts.digif allowDig == nil thenallowDig = cfg.digOnMoveif allowDig == nil thenallowDig = trueendendlocal allowAttack = opts and opts.attackif allowAttack == nil thenallowAttack = cfg.attackOnMoveif allowAttack == nil thenallowAttack = trueendendlocal delay = (opts and opts.retryDelay) or cfg.moveRetryDelay or 0.5return maxRetries, allowDig, allowAttack, delayendlocal function moveWithRetries(ctx, opts, moveFns, delta)local state = ensureMovementState(ctx)if not turtle thenreturn false, "turtle API unavailable"endlocal maxRetries, allowDig, allowAttack, delay = getMoveConfig(ctx, opts)if type(maxRetries) ~= "number" or maxRetries < 1 thenmaxRetries = 1elsemaxRetries = math.floor(maxRetries)endif (allowDig or state.hasSoftClearRules) and maxRetries < 2 then-- Ensure we attempt at least two cycles whenever we might clear obstructions.maxRetries = 2endlocal attempt = 0while attempt < maxRetries doattempt = attempt + 1local targetPos = vecAdd(state.position, delta)if moveFns.move() thenstate.position = targetPoslogger.log(ctx, "debug", string.format("Moved to x=%d y=%d z=%d", state.position.x, state.position.y, state.position.z))if ctx.save then ctx.save() endreturn trueendlocal handled = falseif allowAttack and moveFns.attack thenif moveFns.attack() thenhandled = truelogger.log(ctx, "debug", "Attacked entity blocking movement")endendlocal blocked = moveFns.detect and moveFns.detect() or falselocal inspectDataif blocked theninspectData = tryInspect(moveFns.inspect)endif blocked and moveFns.dig thenlocal plannedMateriallocal canClear = falselocal softBlock = inspectData and isSoftBlock(state, inspectData)if softBlock thencanClear = trueelseif allowDig thenplannedMaterial = getPlannedMaterial(ctx, targetPos)canClear = true-- Safety check: Do not dig chests/barrels unless explicitly allowedif inspectData and inspectData.name and (inspectData.name:find("chest") or inspectData.name:find("barrel")) thenif not opts or not opts.forceDigChests thencanClear = falselogger.log(ctx, "warn", "Refusing to dig chest/barrel at " .. tostring(inspectData.name))endendif plannedMaterial thenif inspectData and inspectData.name thenif inspectData.name == plannedMaterial thencanClear = falseendelsecanClear = falseendendendif canClear and moveFns.dig() thenhandled = trueif moveFns.suck thenmoveFns.suck()endif softBlock thenlocal foundName = inspectData and inspectData.name or "unknown"logger.log(ctx, "debug", string.format("Cleared soft obstruction %s at x=%d y=%d z=%d",tostring(foundName),targetPos.x or 0,targetPos.y or 0,targetPos.z or 0))elseif plannedMaterial thenlocal foundName = inspectData and inspectData.name or "unknown"logger.log(ctx, "debug", string.format("Cleared mismatched block %s (expected %s) at x=%d y=%d z=%d",tostring(foundName),tostring(plannedMaterial),targetPos.x or 0,targetPos.y or 0,targetPos.z or 0))elselocal foundName = inspectData and inspectData.nameif foundName thenlogger.log(ctx, "debug", string.format("Dug blocking block %s at x=%d y=%d z=%d",foundName,targetPos.x or 0,targetPos.y or 0,targetPos.z or 0))elselogger.log(ctx, "debug", string.format("Dug blocking block at x=%d y=%d z=%d",targetPos.x or 0,targetPos.y or 0,targetPos.z or 0))endendelseif plannedMaterial and not canClear and allowDig thenlogger.log(ctx, "debug", string.format("Preserving planned block %s at x=%d y=%d z=%d",tostring(plannedMaterial),targetPos.x or 0,targetPos.y or 0,targetPos.z or 0))endendif attempt < maxRetries thenif delay and delay > 0 and _G.sleep thensleep(delay)endendendlocal axisDelta = string.format("(dx=%d, dy=%d, dz=%d)", delta.x or 0, delta.y or 0, delta.z or 0)return false, "unable to move " .. axisDelta .. " after " .. tostring(maxRetries) .. " attempts"endfunction movement.forward(ctx, opts)local state = ensureMovementState(ctx)local facing = state.facing or "north"local delta = copyPosition(DIRECTION_VECTORS[facing])local moveFns = {move = turtle and turtle.forward or nil,detect = turtle and turtle.detect or nil,dig = turtle and turtle.dig or nil,attack = turtle and turtle.attack or nil,inspect = turtle and turtle.inspect or nil,suck = turtle and turtle.suck or nil,}if not moveFns.move thenreturn false, "turtle API unavailable"endreturn moveWithRetries(ctx, opts, moveFns, delta)endfunction movement.up(ctx, opts)local moveFns = {move = turtle and turtle.up or nil,detect = turtle and turtle.detectUp or nil,dig = turtle and turtle.digUp or nil,attack = turtle and turtle.attackUp or nil,inspect = turtle and turtle.inspectUp or nil,suck = turtle and turtle.suckUp or nil,}if not moveFns.move thenreturn false, "turtle API unavailable"endreturn moveWithRetries(ctx, opts, moveFns, { x = 0, y = 1, z = 0 })endfunction movement.down(ctx, opts)local moveFns = {move = turtle and turtle.down or nil,detect = turtle and turtle.detectDown or nil,dig = turtle and turtle.digDown or nil,attack = turtle and turtle.attackDown or nil,inspect = turtle and turtle.inspectDown or nil,suck = turtle and turtle.suckDown or nil,}if not moveFns.move thenreturn false, "turtle API unavailable"endreturn moveWithRetries(ctx, opts, moveFns, { x = 0, y = -1, z = 0 })endlocal function axisFacing(axis, delta)if delta > 0 thenreturn AXIS_FACINGS[axis].positiveelsereturn AXIS_FACINGS[axis].negativeendendlocal function moveAxis(ctx, axis, delta, opts)if delta == 0 thenreturn trueendif axis == "y" thenlocal moveFn = delta > 0 and movement.up or movement.downfor _ = 1, math.abs(delta) dolocal ok, err = moveFn(ctx, opts)if not ok thenreturn false, errendendreturn trueendlocal targetFacing = axisFacing(axis, delta)local ok, err = movement.faceDirection(ctx, targetFacing)if not ok thenreturn false, errendfor step = 1, math.abs(delta) dook, err = movement.forward(ctx, opts)if not ok thenreturn false, string.format("failed moving along %s on step %d: %s", axis, step, err or "unknown")endendreturn trueendfunction movement.goTo(ctx, targetPos, opts)ensureMovementState(ctx)if type(targetPos) ~= "table" thenreturn false, "target position must be a table"endlocal state = ctx.movementlocal axisOrder = (opts and opts.axisOrder) or (ctx.config and ctx.config.movementAxisOrder) or { "x", "z", "y" }for _, axis in ipairs(axisOrder) dolocal desired = targetPos[axis]if desired == nil thenreturn false, "target position missing axis " .. axisendlocal delta = desired - (state.position[axis] or 0)local ok, err = moveAxis(ctx, axis, delta, opts)if not ok thenreturn false, errendendreturn trueendfunction movement.stepPath(ctx, pathNodes, opts)if type(pathNodes) ~= "table" thenreturn false, "pathNodes must be a table"endfor index, node in ipairs(pathNodes) dolocal ok, err = movement.goTo(ctx, node, opts)if not ok thenreturn false, string.format("failed at path node %d: %s", index, err or "unknown")endendreturn trueendfunction movement.returnToOrigin(ctx, opts)ensureMovementState(ctx)if not ctx.origin thenreturn false, "ctx.origin is required"endlocal ok, err = movement.goTo(ctx, ctx.origin, opts)if not ok thenreturn false, errendlocal desiredFacing = (opts and opts.facing) or ctx.movement.homeFacingif desiredFacing thenok, err = movement.faceDirection(ctx, desiredFacing)if not ok thenreturn false, errendendreturn trueendfunction movement.turnLeftOf(facing)facing = world.normaliseFacing(facing)if facing == "north" thenreturn "west"elseif facing == "west" thenreturn "south"elseif facing == "south" thenreturn "east"else -- eastreturn "north"endendfunction movement.turnRightOf(facing)facing = world.normaliseFacing(facing)if facing == "north" thenreturn "east"elseif facing == "east" thenreturn "south"elseif facing == "south" thenreturn "west"else -- westreturn "north"endendfunction movement.turnBackOf(facing)facing = world.normaliseFacing(facing)if facing == "north" thenreturn "south"elseif facing == "south" thenreturn "north"elseif facing == "east" thenreturn "west"else -- westreturn "east"endendfunction movement.describePosition(ctx)local pos = movement.getPosition(ctx)local facing = movement.getFacing(ctx)return string.format("(x=%d, y=%d, z=%d, facing=%s)", pos.x, pos.y, pos.z, tostring(facing))endfunction movement.face(ctx, targetFacing)return movement.faceDirection(ctx, targetFacing)endreturn movement]=])addEmbeddedFile("lib/lib_fuel.lua", [=[---@diagnostic disable: undefined-globallocal movement = require("lib_movement")local inventory = require("lib_inventory")local table_utils = require("lib_table")local logger = require("lib_logger")local copyTable = table_utils.copy or table_utils.shallowCopy or function(tbl)local result = {}if type(tbl) ~= "table" thenreturn resultendfor k, v in pairs(tbl) doresult[k] = vendreturn resultendlocal fuel = {}local DEFAULT_THRESHOLD = 80local DEFAULT_RESERVE = 160local DEFAULT_SIDES = { "forward", "down", "up" }local DEFAULT_FUEL_ITEMS = {"minecraft:coal","minecraft:charcoal","minecraft:coal_block","minecraft:lava_bucket","minecraft:blaze_rod","minecraft:dried_kelp_block",}local function ensureFuelState(ctx)if type(ctx) ~= "table" thenerror("fuel library requires a context table", 2)endctx.fuelState = ctx.fuelState or {}local state = ctx.fuelStatelocal cfg = ctx.config or {}state.threshold = state.threshold or cfg.fuelThreshold or cfg.minFuel or DEFAULT_THRESHOLDstate.reserve = state.reserve or cfg.fuelReserve or math.max(DEFAULT_RESERVE, state.threshold * 2)state.fuelItems = state.fuelItems or (cfg.fuelItems and #cfg.fuelItems > 0 and table_utils.copyArray(cfg.fuelItems)) or table_utils.copyArray(DEFAULT_FUEL_ITEMS)state.sides = state.sides or (cfg.fuelChestSides and #cfg.fuelChestSides > 0 and table_utils.copyArray(cfg.fuelChestSides)) or table_utils.copyArray(DEFAULT_SIDES)state.cycleLimit = state.cycleLimit or cfg.fuelCycleLimit or cfg.inventoryCycleLimit or 192state.history = state.history or {}state.serviceActive = state.serviceActive or falsestate.lastLevel = state.lastLevel or nilreturn stateendfunction fuel.ensureState(ctx)return ensureFuelState(ctx)endlocal function readFuel()if not turtle or not turtle.getFuelLevel thenreturn nil, nil, falseendlocal level = turtle.getFuelLevel()local limit = turtle.getFuelLimit and turtle.getFuelLimit() or nilif level == "unlimited" or limit == "unlimited" thenreturn nil, nil, trueendif level == math.huge or limit == math.huge thenreturn nil, nil, trueendif type(level) ~= "number" thenreturn nil, nil, falseendif type(limit) ~= "number" thenlimit = nilendreturn level, limit, falseendlocal function resolveTarget(state, opts)opts = opts or {}local target = opts.target or 0if type(target) ~= "number" or target <= 0 thentarget = 0endlocal threshold = opts.threshold or state.threshold or 0local reserve = opts.reserve or state.reserve or 0if threshold > target thentarget = thresholdendif reserve > target thentarget = reserveendif target <= 0 thentarget = threshold > 0 and threshold or DEFAULT_THRESHOLDendreturn targetendlocal function resolveSides(state, opts)opts = opts or {}if type(opts.sides) == "table" and #opts.sides > 0 thenreturn table_utils.copyArray(opts.sides)endreturn table_utils.copyArray(state.sides)endlocal function resolveFuelItems(state, opts)opts = opts or {}if type(opts.fuelItems) == "table" and #opts.fuelItems > 0 thenreturn table_utils.copyArray(opts.fuelItems)endreturn table_utils.copyArray(state.fuelItems)endlocal function recordHistory(state, entry)state.history = state.history or {}state.history[#state.history + 1] = entrylocal limit = 20while #state.history > limit dotable.remove(state.history, 1)endendlocal function consumeFromInventory(ctx, target, opts)if not turtle or type(turtle.refuel) ~= "function" thenreturn false, { error = "turtle API unavailable" }endlocal before = select(1, readFuel())if before == nil thenreturn false, { error = "fuel unreadable" }endtarget = target or 0if target <= 0 thenreturn false, {consumed = {},startLevel = before,endLevel = before,note = "no_target",}endlocal level = beforelocal consumed = {}for slot = 1, 16 doif target > 0 and level >= target thenbreakendlocal item = turtle.getItemDetail(slot)local shouldSkip = falseif item and opts and opts.excludeItems thenfor _, pattern in ipairs(opts.excludeItems) doif item.name:find(pattern) thenshouldSkip = truebreakendendendif not shouldSkip thenturtle.select(slot)local count = turtle.getItemCount(slot)local canRefuel = count and count > 0 and turtle.refuel(0)if canRefuel thenwhile (target <= 0 or level < target) and turtle.getItemCount(slot) > 0 doif not turtle.refuel(1) thenbreakendconsumed[slot] = (consumed[slot] or 0) + 1level = select(1, readFuel()) or levelif target > 0 and level >= target thenbreakendendendendendlocal after = select(1, readFuel()) or levelif inventory.invalidate theninventory.invalidate(ctx)endreturn (after > before), {consumed = consumed,startLevel = before,endLevel = after,}endlocal function pullFromSources(ctx, state, opts, target)if not turtle thenreturn false, { error = "turtle API unavailable" }endinventory.ensureState(ctx)local sides = resolveSides(state, opts)local items = resolveFuelItems(state, opts)local pullAmount = opts and opts.pullAmountlocal pulled = {}local errors = {}local refueled = {}local attempts = 0local maxAttempts = opts and opts.maxPullAttempts or (#sides * #items)if maxAttempts < 1 thenmaxAttempts = #sides * #itemsendlocal cycleLimit = (opts and opts.inventoryCycleLimit) or state.cycleLimit or 192for _, side in ipairs(sides) dofor _, material in ipairs(items) doif attempts >= maxAttempts thenbreakendattempts = attempts + 1local ok, err = inventory.pullMaterial(ctx, material, pullAmount, {side = side,deferScan = true,cycleLimit = cycleLimit,})if ok thenpulled[#pulled + 1] = { side = side, material = material }logger.log(ctx, "debug", string.format("Pulled %s from %s", material, side))-- Immediately refresh inventory and attempt to use pulled items as fuelif turtle and type(turtle.refuel) == "function" then-- force a fresh scan so we can locate the pulled stacksinventory.ensureState(ctx)inventory.scan(ctx)local slots, _err = inventory.getMaterialSlots(ctx, material)if slots and #slots > 0 thenfor _, slot in ipairs(slots) dolocal detail = turtle.getItemDetail and turtle.getItemDetail(slot) or nillocal shouldSkip = falseif detail and opts and opts.excludeItems thenfor _, pattern in ipairs(opts.excludeItems) doif detail.name and detail.name:find(pattern) thenshouldSkip = truebreakendendendif shouldSkip thenlogger.log(ctx, "debug", string.format("Skipping refuel from %s (slot %d) due to excludeItems", material, slot))elselocal beforeLevel = select(1, readFuel()) or 0if turtle.refuel(0) thenturtle.select(slot)local consumedCount = 0while turtle.getItemCount and turtle.getItemCount(slot) > 0 do-- stop if we reached target (if provided)local current = select(1, readFuel()) or beforeLevelif target and target > 0 and current >= target thenbreakendif not turtle.refuel(1) thenbreakendconsumedCount = consumedCount + 1endif consumedCount > 0 thenrefueled[#refueled + 1] = { slot = slot, material = material, consumed = consumedCount }logger.log(ctx, "debug", string.format("Refueled using %d of %s from slot %d", consumedCount, material, slot))endendendendif #refueled > 0 theninventory.invalidate(ctx)inventory.scan(ctx)endendendelseif err ~= "missing_material" thenerrors[#errors + 1] = { side = side, material = material, error = err }logger.log(ctx, "warn", string.format("Pull %s from %s failed: %s", material, side, tostring(err)))endendif attempts >= maxAttempts thenbreakendendif #pulled > 0 theninventory.invalidate(ctx)endreturn #pulled > 0, { pulled = pulled, errors = errors, refueled = refueled }endlocal function refuelRound(ctx, state, opts, target, report)local consumed, info = consumeFromInventory(ctx, target, opts)report.steps[#report.steps + 1] = {type = "inventory",round = report.round,success = consumed,info = info,}if consumed thenlogger.log(ctx, "debug", string.format("Consumed %d fuel items from inventory", table_utils.sumValues(info and info.consumed)))endlocal level = select(1, readFuel())if level and level >= target and target > 0 thenreport.finalLevel = levelreport.reachedTarget = truereturn true, reportendlocal pullOpts = opts and copyTable(opts) or {}local missing = target - (level or 0)if missing > 0 then-- Avoid over-pulling unstackable fuels (e.g., lava buckets). Assume a conservative 1000 fuel per item.pullOpts.pullAmount = pullOpts.pullAmount or math.max(1, math.ceil(missing / 1000))endlocal pulled, pullInfo = pullFromSources(ctx, state, pullOpts, target)report.steps[#report.steps + 1] = {type = "pull",round = report.round,success = pulled,info = pullInfo,}if pulled thenlocal consumedAfterPull, postInfo = consumeFromInventory(ctx, target, opts)report.steps[#report.steps + 1] = {type = "inventory",stage = "post_pull",round = report.round,success = consumedAfterPull,info = postInfo,}if consumedAfterPull thenlogger.log(ctx, "debug", string.format("Post-pull consumption used %d fuel items", table_utils.sumValues(postInfo and postInfo.consumed)))local postLevel = select(1, readFuel())if postLevel and postLevel >= target and target > 0 thenreport.finalLevel = postLevelreport.reachedTarget = truereturn true, reportendendendreturn (pulled or consumed), reportendlocal function refuelInternal(ctx, state, opts)local startLevel, limit, unlimited = readFuel()if unlimited thenreturn true, {startLevel = startLevel,limit = limit,finalLevel = startLevel,unlimited = true,}endif not startLevel thenreturn true, {startLevel = nil,limit = limit,finalLevel = nil,message = "fuel level unavailable",}endlocal target = resolveTarget(state, opts)local report = {startLevel = startLevel,limit = limit,target = target,steps = {},}local rounds = opts and opts.rounds or 3if rounds < 1 thenrounds = 1endfor i = 1, rounds doreport.round = ilocal ok, roundReport = refuelRound(ctx, state, opts, target, report)report = roundReportif report.reachedTarget thenreturn true, reportendif not ok thenbreakendendreport.finalLevel = select(1, readFuel()) or startLevelif report.finalLevel and report.finalLevel >= target and target > 0 thenreport.reachedTarget = truereturn true, reportendreport.reachedTarget = target <= 0return report.reachedTarget, reportendfunction fuel.check(ctx, opts)local state = ensureFuelState(ctx)local level, limit, unlimited = readFuel()state.lastLevel = level or state.lastLevellocal report = {level = level,limit = limit,unlimited = unlimited,threshold = state.threshold,reserve = state.reserve,history = state.history,}if unlimited thenreport.ok = truereturn true, reportendif not level thenreport.ok = truereport.note = "fuel level unavailable"return true, reportendlocal threshold = opts and opts.threshold or state.threshold or 0report.threshold = thresholdreport.reserve = opts and opts.reserve or state.reservereport.ok = level >= thresholdreport.needsService = not report.okreport.depleted = level <= 0return report.ok, reportendfunction fuel.refuel(ctx, opts)local state = ensureFuelState(ctx)local ok, report = refuelInternal(ctx, state, opts)recordHistory(state, {type = "refuel",timestamp = os and os.time and os.time() or nil,success = ok,report = report,})if ok thenlogger.log(ctx, "info", string.format("Refuel complete (fuel=%s)", tostring(report.finalLevel or "unknown")))elselogger.log(ctx, "warn", "Refuel attempt did not reach target level")endreturn ok, reportendfunction fuel.ensure(ctx, opts)local state = ensureFuelState(ctx)local ok, report = fuel.check(ctx, opts)if ok thenreturn true, reportendif opts and opts.nonInteractive thenreturn false, reportendlocal serviceOk, serviceReport = fuel.service(ctx, opts)if not serviceOk thenreport.service = serviceReportreturn false, reportendreturn fuel.check(ctx, opts)endlocal function bootstrapFuel(ctx, state, opts, report)logger.log(ctx, "warn", "Fuel depleted; attempting to consume onboard fuel before navigating")local minimumMove = opts and opts.minimumMoveFuel or math.max(10, state.threshold or 0)if minimumMove <= 0 thenminimumMove = 10endlocal consumed, info = consumeFromInventory(ctx, minimumMove, opts)report.steps[#report.steps + 1] = {type = "inventory",stage = "bootstrap",success = consumed,info = info,}local level = select(1, readFuel()) or (info and info.endLevel) or report.startLevelreport.bootstrapLevel = levelif level <= 0 thenlogger.log(ctx, "error", "Fuel depleted; cannot move to origin")report.error = "out_of_fuel"report.finalLevel = levelreturn false, reportendreturn true, reportendlocal function runService(ctx, state, opts, report)state.serviceActive = truelogger.log(ctx, "info", "Entering SERVICE mode: returning to origin for refuel")local ok, err = movement.returnToOrigin(ctx, opts and opts.navigation)if not ok thenstate.serviceActive = falselogger.log(ctx, "error", "SERVICE return failed: " .. tostring(err))report.returnError = errreturn false, reportendreport.steps[#report.steps + 1] = { type = "return", success = true }local refuelOk, refuelReport = refuelInternal(ctx, state, opts)report.steps[#report.steps + 1] = {type = "refuel",success = refuelOk,report = refuelReport,}state.serviceActive = falserecordHistory(state, {type = "service",timestamp = os and os.time and os.time() or nil,success = refuelOk,report = report,})if not refuelOk thenlogger.log(ctx, "warn", "SERVICE refuel did not reach target level")report.finalLevel = select(1, readFuel()) or (refuelReport and refuelReport.finalLevel) or report.startLevelreturn false, reportendlocal finalLevel = select(1, readFuel()) or refuelReport.finalLevelreport.finalLevel = finalLevellogger.log(ctx, "info", string.format("SERVICE complete (fuel=%s)", tostring(finalLevel or "unknown")))return true, reportendfunction fuel.service(ctx, opts)local state = ensureFuelState(ctx)if state.serviceActive thenreturn false, { error = "service_already_active" }endinventory.ensureState(ctx)movement.ensureState(ctx)local level, limit, unlimited = readFuel()local report = {startLevel = level,limit = limit,steps = {},}if unlimited thenreport.note = "fuel is unlimited"return true, reportendif not level thenlogger.log(ctx, "warn", "Fuel level unavailable; skipping service")report.error = "fuel_unreadable"return false, reportendif level <= 0 thenlocal ok, bootstrapReport = bootstrapFuel(ctx, state, opts, report)if not ok thenreturn false, bootstrapReportendreport = bootstrapReportendreturn runService(ctx, state, opts, report)endfunction fuel.resolveFuelThreshold(ctx)local threshold = 0local function consider(value)if type(value) == "number" and value > threshold thenthreshold = valueendendif type(ctx.fuelState) == "table" thenlocal fuel = ctx.fuelStateconsider(fuel.threshold)consider(fuel.reserve)consider(fuel.min)consider(fuel.minFuel)consider(fuel.low)endif type(ctx.config) == "table" thenlocal cfg = ctx.configconsider(cfg.fuelThreshold)consider(cfg.fuelReserve)consider(cfg.minFuel)endreturn thresholdendfunction fuel.isFuelLow(ctx)if not turtle or not turtle.getFuelLevel thenreturn falseendlocal level = turtle.getFuelLevel()if level == "unlimited" thenreturn falseendif type(level) ~= "number" thenreturn falseendlocal threshold = fuel.resolveFuelThreshold(ctx)if threshold <= 0 thenreturn falseendreturn level <= thresholdendfunction fuel.describeFuel(io, report)if not io.print thenreturnendif report.unlimited thenio.print("Fuel: unlimited")returnendlocal levelText = report.level and tostring(report.level) or "unknown"local limitText = report.limit and ("/" .. tostring(report.limit)) or ""io.print(string.format("Fuel level: %s%s", levelText, limitText))if report.threshold thenio.print(string.format("Threshold: %d", report.threshold))endif report.reserve thenio.print(string.format("Reserve target: %d", report.reserve))endif report.needsService thenio.print("Status: below threshold (service required)")elseio.print("Status: sufficient for now")endendfunction fuel.describeService(io, report)if not io.print thenreturnendif not report thenio.print("No service report available.")returnendif report.returnError thenio.print("Return-to-origin failed: " .. tostring(report.returnError))endif report.steps thenfor _, step in ipairs(report.steps) doif step.type == "return" thenio.print("Return to origin: " .. (step.success and "OK" or "FAIL"))elseif step.type == "refuel" thenlocal info = step.report or {}local final = info.finalLevel ~= nil and info.finalLevel or (info.endLevel or "unknown")io.print(string.format("Refuel step: %s (final=%s)", step.success and "OK" or "FAIL", tostring(final)))endendendif report.finalLevel thenio.print("Service final fuel level: " .. tostring(report.finalLevel))endendreturn fuel]=])addEmbeddedFile("lib/lib_inventory.lua", [=[---@diagnostic disable: undefined-globallocal inventory = {}local movement = require("lib_movement")local logger = require("lib_logger")local SIDE_ACTIONS = {forward = {drop = turtle and turtle.drop or nil,suck = turtle and turtle.suck or nil,},up = {drop = turtle and turtle.dropUp or nil,suck = turtle and turtle.suckUp or nil,},down = {drop = turtle and turtle.dropDown or nil,suck = turtle and turtle.suckDown or nil,},}local PUSH_TARGETS = {"front","back","left","right","top","bottom","north","south","east","west","up","down",}local OPPOSITE_FACING = {north = "south",south = "north",east = "west",west = "east",}local CONTAINER_KEYWORDS = {"chest","barrel","shulker","crate","storage","inventory",}inventory.DEFAULT_TRASH = {["minecraft:air"] = true,["minecraft:stone"] = true,["minecraft:cobblestone"] = true,["minecraft:deepslate"] = true,["minecraft:cobbled_deepslate"] = true,["minecraft:tuff"] = true,["minecraft:diorite"] = true,["minecraft:granite"] = true,["minecraft:andesite"] = true,["minecraft:calcite"] = true,["minecraft:netherrack"] = true,["minecraft:end_stone"] = true,["minecraft:basalt"] = true,["minecraft:blackstone"] = true,["minecraft:gravel"] = true,["minecraft:dirt"] = true,["minecraft:coarse_dirt"] = true,["minecraft:rooted_dirt"] = true,["minecraft:mycelium"] = true,["minecraft:sand"] = true,["minecraft:red_sand"] = true,["minecraft:sandstone"] = true,["minecraft:red_sandstone"] = true,["minecraft:clay"] = true,["minecraft:dripstone_block"] = true,["minecraft:pointed_dripstone"] = true,["minecraft:bedrock"] = true,["minecraft:lava"] = true,["minecraft:water_bucket"] = true,}local function noop()endlocal function normalizeSide(value)if type(value) ~= "string" thenreturn nilendlocal lower = value:lower()if lower == "forward" or lower == "front" or lower == "fwd" thenreturn "forward"endif lower == "up" or lower == "top" or lower == "above" thenreturn "up"endif lower == "down" or lower == "bottom" or lower == "below" thenreturn "down"endreturn nilendlocal function resolveSide(ctx, opts)if type(opts) == "string" thenlocal direct = normalizeSide(opts)return direct or "forward"endlocal candidateif type(opts) == "table" thencandidate = opts.side or opts.direction or opts.facing or opts.containerSide or opts.defaultSideif not candidate and type(opts.location) == "string" thencandidate = opts.locationendendif not candidate and type(ctx) == "table" thenlocal cfg = ctx.configif type(cfg) == "table" thencandidate = cfg.inventorySide or cfg.materialSide or cfg.supplySide or cfg.defaultInventorySideendif not candidate and type(ctx.inventoryState) == "table" thencandidate = ctx.inventoryState.defaultSideendendlocal normalised = normalizeSide(candidate)if normalised thenreturn normalisedendreturn "forward"endlocal function tableCount(tbl)if type(tbl) ~= "table" thenreturn 0endlocal count = 0for _ in pairs(tbl) docount = count + 1endreturn countendlocal function copyArray(list)if type(list) ~= "table" thenreturn {}endlocal result = {}for index = 1, #list doresult[index] = list[index]endreturn resultendlocal function copySummary(summary)if type(summary) ~= "table" thenreturn {}endlocal result = {}for key, value in pairs(summary) doresult[key] = valueendreturn resultendlocal function copySlots(slots)if type(slots) ~= "table" thenreturn {}endlocal result = {}for slot, info in pairs(slots) doif type(info) == "table" thenresult[slot] = {slot = info.slot,count = info.count,name = info.name,detail = info.detail,}elseresult[slot] = infoendendreturn resultendlocal function hasContainerTag(tags)if type(tags) ~= "table" thenreturn falseendfor key, value in pairs(tags) doif value and type(key) == "string" thenlocal lower = key:lower()for _, keyword in ipairs(CONTAINER_KEYWORDS) doif lower:find(keyword, 1, true) thenreturn trueendendendendreturn falseendlocal function isContainerBlock(name, tags)if type(name) ~= "string" thenreturn falseendlocal lower = name:lower()for _, keyword in ipairs(CONTAINER_KEYWORDS) doif lower:find(keyword, 1, true) thenreturn trueendendreturn hasContainerTag(tags)endlocal function inspectForwardForContainer()if not turtle or type(turtle.inspect) ~= "function" thenreturn falseendlocal ok, data = turtle.inspect()if not ok or type(data) ~= "table" thenreturn falseendif isContainerBlock(data.name, data.tags) thenreturn true, dataendreturn falseendlocal function inspectUpForContainer()if not turtle or type(turtle.inspectUp) ~= "function" thenreturn falseendlocal ok, data = turtle.inspectUp()if not ok or type(data) ~= "table" thenreturn falseendif isContainerBlock(data.name, data.tags) thenreturn true, dataendreturn falseendlocal function inspectDownForContainer()if not turtle or type(turtle.inspectDown) ~= "function" thenreturn falseendlocal ok, data = turtle.inspectDown()if not ok or type(data) ~= "table" thenreturn falseendif isContainerBlock(data.name, data.tags) thenreturn true, dataendreturn falseendlocal function shouldSearchAllSides(opts)if type(opts) ~= "table" thenreturn trueendif opts.searchAllSides == false thenreturn falseendreturn trueendlocal function peripheralSideForDirection(side)if side == "forward" or side == "front" thenreturn "front"endif side == "up" or side == "top" thenreturn "top"endif side == "down" or side == "bottom" thenreturn "bottom"endreturn sideendlocal function computePrimaryPushDirection(ctx, periphSide)if periphSide == "front" thenlocal facing = movement.getFacing(ctx)if facing thenreturn OPPOSITE_FACING[facing]endelseif periphSide == "top" thenreturn "down"elseif periphSide == "bottom" thenreturn "up"endreturn nilendlocal function tryPushItems(chest, periphSide, slot, amount, targetSlot, primaryDirection)if type(chest) ~= "table" or type(chest.pushItems) ~= "function" thenreturn 0endlocal tried = {}local function attempt(direction)if not direction or tried[direction] thenreturn 0endtried[direction] = truelocal ok, movedif targetSlot thenok, moved = pcall(chest.pushItems, direction, slot, amount, targetSlot)elseok, moved = pcall(chest.pushItems, direction, slot, amount)endif ok and type(moved) == "number" and moved > 0 thenreturn movedendreturn 0endlocal moved = attempt(primaryDirection)if moved > 0 thenreturn movedendfor _, direction in ipairs(PUSH_TARGETS) domoved = attempt(direction)if moved > 0 thenreturn movedendendreturn 0endlocal function collectStacks(chest, material)local stacks = {}if type(chest) ~= "table" or not material thenreturn stacksendif type(chest.list) == "function" thenlocal ok, list = pcall(chest.list)if ok and type(list) == "table" thenfor slot, stack in pairs(list) dolocal numericSlot = tonumber(slot)if numericSlot and type(stack) == "table" thenlocal name = stack.name or stack.idlocal count = stack.count or stack.qty or stack.quantity or 0if name == material and type(count) == "number" and count > 0 thenstacks[#stacks + 1] = { slot = numericSlot, count = count }endendendendendif #stacks == 0 and type(chest.size) == "function" and type(chest.getItemDetail) == "function" thenlocal okSize, size = pcall(chest.size)if okSize and type(size) == "number" and size > 0 thenfor slot = 1, size dolocal okDetail, detail = pcall(chest.getItemDetail, slot)if okDetail and type(detail) == "table" thenlocal name = detail.namelocal count = detail.count or detail.qty or detail.quantity or 0if name == material and type(count) == "number" and count > 0 thenstacks[#stacks + 1] = { slot = slot, count = count }endendendendendtable.sort(stacks, function(a, b)return a.slot < b.slotend)return stacksendlocal function newContainerManifest()return {totals = {},slots = {},totalItems = 0,orderedSlots = {},size = nil,metadata = nil,}endlocal function addManifestEntry(manifest, slot, stack)if type(manifest) ~= "table" or type(slot) ~= "number" thenreturnendif type(stack) ~= "table" thenreturnendlocal name = stack.name or stack.idlocal count = stack.count or stack.qty or stack.quantity or stack.Countif type(name) ~= "string" or type(count) ~= "number" or count <= 0 thenreturnendmanifest.slots[slot] = {name = name,count = count,tags = stack.tags,nbt = stack.nbt,displayName = stack.displayName or stack.label or stack.Name,detail = stack,}manifest.totals[name] = (manifest.totals[name] or 0) + countmanifest.totalItems = manifest.totalItems + countendlocal function populateManifestSlots(manifest)local ordered = {}for slot in pairs(manifest.slots) doordered[#ordered + 1] = slotendtable.sort(ordered)manifest.orderedSlots = orderedlocal materials = {}for material in pairs(manifest.totals) domaterials[#materials + 1] = materialendtable.sort(materials)manifest.materials = materialsendlocal function attachMetadata(manifest, periphSide)if not peripheral thenreturnendlocal metadata = manifest.metadata or {}if type(peripheral.call) == "function" thenlocal okMeta, meta = pcall(peripheral.call, periphSide, "getMetadata")if okMeta and type(meta) == "table" thenmetadata.name = meta.name or metadata.namemetadata.displayName = meta.displayName or meta.label or metadata.displayNamemetadata.tags = meta.tags or metadata.tagsendendif type(peripheral.getType) == "function" thenlocal okType, perType = pcall(peripheral.getType, periphSide)if okType thenif type(perType) == "string" thenmetadata.peripheralType = perTypeelseif type(perType) == "table" and type(perType[1]) == "string" thenmetadata.peripheralType = perType[1]endendendif next(metadata) ~= nil thenmanifest.metadata = metadataendendlocal function readContainerManifest(periphSide)if not peripheral or type(peripheral.wrap) ~= "function" thenreturn nil, "peripheral_api_unavailable"endlocal wrapOk, chest = pcall(peripheral.wrap, periphSide)if not wrapOk or type(chest) ~= "table" thenreturn nil, "wrap_failed"endlocal manifest = newContainerManifest()if type(chest.list) == "function" thenlocal okList, list = pcall(chest.list)if okList and type(list) == "table" thenfor slot, stack in pairs(list) dolocal numericSlot = tonumber(slot)if numericSlot thenaddManifestEntry(manifest, numericSlot, stack)endendendendlocal haveSlots = next(manifest.slots) ~= nilif type(chest.size) == "function" thenlocal okSize, size = pcall(chest.size)if okSize and type(size) == "number" and size >= 0 thenmanifest.size = sizeif not haveSlots and type(chest.getItemDetail) == "function" thenfor slot = 1, size dolocal okDetail, detail = pcall(chest.getItemDetail, slot)if okDetail thenaddManifestEntry(manifest, slot, detail)endendendendendpopulateManifestSlots(manifest)attachMetadata(manifest, periphSide)return manifestendlocal function extractFromContainer(ctx, periphSide, material, amount, targetSlot)if not material or not peripheral or type(peripheral.wrap) ~= "function" thenreturn 0endlocal wrapOk, chest = pcall(peripheral.wrap, periphSide)if not wrapOk or type(chest) ~= "table" thenreturn 0endif type(chest.pushItems) ~= "function" thenreturn 0endlocal desired = amountif not desired or desired <= 0 thendesired = 64endlocal stacks = collectStacks(chest, material)if #stacks == 0 thenreturn 0endlocal remaining = desiredlocal transferred = 0local primaryDirection = computePrimaryPushDirection(ctx, periphSide)for _, stack in ipairs(stacks) dolocal available = stack.count or 0while remaining > 0 and available > 0 dolocal toMove = math.min(available, remaining, 64)local moved = tryPushItems(chest, periphSide, stack.slot, toMove, targetSlot, primaryDirection)if moved <= 0 thenbreakendtransferred = transferred + movedremaining = remaining - movedavailable = available - movedendif remaining <= 0 thenbreakendendreturn transferredendlocal function ensureChestAhead(ctx, opts)local frontOk, frontDetail = inspectForwardForContainer()if frontOk thenreturn true, noop, { side = "forward", detail = frontDetail }endif not shouldSearchAllSides(opts) thenreturn false, nil, nil, "container_not_found"endif not turtle thenreturn false, nil, nil, "turtle_api_unavailable"endmovement.ensureState(ctx)local startFacing = movement.getFacing(ctx)local function restoreFacing()if not startFacing thenreturnendif movement.getFacing(ctx) ~= startFacing thenlocal okFace, faceErr = movement.faceDirection(ctx, startFacing)if not okFace and faceErr thenlogger.log(ctx, "warn", "Failed to restore facing: " .. tostring(faceErr))endendendlocal function makeRestore()if not startFacing thenreturn noopendreturn function()restoreFacing()endend-- Check leftlocal ok, err = movement.turnLeft(ctx)if not ok thenrestoreFacing()return false, nil, nil, err or "turn_failed"endlocal leftOk, leftDetail = inspectForwardForContainer()if leftOk thenlogger.log(ctx, "debug", "Found container on left side; using that")return true, makeRestore(), { side = "left", detail = leftDetail }endok, err = movement.turnRight(ctx)if not ok thenrestoreFacing()return false, nil, nil, err or "turn_failed"end-- Check rightok, err = movement.turnRight(ctx)if not ok thenrestoreFacing()return false, nil, nil, err or "turn_failed"endlocal rightOk, rightDetail = inspectForwardForContainer()if rightOk thenlogger.log(ctx, "debug", "Found container on right side; using that")return true, makeRestore(), { side = "right", detail = rightDetail }endok, err = movement.turnLeft(ctx)if not ok thenrestoreFacing()return false, nil, nil, err or "turn_failed"end-- Check behindok, err = movement.turnRight(ctx)if not ok thenrestoreFacing()return false, nil, nil, err or "turn_failed"endok, err = movement.turnRight(ctx)if not ok thenrestoreFacing()return false, nil, nil, err or "turn_failed"endlocal backOk, backDetail = inspectForwardForContainer()if backOk thenlogger.log(ctx, "debug", "Found container behind; using that")return true, makeRestore(), { side = "back", detail = backDetail }endok, err = movement.turnLeft(ctx)if not ok thenrestoreFacing()return false, nil, nil, err or "turn_failed"endok, err = movement.turnLeft(ctx)if not ok thenrestoreFacing()return false, nil, nil, err or "turn_failed"endrestoreFacing()return false, nil, nil, "container_not_found"endlocal function ensureInventoryState(ctx)if type(ctx) ~= "table" thenerror("inventory library requires a context table", 2)endif type(ctx.inventoryState) ~= "table" thenctx.inventoryState = ctx.inventory or {}endctx.inventory = ctx.inventoryStatelocal state = ctx.inventoryStatestate.scanVersion = state.scanVersion or 0state.slots = state.slots or {}state.materialSlots = state.materialSlots or {}state.materialTotals = state.materialTotals or {}state.emptySlots = state.emptySlots or {}state.totalItems = state.totalItems or 0if state.dirty == nil thenstate.dirty = trueendreturn stateendfunction inventory.ensureState(ctx)return ensureInventoryState(ctx)endfunction inventory.invalidate(ctx)local state = ensureInventoryState(ctx)state.dirty = truereturn trueendlocal function fetchSlotDetail(slot)if not turtle thenreturn { slot = slot, count = 0 }endlocal detailif turtle.getItemDetail thendetail = turtle.getItemDetail(slot)endlocal countif turtle.getItemCount thencount = turtle.getItemCount(slot)elseif detail thencount = detail.countendcount = count or 0local name = detail and detail.name or nilreturn {slot = slot,count = count,name = name,detail = detail,}endfunction inventory.scan(ctx, opts)local state = ensureInventoryState(ctx)if not turtle thenstate.slots = {}state.materialSlots = {}state.materialTotals = {}state.emptySlots = {}state.totalItems = 0state.dirty = falsestate.scanVersion = state.scanVersion + 1return false, "turtle API unavailable"endlocal slots = {}local materialSlots = {}local materialTotals = {}local emptySlots = {}local totalItems = 0for slot = 1, 16 dolocal info = fetchSlotDetail(slot)slots[slot] = infoif info.count > 0 and info.name thenlocal list = materialSlots[info.name]if not list thenlist = {}materialSlots[info.name] = listendlist[#list + 1] = slotmaterialTotals[info.name] = (materialTotals[info.name] or 0) + info.counttotalItems = totalItems + info.countelseemptySlots[#emptySlots + 1] = slotendendstate.slots = slotsstate.materialSlots = materialSlotsstate.materialTotals = materialTotalsstate.emptySlots = emptySlotsstate.totalItems = totalItemsif os and type(os.clock) == "function" thenstate.lastScanClock = os.clock()elsestate.lastScanClock = nilendlocal epochFn = os and os["epoch"]if type(epochFn) == "function" thenstate.lastScanEpoch = epochFn("utc")elsestate.lastScanEpoch = nilendstate.scanVersion = state.scanVersion + 1state.dirty = falselogger.log(ctx, "debug", string.format("Inventory scan complete: %d items across %d materials", totalItems, tableCount(materialSlots)))return trueendlocal function ensureScanned(ctx, opts)local state = ensureInventoryState(ctx)if state.dirty or (type(opts) == "table" and opts.force) or not state.slots or next(state.slots) == nil thenlocal ok, err = inventory.scan(ctx, opts)if not ok and err thenreturn nil, errendendreturn stateendfunction inventory.getMaterialSlots(ctx, material, opts)if type(material) ~= "string" or material == "" thenreturn nil, "invalid_material"endlocal state, err = ensureScanned(ctx, opts)if not state thenreturn nil, errendlocal slots = state.materialSlots[material]if not slots or #slots == 0 thenreturn nil, "missing_material"endreturn copyArray(slots)endfunction inventory.count(ctx, material, opts)local state, err = ensureScanned(ctx, opts)if not state thenreturn 0endif material thenreturn state.materialTotals[material] or 0endreturn state.totalItemsendfunction inventory.select(ctx, slot)if type(slot) ~= "number" or slot < 1 or slot > 16 thenreturn false, "invalid_slot"endif not turtle thenreturn false, "turtle API unavailable"endif turtle.select(slot) thenreturn trueendreturn false, "select_failed"endfunction inventory.drop(ctx, slot, amount, side)if not turtle thenreturn false, "turtle API unavailable"endlocal ok, err = inventory.select(ctx, slot)if not ok thenreturn false, errendside = resolveSide(ctx, side)local action = SIDE_ACTIONS[side] and SIDE_ACTIONS[side].dropif not action thenreturn false, "invalid_side"endif action(amount) theninventory.invalidate(ctx)return trueendreturn false, "drop_failed"endfunction inventory.suck(ctx, amount, side)if not turtle thenreturn false, "turtle API unavailable"endside = resolveSide(ctx, side)local action = SIDE_ACTIONS[side] and SIDE_ACTIONS[side].suckif not action thenreturn false, "invalid_side"endif action(amount) theninventory.invalidate(ctx)return trueendreturn false, "suck_failed"endfunction inventory.dumpTrash(ctx, trashList, opts)local state, err = ensureScanned(ctx, opts)if not state thenreturn false, errendlocal toDump = {}local trashLookup = trashList or inventory.DEFAULT_TRASHfor slot, info in pairs(state.slots) doif info.name and trashLookup[info.name] thentoDump[#toDump + 1] = slotendendif #toDump == 0 thenreturn true, 0endlocal dumpedCount = 0for _, slot in ipairs(toDump) doif inventory.drop(ctx, slot, nil, opts) thendumpedCount = dumpedCount + 1endendreturn true, dumpedCountendfunction inventory.compact(ctx, opts)local state, err = ensureScanned(ctx, opts)if not state thenreturn false, errendlocal moves = 0local materials = {}for name, slots in pairs(state.materialSlots) doif #slots > 1 thenmaterials[name] = copyArray(slots)endendfor name, slots in pairs(materials) dolocal targetIndex = 1for i = 2, #slots dolocal sourceSlot = slots[i]local targetSlot = slots[targetIndex]local space = 64 - (state.slots[targetSlot].count or 0)if space > 0 theninventory.select(ctx, sourceSlot)if turtle.transferTo(targetSlot) thenmoves = moves + 1endif turtle.getItemCount(sourceSlot) == 0 then-- fully movedelse-- partially moved, target fulltargetIndex = iendelsetargetIndex = iendendendif moves > 0 theninventory.invalidate(ctx)inventory.scan(ctx)endreturn true, movesendfunction inventory.pullMaterial(ctx, material, amount, opts)if not material thenreturn false, "missing_material_name"end-- Check if we already have itlocal current = inventory.count(ctx, material, opts)if amount and current >= amount thenreturn true, { count = current, alreadyHad = true }endlocal needed = amount and (amount - current) or 64local side = resolveSide(ctx, opts)local periphSide = peripheralSideForDirection(side)-- Try to find containerlocal containerOk, restoreFn, containerInfo = ensureChestAhead(ctx, {side = side,searchAllSides = (opts and opts.searchAllSides),})if not containerOk thenreturn false, containerInfo or "container_not_found"end-- If we found a container on a different side, update periphSideif containerInfo and containerInfo.side thenperiphSide = peripheralSideForDirection(containerInfo.side)end-- Attempt extractionlocal transferred = extractFromContainer(ctx, periphSide, material, needed)if restoreFn thenrestoreFn()endinventory.invalidate(ctx)inventory.scan(ctx)local finalCount = inventory.count(ctx, material)if amount and finalCount < amount thenreturn false, "insufficient_items", {requested = amount,got = finalCount,missing = amount - finalCount,}endreturn true, { count = finalCount, transferred = transferred }endreturn inventory]=])addEmbeddedFile("lib/lib_network.lua", [=[local network = {}local PROTOCOL = "ARCADESYS_FACTORY"local PING_MESSAGE = "PING"local PONG_MESSAGE = "PONG"local SEND_SCHEMA_MESSAGE = "SEND_SCHEMA"function network.openModem()local modem = peripheral.find("modem", function(name, wrapped)return wrapped.isWireless()end)if modem thenrednet.open(peripheral.getName(modem))return trueendreturn falseendfunction network.closeModem()local modem = peripheral.find("modem", function(name, wrapped)return wrapped.isWireless()end)if modem thenrednet.close(peripheral.getName(modem))endendfunction network.broadcastPresence(label)if not rednet.isOpen() then return endrednet.broadcast({type = PONG_MESSAGE,id = os.getComputerID(),label = label or os.getComputerLabel() or "Turtle " .. os.getComputerID()}, PROTOCOL)endfunction network.findDevices(timeout)if not rednet.isOpen() then return {} endrednet.broadcast({ type = PING_MESSAGE }, PROTOCOL)local devices = {}local timer = os.startTimer(timeout or 2)while true dolocal event, senderId, message, protocol = os.pullEvent()if event == "timer" and senderId == timer thenbreakelseif event == "rednet_message" and protocol == PROTOCOL thenif type(message) == "table" and message.type == PONG_MESSAGE thentable.insert(devices, {id = senderId,label = message.label})endendendreturn devicesendfunction network.sendSchema(targetId, filename, content)if not rednet.isOpen() then return false endrednet.send(targetId, {type = SEND_SCHEMA_MESSAGE,filename = filename,content = content}, PROTOCOL)return trueendfunction network.listen(callback)if not rednet.isOpen() then return endwhile true dolocal senderId, message, protocol = rednet.receive(PROTOCOL)if type(message) == "table" thenif message.type == PING_MESSAGE thennetwork.broadcastPresence()elseif message.type == SEND_SCHEMA_MESSAGE thenif callback thencallback(senderId, message.filename, message.content)endendendendendreturn network]=])-- END_EMBEDDED_FILESlocal function log(msg)print("[install] " .. msg)endlocal function readAll(handle)local content = handle.readAll()handle.close()return contentendlocal function fetch(url)if not http thenreturn nil, "HTTP API is disabled"endlocal response, err = http.get(url)if not response thenreturn nil, err or "unknown HTTP error"endreturn readAll(response)endlocal function decodeJson(payload)local ok, result = pcall(textutils.unserializeJSON, payload)if not ok thenreturn nil, "Invalid JSON: " .. tostring(result)endreturn resultendlocal function promptConfirm()term.write("This will ERASE everything except the ROM. Continue? (y/N) ")local reply = string.lower(read() or "")return reply == "y" or reply == "yes"endlocal function sanitizeManifest(manifest)if type(manifest) ~= "table" thenreturn nil, "Manifest is not a table"endif type(manifest.files) ~= "table" or #manifest.files == 0 thenreturn nil, "Manifest contains no files"endreturn manifestendlocal function loadManifest(url)if not url thenreturn nil, "No manifest URL provided"endlog("Fetching manifest from " .. url)local body, err = fetch(url)if not body thenreturn nil, errendlocal manifest, decodeErr = decodeJson(body)if not manifest thenreturn nil, decodeErrendlocal valid, reason = sanitizeManifest(manifest)if not valid thenreturn nil, reasonendreturn manifestendlocal function downloadFiles(manifest)local bundle = {name = manifest.name or "Workstation",version = manifest.version or "unknown",files = {},}for _, file in ipairs(manifest.files) doif not file.path thenreturn nil, "File entry missing 'path'"endif file.content thentable.insert(bundle.files, { path = file.path, content = file.content })elseif file.url thenlog("Downloading " .. file.path)local data, err = fetch(file.url)if not data thenreturn nil, err or ("Failed to download " .. file.url)endtable.insert(bundle.files, { path = file.path, content = data })elsereturn nil, "File entry for " .. file.path .. " needs 'url' or 'content'"endendreturn bundleendlocal function formatDisk()log("Formatting computer...")for _, entry in ipairs(fs.list("/")) doif entry ~= "rom" thenfs.delete(entry)endendendlocal function writeFile(path, content)local dir = fs.getDir(path)if dir ~= "" thenfs.makeDir(dir)endlocal handle = fs.open(path, "wb") or fs.open(path, "w")if not handle thenerror("Unable to write to " .. path)endhandle.write(content)handle.close()endlocal function installImage(image)log("Installing " .. (image.name or "Workstation") .. " (" .. (image.version or "unknown") .. ")")for _, file in ipairs(image.files) dowriteFile(file.path, file.content or "")endendlocal function summarizeInstall(image)local files = image.files or {}print("")print("Install summary:")print(string.format(" - Name: %s", image.name or "Workstation"))print(string.format(" - Version: %s", image.version or "unknown"))print(string.format(" - Files installed: %d", #files))for _, file in ipairs(files) doif file.path thenprint("   * " .. file.path)endendendlocal function main()local manifestUrl = tArgs[1] or DEFAULT_MANIFEST_URLif manifestUrl == "embedded" thenlog("Using embedded Workstation image only.")elseif not http thenlog("HTTP is disabled; falling back to embedded image.")manifestUrl = "embedded"endlocal imageif manifestUrl ~= "embedded" thenlocal manifest, err = loadManifest(manifestUrl)if not manifest thenlog("Manifest error: " .. err)log("Falling back to embedded image.")elselocal bundle, downloadErr = downloadFiles(manifest)if not bundle thenlog("Download error: " .. downloadErr)log("Falling back to embedded image.")elseimage = bundleendendendif not image thenimage = EMBEDDED_IMAGEendif not promptConfirm() thenlog("Installation cancelled.")returnend-- Ensure we have data before wiping the disk.formatDisk()installImage(image)-- Persist the installed manifest/image so users can verify what was applied.pcall(function()if type(textutils) == "table" and textutils.serializeJSON thenwriteFile("/arcadesys_installed_manifest.json", textutils.serializeJSON(image))elsewriteFile("/arcadesys_installed_manifest.json", "{ \"name\": \"" .. tostring(image.name) .. "\", \"version\": \"" .. tostring(image.version) .. "\" }")endend)log("Installation complete.")summarizeInstall(image)print("")term.write("Press Enter to reboot (or type 'cancel' to stay): ")local resp = string.lower(read() or "")if resp == "cancel" or resp == "c" or resp == "no" thenlog("Reboot skipped by user.")returnendlog("Rebooting...")sleep(1)os.reboot()endmain()]=========]
files['printer.lua'] = [======[-- Ensure package path is set (in case startup didn't run or we are in a fresh shell)if not string.find(package.path, "/lib/?.lua") thenpackage.path = package.path .. ";/?.lua;/lib/?.lua;/factory/?.lua"endlocal menu = require("lib_menu")local function getJsonFiles()local files = {}-- Helper to add fileslocal function scan(dir, prefix)if not fs.exists(dir) or not fs.isDir(dir) then return endlocal list = fs.list(dir)for _, file in ipairs(list) doif file:match("%.json$") thentable.insert(files, (prefix or "") .. file)endendendscan("", "")scan("disk", "disk/")return filesendlocal function main()
    while true do
        local files = getJsonFiles()

        if #files == 0 then
            print("No .json schema files found.")print("Create one in the Designer or insert a disk.")print("Press any key to exit.")os.pullEvent("key")returnendlocal options = {}for _, f in ipairs(files) dotable.insert(options, f)endtable.insert(options, "Exit")local choice = menu.run("Select Schema to Print", options)if choice == #options thenterm.clear()term.setCursorPos(1, 1)returnendlocal selectedFile = files[choice]term.clear()term.setCursorPos(1, 1)print("Selected: " .. selectedFile)print("Launching Factory Agent...")sleep(1)-- Run the factory agentshell.run("/factory/main.lua", selectedFile)-- After run, return to menu? Or exit?-- Usually better to exit so user sees the output.print("\nPress any key to return to menu...")
        os.pullEvent("key")
    end
end

local function runWithMonitor(fn)
    local ok, monitorUtil = pcall(require, "lib_monitor")
    if ok and monitorUtil and monitorUtil.runOnMonitor then
        return monitorUtil.runOnMonitor(fn, { textScale = 0.5 })
    end
    return fn()
end

runWithMonitor(main)]======]
files['factory/schema_farm_tree.txt'] = [=======[legend:
. = minecraft:air
D = minecraft:dirt
S = minecraft:oak_sapling
# = minecraft:stone_bricks

meta:
mode = treefarm

layer:0
#####
#DDD#
#DDD#
#DDD#
#####

layer:1
.....
.S.S.
.....
.S.S.
.....
]=======]
files['factory/schema_farm_potato.txt'] = [=========[legend:
. = minecraft:air
D = minecraft:dirt
W = minecraft:water_bucket
P = minecraft:potatoes
# = minecraft:stone_bricks

meta:
mode = potatofarm

layer:0
#####
#DDD#
#DWD#
#DDD#
#####

layer:1
.....
.PPP.
.P.P.
.PPP.
.....
]=========]
files['startup.lua'] = [=====[-- startup.lua
-- Simplified launcher for TurtleOS

package.path = package.path .. ";/?.lua;/lib/?.lua"

if fs.exists("factory/turtle_os.lua") then
    shell.run("factory/turtle_os.lua")
elseif fs.exists("/factory/turtle_os.lua") then
    shell.run("/factory/turtle_os.lua")
else
    print("Error: factory/turtle_os.lua not found.")
end]=====]
files['manifest.json'] = [[{
    "name":  "Arcadesys Workstation",
    "version":  "1.0.6",
    "description":  "Manifest downloaded by install.lua from the main GitHub branch.",
    "files":  [
                  {
                      "path":  "arcade/data/programs.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/arcade/data/programs.lua"
                  },
                  {
                      "path":  "arcade/data/valhelsia_blocks.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/arcade/data/valhelsia_blocks.lua"
                  },
                  {
                      "path":  "arcade/ui/renderer.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/arcade/ui/renderer.lua"
                  },
                  {
                      "path":  "arcade/boot.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/arcade/boot.lua"
                  },
                  {
                      "path":  "factory/dist/factory.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/factory/dist/factory.lua"
                  },
                  {
                      "path":  "factory/factory.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/factory/factory.lua"
                  },
                  {
                      "path":  "factory/main.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/factory/main.lua"
                  },
                  {
                      "path":  "factory/state_blocked.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/factory/state_blocked.lua"
                  },
                  {
                      "path":  "factory/state_branchmine.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/factory/state_branchmine.lua"
                  },
                  {
                      "path":  "factory/state_build.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/factory/state_build.lua"
                  },
                  {
                      "path":  "factory/state_check_requirements.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/factory/state_check_requirements.lua"
                  },
                  {
                      "path":  "factory/state_done.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/factory/state_done.lua"
                  },
                  {
                      "path":  "factory/state_error.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/factory/state_error.lua"
                  },
                  {
                      "path":  "factory/state_initialize.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/factory/state_initialize.lua"
                  },
                  {
                      "path":  "factory/state_mine.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/factory/state_mine.lua"
                  },
                  {
                      "path":  "factory/state_potatofarm.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/factory/state_potatofarm.lua"
                  },
                  {
                      "path":  "factory/state_refuel.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/factory/state_refuel.lua"
                  },
                  {
                      "path":  "factory/state_restock.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/factory/state_restock.lua"
                  },
                  {
                      "path":  "factory/state_treefarm.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/factory/state_treefarm.lua"
                  },
                  {
                      "path":  "factory/turtle_os.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/factory/turtle_os.lua"
                  },
                  {
                      "path":  "lib/lib_cards.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/lib/lib_cards.lua"
                  },
                  {
                      "path":  "lib/lib_designer.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/lib/lib_designer.lua"
                  },
                  {
                      "path":  "lib/lib_diagnostics.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/lib/lib_diagnostics.lua"
                  },
                  {
                      "path":  "lib/lib_farming.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/lib/lib_farming.lua"
                  },
                  {
                      "path":  "lib/lib_fs.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/lib/lib_fs.lua"
                  },
                  {
                      "path":  "lib/lib_fuel.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/lib/lib_fuel.lua"
                  },
                  {
                      "path":  "lib/lib_games.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/lib/lib_games.lua"
                  },
                  {
                      "path":  "lib/lib_gps.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/lib/lib_gps.lua"
                  },
                  {
                      "path":  "lib/lib_initialize.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/lib/lib_initialize.lua"
                  },
                  {
                      "path":  "lib/lib_inventory.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/lib/lib_inventory.lua"
                  },
                  {
                      "path":  "lib/lib_items.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/lib/lib_items.lua"
                  },
                  {
                      "path":  "lib/lib_json.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/lib/lib_json.lua"
                  },
                  {
                      "path":  "lib/lib_license.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/lib/lib_license.lua"
                  },
                  {
                      "path":  "lib/lib_logger.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/lib/lib_logger.lua"
                  },
                  {
                      "path":  "lib/lib_menu.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/lib/lib_menu.lua"
                  },
                  {
                      "path":  "lib/lib_mining.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/lib/lib_mining.lua"
                  },
                  {
                      "path":  "lib/lib_monitor.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/lib/lib_monitor.lua"
                  },
                  {
                      "path":  "lib/lib_movement.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/lib/lib_movement.lua"
                  },
                  {
                      "path":  "lib/lib_navigation.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/lib/lib_navigation.lua"
                  },
                  {
                      "path":  "lib/lib_network.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/lib/lib_network.lua"
                  },
                  {
                      "path":  "lib/lib_orientation.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/lib/lib_orientation.lua"
                  },
                  {
                      "path":  "lib/lib_parser.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/lib/lib_parser.lua"
                  },
                  {
                      "path":  "lib/lib_placement.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/lib/lib_placement.lua"
                  },
                  {
                      "path":  "lib/lib_persistence.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/lib/lib_persistence.lua"
                  },
                  {
                      "path":  "lib/lib_reporter.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/lib/lib_reporter.lua"
                  },
                  {
                      "path":  "lib/lib_schema.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/lib/lib_schema.lua"
                  },
                  {
                      "path":  "lib/lib_startup.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/lib/lib_startup.lua"
                  },
                  {
                      "path":  "lib/lib_strategy.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/lib/lib_strategy.lua"
                  },
                  {
                      "path":  "lib/lib_strategy_branchmine.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/lib/lib_strategy_branchmine.lua"
                  },
                  {
                      "path":  "lib/lib_strategy_excavate.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/lib/lib_strategy_excavate.lua"
                  },
                  {
                      "path":  "lib/lib_strategy_farm.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/lib/lib_strategy_farm.lua"
                  },
                  {
                      "path":  "lib/lib_strategy_tunnel.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/lib/lib_strategy_tunnel.lua"
                  },
                  {
                      "path":  "lib/lib_string.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/lib/lib_string.lua"
                  },
                  {
                      "path":  "lib/lib_table.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/lib/lib_table.lua"
                  },
                  {
                      "path":  "lib/lib_ui.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/lib/lib_ui.lua"
                  },
                  {
                      "path":  "lib/lib_wizard.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/lib/lib_wizard.lua"
                  },
                  {
                      "path":  "lib/lib_world.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/lib/lib_world.lua"
                  },
                  {
                      "path":  "lib/lib_worldstate.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/lib/lib_worldstate.lua"
                  },
                  {
                      "path":  "lib/log.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/lib/log.lua"
                  },
                  {
                      "path":  "lib/version.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/lib/version.lua"
                  },
                  {
                      "path":  "ui/hub.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/ui/hub.lua"
                  },
                  {
                      "path":  "ui/trash_config.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/ui/trash_config.lua"
                  },
                  {
                      "path":  "ae2_drive_monitor.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/ae2_drive_monitor.lua"
                  },
                  {
                      "path":  "ae2_me_bridge_monitor.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/ae2_me_bridge_monitor.lua"
                  },
                  {
                      "path":  "arcadesys_os.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/arcadesys_os.lua"
                  },
                  {
                      "path":  "factory_planner.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/factory_planner.lua"
                  },
                  {
                      "path":  "install.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/install.lua"
                  },
                  {
                      "path":  "printer.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/printer.lua"
                  },
                  {
                      "path":  "factory/schema_farm_tree.txt",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/factory/schema_farm_tree.txt"
                  },
                  {
                      "path":  "factory/schema_farm_potato.txt",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/factory/schema_farm_potato.txt"
                  },
                  {
                      "path":  "startup.lua",
                      "url":  "https://raw.githubusercontent.com/Arcadesys/computercraft_scripts/main/startup.lua"
                  }
              ]
}
]]

-- Installer Logic
print('Installing files (Part 4)...')
for path, content in pairs(files) do
    local dir = fs.getDir(path)
    if not fs.exists(dir) then
        fs.makeDir(dir)
    end
    local f = fs.open(path, 'w')
    f.write(content)
    f.close()
    print('Installed: ' .. path)
end
print('Part 4 complete.')
print('Run the next part if available.')
